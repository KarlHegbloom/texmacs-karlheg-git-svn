(letrec ((lambda-var-list (lambda (vars203) (let lvl ((vars204 vars203) (ls (quote ())) (w205 (quote (())))) (cond ((pair? vars204) (lvl (cdr vars204) (cons (wrap (car vars204) w205) ls) w205)) ((id? vars204) (cons (wrap vars204 w205) ls)) ((null? vars204) ls) ((syntax-object? vars204) (lvl (syntax-object-expression vars204) ls (join-wraps w205 (syntax-object-wrap vars204)))) ((annotation? vars204) (lvl (annotation-expression vars204) ls w205)) (else (cons vars204 ls)))))) (gen-var (lambda (id206) (let ((id207 (if (syntax-object? id206) (syntax-object-expression id206) id206))) (if (annotation? id207) (gensym (annotation-expression id207) generated-symbols) (gensym id207 generated-symbols))))) (strip (lambda (x208 w209) (if (memq (quote top) (wrap-marks w209)) (if (or (annotation? x208) (and (pair? x208) (annotation? (car x208)))) (strip-annotation x208 (quote #f)) x208) (let f210 ((x211 x208)) (cond ((syntax-object? x211) (strip (syntax-object-expression x211) (syntax-object-wrap x211))) ((pair? x211) (let ((a (f210 (car x211))) (d (f210 (cdr x211)))) (if (and (eq? a (car x211)) (eq? d (cdr x211))) x211 (cons a d)))) ((vector? x211) (let ((old212 (vector->list x211))) (let ((new213 (map f210 old212))) (if (andmap eq? old212 new213) x211 (list->vector new213))))) (else x211)))))) (strip-annotation (lambda (x214 parent) (cond ((pair? x214) (let ((new215 (cons (quote #f) (quote #f)))) (begin (when parent (set-annotation-stripped! parent new215)) (set-car! new215 (strip-annotation (car x214) (quote #f))) (set-cdr! new215 (strip-annotation (cdr x214) (quote #f))) new215))) ((annotation? x214) (or (annotation-stripped x214) (strip-annotation (annotation-expression x214) x214))) ((vector? x214) (let ((new216 (make-vector (vector-length x214)))) (begin (when parent (set-annotation-stripped! parent new216)) (let loop ((i217 (- (vector-length x214) (quote 1)))) (unless (fx< i217 (quote 0)) (vector-set! new216 i217 (strip-annotation (vector-ref x214 i217) (quote #f))) (loop (fx- i217 (quote 1))))) new216))) (else x214)))) (ellipsis? (lambda (x218) (and (nonsymbol-id? x218) (free-id=? x218 (quote #(syntax-object ... ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-wrap! set-syntax-object-expression! syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object self-evaluating? build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application get-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook annotation? fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i"))))))))) (chi-void (lambda () (list (quote void)))) (eval-local-transformer (lambda (expanded) (let ((p (local-eval-hook expanded))) (if (procedure? p) p (syntax-error p (quote "nonprocedure transfomer")))))) (chi-local-syntax (lambda (rec? e219 r w220 s k) ((lambda (tmp221) ((lambda (tmp222) (if tmp222 (apply (lambda (_223 id224 val e1 e2) (let ((ids225 id224)) (if (not (valid-bound-ids? ids225)) (syntax-error e219 (quote "duplicate bound keyword in")) (let ((labels (gen-labels ids225))) (let ((new-w (make-binding-wrap ids225 labels w220))) (k (cons e1 e2) (extend-env labels (let ((w228 (if rec? new-w w220)) (trans-r (macros-only-env r))) (map (lambda (x229) (cons (quote macro) (eval-local-transformer (chi x229 trans-r w228)))) val)) r) new-w s)))))) tmp222) ((lambda (_231) (syntax-error (source-wrap e219 w220 s))) tmp221))) (syntax-dispatch tmp221 (quote (any #(each (any any)) any . each-any))))) e219))) (chi-lambda-clause (lambda (e232 c r233 w234 k235) ((lambda (tmp236) ((lambda (tmp237) (if tmp237 (apply (lambda (id238 e1239 e2240) (let ((ids241 id238)) (if (not (valid-bound-ids? ids241)) (syntax-error e232 (quote "invalid parameter list in")) (let ((labels243 (gen-labels ids241)) (new-vars (map gen-var ids241))) (k235 new-vars (chi-body (cons e1239 e2240) e232 (extend-var-env labels243 new-vars r233) (make-binding-wrap ids241 labels243 w234))))))) tmp237) ((lambda (tmp245) (if tmp245 (apply (lambda (ids246 e1247 e2248) (let ((old-ids (lambda-var-list ids246))) (if (not (valid-bound-ids? old-ids)) (syntax-error e232 (quote "invalid parameter list in")) (let ((labels249 (gen-labels old-ids)) (new-vars250 (map gen-var old-ids))) (k235 (let f251 ((ls1 (cdr new-vars250)) (ls2 (car new-vars250))) (if (null? ls1) ls2 (f251 (cdr ls1) (cons (car ls1) ls2)))) (chi-body (cons e1247 e2248) e232 (extend-var-env labels249 new-vars250 r233) (make-binding-wrap old-ids labels249 w234))))))) tmp245) ((lambda (_253) (syntax-error e232)) tmp236))) (syntax-dispatch tmp236 (quote (any any . each-any)))))) (syntax-dispatch tmp236 (quote (each-any any . each-any))))) c))) (chi-body (lambda (body outer-form r254 w255) (let ((r256 (cons (quote ("placeholder" placeholder)) r254))) (let ((ribcage (make-ribcage (quote ()) (quote ()) (quote ())))) (let ((w257 (make-wrap (wrap-marks w255) (cons ribcage (wrap-subst w255))))) (let parse ((body258 (map (lambda (x262) (cons r256 (wrap x262 w257))) body)) (ids259 (quote ())) (labels260 (quote ())) (vars261 (quote ())) (vals (quote ())) (bindings (quote ()))) (if (null? body258) (syntax-error outer-form (quote "no expressions in body")) (let ((e263 (cdar body258)) (er (caar body258))) (call-with-values (lambda () (syntax-type e263 er (quote (())) (quote #f) ribcage)) (lambda (type264 value265 e266 w267 s268) (let ((t type264)) (if (memv t (quote (define-form))) (let ((id269 (wrap value265 w267)) (label (gen-label))) (let ((var270 (gen-var id269))) (begin (extend-ribcage! ribcage id269 label) (parse (cdr body258) (cons id269 ids259) (cons label labels260) (cons var270 vars261) (cons (cons er (wrap e266 w267)) vals) (cons (cons (quote lexical) var270) bindings))))) (if (memv t (quote (define-syntax-form))) (let ((id271 (wrap value265 w267)) (label272 (gen-label))) (begin (extend-ribcage! ribcage id271 label272) (parse (cdr body258) (cons id271 ids259) (cons label272 labels260) vars261 vals (cons (cons (quote macro) (cons er (wrap e266 w267))) bindings)))) (if (memv t (quote (begin-form))) ((lambda (tmp273) ((lambda (tmp274) (if tmp274 (apply (lambda (_275 e1276) (parse (let f277 ((forms e1276)) (if (null? forms) (cdr body258) (cons (cons er (wrap (car forms) w267)) (f277 (cdr forms))))) ids259 labels260 vars261 vals bindings)) tmp274) (syntax-error tmp273))) (syntax-dispatch tmp273 (quote (any . each-any))))) e266) (if (memv t (quote (local-syntax-form))) (chi-local-syntax value265 e266 er w267 s268 (lambda (forms279 er280 w281 s282) (parse (let f283 ((forms284 forms279)) (if (null? forms284) (cdr body258) (cons (cons er280 (wrap (car forms284) w281)) (f283 (cdr forms284))))) ids259 labels260 vars261 vals bindings))) (if (null? ids259) (build-sequence (quote #f) (map (lambda (x285) (chi (cdr x285) (car x285) (quote (())))) (cons (cons er (source-wrap e266 w267 s268)) (cdr body258)))) (begin (if (not (valid-bound-ids? ids259)) (syntax-error outer-form (quote "invalid or duplicate identifier in definition"))) (let loop286 ((bs bindings) (er-cache (quote #f)) (r-cache (quote #f))) (if (not (null? bs)) (let ((b (car bs))) (if (eq? (car b) (quote macro)) (let ((er287 (cadr b))) (let ((r-cache288 (if (eq? er287 er-cache) r-cache (macros-only-env er287)))) (begin (set-cdr! b (eval-local-transformer (chi (cddr b) r-cache288 (quote (()))))) (loop286 (cdr bs) er287 r-cache288)))) (loop286 (cdr bs) er-cache r-cache))))) (set-cdr! r256 (extend-env labels260 bindings (cdr r256))) (build-letrec (quote #f) vars261 (map (lambda (x289) (chi (cdr x289) (car x289) (quote (())))) vals) (build-sequence (quote #f) (map (lambda (x290) (chi (cdr x290) (car x290) (quote (())))) (cons (cons er (source-wrap e266 w267 s268)) (cdr body258)))))))))))))))))))))) (chi-macro (lambda (p291 e292 r293 w294 rib) (letrec ((rebuild-macro-output (lambda (x295 m) (cond ((pair? x295) (cons (rebuild-macro-output (car x295) m) (rebuild-macro-output (cdr x295) m))) ((syntax-object? x295) (let ((w296 (syntax-object-wrap x295))) (let ((ms (wrap-marks w296)) (s297 (wrap-subst w296))) (make-syntax-object (syntax-object-expression x295) (if (and (pair? ms) (eq? (car ms) (quote #f))) (make-wrap (cdr ms) (if rib (cons rib (cdr s297)) (cdr s297))) (make-wrap (cons m ms) (if rib (cons rib (cons (quote shift) s297)) (cons (quote shift) s297)))))))) ((vector? x295) (let ((n (vector-length x295))) (let ((v (make-vector n))) (let doloop ((i298 (quote 0))) (if (fx= i298 n) v (begin (vector-set! v i298 (rebuild-macro-output (vector-ref x295 i298) m)) (doloop (fx+ i298 (quote 1))))))))) ((symbol? x295) (syntax-error x295 (quote "encountered raw symbol in macro output"))) (else x295))))) (rebuild-macro-output (p291 (wrap e292 (anti-mark w294))) (string (quote #\m)))))) (chi-application (lambda (x299 e300 r301 w302 s303) ((lambda (tmp304) ((lambda (tmp305) (if tmp305 (apply (lambda (e0 e1306) (cons x299 (map (lambda (e307) (chi e307 r301 w302)) e1306))) tmp305) (syntax-error tmp304))) (syntax-dispatch tmp304 (quote (any . each-any))))) e300))) (chi-expr (lambda (type309 value310 e311 r312 w313 s314) (let ((t315 type309)) (if (memv t315 (quote (lexical))) value310 (if (memv t315 (quote (core))) (value310 e311 r312 w313 s314) (if (memv t315 (quote (lexical-call))) (chi-application value310 e311 r312 w313 s314) (if (memv t315 (quote (global-call))) (chi-application value310 e311 r312 w313 s314) (if (memv t315 (quote (constant))) (list (quote quote) (strip (source-wrap e311 w313 s314) (quote (())))) (if (memv t315 (quote (global))) value310 (if (memv t315 (quote (call))) (chi-application (chi (car e311) r312 w313) e311 r312 w313 s314) (if (memv t315 (quote (begin-form))) ((lambda (tmp316) ((lambda (tmp317) (if tmp317 (apply (lambda (_318 e1319 e2320) (chi-sequence (cons e1319 e2320) r312 w313 s314)) tmp317) (syntax-error tmp316))) (syntax-dispatch tmp316 (quote (any any . each-any))))) e311) (if (memv t315 (quote (local-syntax-form))) (chi-local-syntax value310 e311 r312 w313 s314 chi-sequence) (if (memv t315 (quote (eval-when-form))) ((lambda (tmp322) ((lambda (tmp323) (if tmp323 (apply (lambda (_324 x325 e1326 e2327) (let ((when-list (chi-when-list e311 x325 w313))) (if (memq (quote eval) when-list) (chi-sequence (cons e1326 e2327) r312 w313 s314) (chi-void)))) tmp323) (syntax-error tmp322))) (syntax-dispatch tmp322 (quote (any each-any any . each-any))))) e311) (if (memv t315 (quote (define-form define-syntax-form))) (syntax-error (wrap value310 w313) (quote "invalid context for definition of")) (if (memv t315 (quote (syntax))) (syntax-error (source-wrap e311 w313 s314) (quote "reference to pattern variable outside syntax form")) (if (memv t315 (quote (displaced-lexical))) (syntax-error (source-wrap e311 w313 s314) (quote "reference to identifier outside its scope")) (syntax-error (source-wrap e311 w313 s314)))))))))))))))))) (chi (lambda (e330 r331 w332) (call-with-values (lambda () (syntax-type e330 r331 w332 (quote #f) (quote #f))) (lambda (type333 value334 e335 w336 s337) (chi-expr type333 value334 e335 r331 w336 s337))))) (chi-top (lambda (e338 r339 w340 m341 esew) (call-with-values (lambda () (syntax-type e338 r339 w340 (quote #f) (quote #f))) (lambda (type348 value349 e350 w351 s352) (let ((t353 type348)) (if (memv t353 (quote (begin-form))) ((lambda (tmp354) ((lambda (tmp355) (if tmp355 (apply (lambda (_356) (chi-void)) tmp355) ((lambda (tmp357) (if tmp357 (apply (lambda (_358 e1359 e2360) (chi-top-sequence (cons e1359 e2360) r339 w351 s352 m341 esew)) tmp357) (syntax-error tmp354))) (syntax-dispatch tmp354 (quote (any any . each-any)))))) (syntax-dispatch tmp354 (quote (any))))) e350) (if (memv t353 (quote (local-syntax-form))) (chi-local-syntax value349 e350 r339 w351 s352 (lambda (body362 r363 w364 s365) (chi-top-sequence body362 r363 w364 s365 m341 esew))) (if (memv t353 (quote (eval-when-form))) ((lambda (tmp366) ((lambda (tmp367) (if tmp367 (apply (lambda (_368 x369 e1370 e2371) (let ((when-list372 (chi-when-list e350 x369 w351)) (body373 (cons e1370 e2371))) (cond ((eq? m341 (quote e)) (if (memq (quote eval) when-list372) (chi-top-sequence body373 r339 w351 s352 (quote e) (quote (eval))) (chi-void))) ((memq (quote load) when-list372) (if (or (memq (quote compile) when-list372) (and (eq? m341 (quote c&e)) (memq (quote eval) when-list372))) (chi-top-sequence body373 r339 w351 s352 (quote c&e) (quote (compile load))) (if (memq m341 (quote (c c&e))) (chi-top-sequence body373 r339 w351 s352 (quote c) (quote (load))) (chi-void)))) ((or (memq (quote compile) when-list372) (and (eq? m341 (quote c&e)) (memq (quote eval) when-list372))) (top-level-eval-hook (chi-top-sequence body373 r339 w351 s352 (quote e) (quote (eval)))) (chi-void)) (else (chi-void))))) tmp367) (syntax-error tmp366))) (syntax-dispatch tmp366 (quote (any each-any any . each-any))))) e350) (if (memv t353 (quote (define-syntax-form))) (let ((n376 (id-var-name value349 w351)) (r377 (macros-only-env r339))) (let ((t378 m341)) (if (memv t378 (quote (c))) (if (memq (quote compile) esew) (let ((e379 (chi-install-global n376 (chi e350 r377 w351)))) (begin (top-level-eval-hook e379) (if (memq (quote load) esew) e379 (chi-void)))) (if (memq (quote load) esew) (chi-install-global n376 (chi e350 r377 w351)) (chi-void))) (if (memv t378 (quote (c&e))) (let ((e380 (chi-install-global n376 (chi e350 r377 w351)))) (begin (top-level-eval-hook e380) e380)) (begin (if (memq (quote eval) esew) (top-level-eval-hook (chi-install-global n376 (chi e350 r377 w351)))) (chi-void)))))) (if (memv t353 (quote (define-form))) (let ((n381 (id-var-name value349 w351))) (let ((t382 (binding-type (lookup n381 r339)))) (if (memv t382 (quote (global))) (let ((x383 (list (quote define) n381 (chi e350 r339 w351)))) (begin (if (eq? m341 (quote c&e)) (top-level-eval-hook x383)) x383)) (if (memv t382 (quote (displaced-lexical))) (syntax-error (wrap value349 w351) (quote "identifier out of context")) (syntax-error (wrap value349 w351) (quote "cannot define keyword at top level")))))) (let ((x384 (chi-expr type348 value349 e350 r339 w351 s352))) (begin (if (eq? m341 (quote c&e)) (top-level-eval-hook x384)) x384)))))))))))) (syntax-type (lambda (e385 r386 w387 s388 rib389) (cond ((symbol? e385) (let ((n390 (id-var-name e385 w387))) (let ((b391 (lookup n390 r386))) (let ((type392 (binding-type b391))) (let ((t393 type392)) (if (memv t393 (quote (lexical))) (values type392 (binding-value b391) e385 w387 s388) (if (memv t393 (quote (global))) (values type392 n390 e385 w387 s388) (if (memv t393 (quote (macro))) (syntax-type (chi-macro (binding-value b391) e385 r386 w387 rib389) r386 (quote (())) s388 rib389) (values type392 (binding-value b391) e385 w387 s388))))))))) ((pair? e385) (let ((first (car e385))) (if (id? first) (let ((n394 (id-var-name first w387))) (let ((b395 (lookup n394 r386))) (let ((type396 (binding-type b395))) (let ((t397 type396)) (if (memv t397 (quote (lexical))) (values (quote lexical-call) (binding-value b395) e385 w387 s388) (if (memv t397 (quote (global))) (values (quote global-call) n394 e385 w387 s388) (if (memv t397 (quote (macro))) (syntax-type (chi-macro (binding-value b395) e385 r386 w387 rib389) r386 (quote (())) s388 rib389) (if (memv t397 (quote (core))) (values type396 (binding-value b395) e385 w387 s388) (if (memv t397 (quote (local-syntax))) (values (quote local-syntax-form) (binding-value b395) e385 w387 s388) (if (memv t397 (quote (begin))) (values (quote begin-form) (quote #f) e385 w387 s388) (if (memv t397 (quote (eval-when))) (values (quote eval-when-form) (quote #f) e385 w387 s388) (if (memv t397 (quote (define))) ((lambda (tmp398) ((lambda (tmp399) (if (if tmp399 (apply (lambda (_400 name401 val402) (id? name401)) tmp399) (quote #f)) (apply (lambda (_403 name404 val405) (values (quote define-form) name404 val405 w387 s388)) tmp399) ((lambda (tmp406) (if (if tmp406 (apply (lambda (_407 name408 args409 e1410 e2411) (and (id? name408) (or (valid-bound-ids? (lambda-var-list args409)) (id? (lambda-var-list args409))))) tmp406) (quote #f)) (apply (lambda (_412 name413 args414 e1415 e2416) (values (quote define-form) (wrap name413 w387) (cons (quote #(syntax-object lambda ((top) #(ribcage #(_ name args e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(t) #(("m" top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(e r w s rib) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-wrap! set-syntax-object-expression! syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object self-evaluating? build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application get-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook annotation? fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i"))))) (wrap (cons args414 (cons e1415 e2416)) w387)) (quote (())) s388)) tmp406) ((lambda (tmp418) (if (if tmp418 (apply (lambda (_419 name420) (id? name420)) tmp418) (quote #f)) (apply (lambda (_421 name422) (values (quote define-form) (wrap name422 w387) (quote (#(syntax-object void ((top) #(ribcage #(_ name) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(t) #(("m" top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(e r w s rib) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-wrap! set-syntax-object-expression! syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object self-evaluating? build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application get-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook annotation? fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i")))))) (quote (())) s388)) tmp418) (syntax-error tmp398))) (syntax-dispatch tmp398 (quote (any any)))))) (syntax-dispatch tmp398 (quote (any (any . any) any . each-any)))))) (syntax-dispatch tmp398 (quote (any any any))))) e385) (if (memv t397 (quote (define-syntax))) ((lambda (tmp423) ((lambda (tmp424) (if (if tmp424 (apply (lambda (_425 name426 val427) (id? name426)) tmp424) (quote #f)) (apply (lambda (_428 name429 val430) (values (quote define-syntax-form) name429 val430 w387 s388)) tmp424) (syntax-error tmp423))) (syntax-dispatch tmp423 (quote (any any any))))) e385) (values (quote call) (quote #f) e385 w387 s388)))))))))))))) (values (quote call) (quote #f) e385 w387 s388)))) ((syntax-object? e385) (syntax-type (syntax-object-expression e385) r386 (join-wraps w387 (syntax-object-wrap e385)) (quote #f) rib389)) ((annotation? e385) (syntax-type (annotation-expression e385) r386 w387 (annotation-source e385) rib389)) ((let ((x431 e385)) (or (boolean? x431) (number? x431) (string? x431) (char? x431) (null? x431) (keyword? x431))) (values (quote constant) (quote #f) e385 w387 s388)) (else (values (quote other) (quote #f) e385 w387 s388))))) (chi-when-list (lambda (e432 when-list433 w434) (let f435 ((when-list436 when-list433) (situations (quote ()))) (if (null? when-list436) situations (f435 (cdr when-list436) (cons (let ((x437 (car when-list436))) (cond ((free-id=? x437 (quote #(syntax-object compile ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-wrap! set-syntax-object-expression! syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object self-evaluating? build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application get-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook annotation? fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i")))))) (quote compile)) ((free-id=? x437 (quote #(syntax-object load ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-wrap! set-syntax-object-expression! syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object self-evaluating? build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application get-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook annotation? fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i")))))) (quote load)) ((free-id=? x437 (quote #(syntax-object eval ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-wrap! set-syntax-object-expression! syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object self-evaluating? build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application get-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook annotation? fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i")))))) (quote eval)) (else (syntax-error (wrap x437 w434) (quote "invalid eval-when situation"))))) situations)))))) (chi-install-global (lambda (name438 e439) (list (quote install-global-transformer) (list (quote quote) name438) e439))) (chi-top-sequence (lambda (body440 r441 w442 s443 m444 esew445) (build-sequence s443 (let dobody ((body446 body440) (r447 r441) (w448 w442) (m449 m444) (esew450 esew445)) (if (null? body446) (quote ()) (let ((first451 (chi-top (car body446) r447 w448 m449 esew450))) (cons first451 (dobody (cdr body446) r447 w448 m449 esew450)))))))) (chi-sequence (lambda (body452 r453 w454 s455) (build-sequence s455 (let dobody456 ((body457 body452) (r458 r453) (w459 w454)) (if (null? body457) (quote ()) (let ((first460 (chi (car body457) r458 w459))) (cons first460 (dobody456 (cdr body457) r458 w459)))))))) (source-wrap (lambda (x461 w462 s463) (wrap (if s463 (make-annotation x461 s463 (quote #f)) x461) w462))) (wrap (lambda (x464 w465) (cond ((and (null? (wrap-marks w465)) (null? (wrap-subst w465))) x464) ((syntax-object? x464) (make-syntax-object (syntax-object-expression x464) (join-wraps w465 (syntax-object-wrap x464)))) ((null? x464) x464) (else (make-syntax-object x464 w465))))) (bound-id-member? (lambda (x466 list) (and (not (null? list)) (or (bound-id=? x466 (car list)) (bound-id-member? x466 (cdr list)))))) (distinct-bound-ids? (lambda (ids467) (let distinct? ((ids468 ids467)) (or (null? ids468) (and (not (bound-id-member? (car ids468) (cdr ids468))) (distinct? (cdr ids468))))))) (valid-bound-ids? (lambda (ids469) (and (let all-ids? ((ids470 ids469)) (or (null? ids470) (and (id? (car ids470)) (all-ids? (cdr ids470))))) (distinct-bound-ids? ids469)))) (bound-id=? (lambda (i471 j) (if (and (syntax-object? i471) (syntax-object? j)) (and (eq? (let ((e472 (syntax-object-expression i471))) (if (annotation? e472) (annotation-expression e472) e472)) (let ((e473 (syntax-object-expression j))) (if (annotation? e473) (annotation-expression e473) e473))) (same-marks? (wrap-marks (syntax-object-wrap i471)) (wrap-marks (syntax-object-wrap j)))) (eq? (let ((e474 i471)) (if (annotation? e474) (annotation-expression e474) e474)) (let ((e475 j)) (if (annotation? e475) (annotation-expression e475) e475)))))) (free-id=? (lambda (i476 j477) (and (eq? (let ((x478 i476)) (let ((e479 (if (syntax-object? x478) (syntax-object-expression x478) x478))) (if (annotation? e479) (annotation-expression e479) e479))) (let ((x480 j477)) (let ((e481 (if (syntax-object? x480) (syntax-object-expression x480) x480))) (if (annotation? e481) (annotation-expression e481) e481)))) (eq? (id-var-name i476 (quote (()))) (id-var-name j477 (quote (()))))))) (id-var-name (lambda (id482 w483) (letrec ((search-vector-rib (lambda (sym subst marks489 symnames ribcage490) (let ((n491 (vector-length symnames))) (let f492 ((i493 (quote 0))) (cond ((fx= i493 n491) (search sym (cdr subst) marks489)) ((and (eq? (vector-ref symnames i493) sym) (same-marks? marks489 (vector-ref (ribcage-marks ribcage490) i493))) (values (vector-ref (ribcage-labels ribcage490) i493) marks489)) (else (f492 (fx+ i493 (quote 1))))))))) (search-list-rib (lambda (sym494 subst495 marks496 symnames497 ribcage498) (let f499 ((symnames500 symnames497) (i501 (quote 0))) (cond ((null? symnames500) (search sym494 (cdr subst495) marks496)) ((and (eq? (car symnames500) sym494) (same-marks? marks496 (list-ref (ribcage-marks ribcage498) i501))) (values (list-ref (ribcage-labels ribcage498) i501) marks496)) (else (f499 (cdr symnames500) (fx+ i501 (quote 1)))))))) (search (lambda (sym502 subst503 marks504) (if (null? subst503) (values (quote #f) marks504) (let ((fst (car subst503))) (if (eq? fst (quote shift)) (search sym502 (cdr subst503) (cdr marks504)) (let ((symnames505 (ribcage-symnames fst))) (if (vector? symnames505) (search-vector-rib sym502 subst503 marks504 symnames505 fst) (search-list-rib sym502 subst503 marks504 symnames505 fst))))))))) (cond ((symbol? id482) (or (call-with-values (lambda () (search id482 (wrap-subst w483) (wrap-marks w483))) (lambda (x506 . ignore) x506)) id482)) ((syntax-object? id482) (let ((id507 (let ((e508 (syntax-object-expression id482))) (if (annotation? e508) (annotation-expression e508) e508))) (w1 (syntax-object-wrap id482))) (let ((marks509 (join-marks (wrap-marks w483) (wrap-marks w1)))) (call-with-values (lambda () (search id507 (wrap-subst w483) marks509)) (lambda (new-id marks510) (or new-id (call-with-values (lambda () (search id507 (wrap-subst w1) marks510)) (lambda (x512 . ignore511) x512)) id507)))))) ((annotation? id482) (let ((id513 (let ((e514 id482)) (if (annotation? e514) (annotation-expression e514) e514)))) (or (call-with-values (lambda () (search id513 (wrap-subst w483) (wrap-marks w483))) (lambda (x516 . ignore515) x516)) id513))) (else (error-hook (quote id-var-name) (quote "invalid id") id482)))))) (same-marks? (lambda (x517 y) (or (eq? x517 y) (and (not (null? x517)) (not (null? y)) (eq? (car x517) (car y)) (same-marks? (cdr x517) (cdr y)))))) (join-marks (lambda (m1 m2) (smart-append m1 m2))) (join-wraps (lambda (w1518 w2) (let ((m1519 (wrap-marks w1518)) (s1 (wrap-subst w1518))) (if (null? m1519) (if (null? s1) w2 (make-wrap (wrap-marks w2) (smart-append s1 (wrap-subst w2)))) (make-wrap (smart-append m1519 (wrap-marks w2)) (smart-append s1 (wrap-subst w2))))))) (smart-append (lambda (m1520 m2521) (if (null? m2521) m1520 (append m1520 m2521)))) (make-binding-wrap (lambda (ids522 labels523 w524) (if (null? ids522) w524 (make-wrap (wrap-marks w524) (cons (let ((labelvec (list->vector labels523))) (let ((n525 (vector-length labelvec))) (let ((symnamevec (make-vector n525)) (marksvec (make-vector n525))) (begin (let f526 ((ids527 ids522) (i528 (quote 0))) (if (not (null? ids527)) (call-with-values (lambda () (id-sym-name&marks (car ids527) w524)) (lambda (symname marks529) (begin (vector-set! symnamevec i528 symname) (vector-set! marksvec i528 marks529) (f526 (cdr ids527) (fx+ i528 (quote 1)))))))) (make-ribcage symnamevec marksvec labelvec))))) (wrap-subst w524)))))) (extend-ribcage! (lambda (ribcage530 id531 label532) (begin (set-ribcage-symnames! ribcage530 (cons (let ((e533 (syntax-object-expression id531))) (if (annotation? e533) (annotation-expression e533) e533)) (ribcage-symnames ribcage530))) (set-ribcage-marks! ribcage530 (cons (wrap-marks (syntax-object-wrap id531)) (ribcage-marks ribcage530))) (set-ribcage-labels! ribcage530 (cons label532 (ribcage-labels ribcage530)))))) (anti-mark (lambda (w534) (make-wrap (cons (quote #f) (wrap-marks w534)) (cons (quote shift) (wrap-subst w534))))) (set-ribcage-labels! (lambda (x535 update) (vector-set! x535 (quote 3) update))) (set-ribcage-marks! (lambda (x536 update537) (vector-set! x536 (quote 2) update537))) (set-ribcage-symnames! (lambda (x538 update539) (vector-set! x538 (quote 1) update539))) (ribcage-labels (lambda (x540) (vector-ref x540 (quote 3)))) (ribcage-marks (lambda (x541) (vector-ref x541 (quote 2)))) (ribcage-symnames (lambda (x542) (vector-ref x542 (quote 1)))) (ribcage? (lambda (x543) (and (vector? x543) (= (vector-length x543) (quote 4)) (eq? (vector-ref x543 (quote 0)) (quote ribcage))))) (make-ribcage (lambda (symnames544 marks545 labels546) (vector (quote ribcage) symnames544 marks545 labels546))) (gen-labels (lambda (ls547) (if (null? ls547) (quote ()) (cons (gen-label) (gen-labels (cdr ls547)))))) (gen-label (lambda () (string (quote #\i)))) (wrap-subst cdr) (wrap-marks car) (make-wrap cons) (id-sym-name&marks (lambda (x548 w549) (if (syntax-object? x548) (values (let ((e550 (syntax-object-expression x548))) (if (annotation? e550) (annotation-expression e550) e550)) (join-marks (wrap-marks w549) (wrap-marks (syntax-object-wrap x548)))) (values (let ((e551 x548)) (if (annotation? e551) (annotation-expression e551) e551)) (wrap-marks w549))))) (id? (lambda (x552) (cond ((symbol? x552) (quote #t)) ((syntax-object? x552) (symbol? (let ((e553 (syntax-object-expression x552))) (if (annotation? e553) (annotation-expression e553) e553)))) ((annotation? x552) (symbol? (annotation-expression x552))) (else (quote #f))))) (nonsymbol-id? (lambda (x554) (and (syntax-object? x554) (symbol? (let ((e555 (syntax-object-expression x554))) (if (annotation? e555) (annotation-expression e555) e555)))))) (global-extend (lambda (type556 sym557 val558) (put-global-definition-hook sym557 (cons type556 val558)))) (lookup (lambda (x559 r560) (cond ((assq x559 r560) => cdr) ((symbol? x559) (or (get-global-definition-hook x559) (quote (global)))) (else (quote (displaced-lexical)))))) (macros-only-env (lambda (r561) (if (null? r561) (quote ()) (let ((a562 (car r561))) (if (eq? (cadr a562) (quote macro)) (cons a562 (macros-only-env (cdr r561))) (macros-only-env (cdr r561))))))) (extend-var-env (lambda (labels563 vars564 r565) (if (null? labels563) r565 (extend-var-env (cdr labels563) (cdr vars564) (cons (cons (car labels563) (cons (quote lexical) (car vars564))) r565))))) (extend-env (lambda (labels566 bindings567 r568) (if (null? labels566) r568 (extend-env (cdr labels566) (cdr bindings567) (cons (cons (car labels566) (car bindings567)) r568))))) (binding-value cdr) (binding-type car) (source-annotation (lambda (x569) (cond ((annotation? x569) (annotation-source x569)) ((syntax-object? x569) (source-annotation (syntax-object-expression x569))) (else (quote #f))))) (set-syntax-object-wrap! (lambda (x570 update571) (vector-set! x570 (quote 2) update571))) (set-syntax-object-expression! (lambda (x572 update573) (vector-set! x572 (quote 1) update573))) (syntax-object-wrap (lambda (x574) (vector-ref x574 (quote 2)))) (syntax-object-expression (lambda (x575) (vector-ref x575 (quote 1)))) (syntax-object? (lambda (x576) (and (vector? x576) (= (vector-length x576) (quote 3)) (eq? (vector-ref x576 (quote 0)) (quote syntax-object))))) (make-syntax-object (lambda (expression wrap577) (vector (quote syntax-object) expression wrap577))) (build-letrec (lambda (src578 vars579 val-exps body-exp) (if (null? vars579) body-exp (list (quote letrec) (map list vars579 val-exps) body-exp)))) (build-named-let (lambda (src580 vars581 val-exps582 body-exp583) (if (null? vars581) body-exp583 (list (quote let) (car vars581) (map list (cdr vars581) val-exps582) body-exp583)))) (build-let (lambda (src584 vars585 val-exps586 body-exp587) (if (null? vars585) body-exp587 (list (quote let) (map list vars585 val-exps586) body-exp587)))) (build-sequence (lambda (src588 exps) (if (null? (cdr exps)) (car exps) (cons (quote begin) exps)))) (get-global-definition-hook (lambda (symbol) (getprop symbol (quote *sc-expander*)))) (put-global-definition-hook (lambda (symbol589 binding) (putprop symbol589 (quote *sc-expander*) binding))) (error-hook (lambda (who590 why what) (error who590 (quote "~a ~s") why what))) (local-eval-hook (lambda (x591) (eval (list noexpand x591)))) (top-level-eval-hook (lambda (x592) (eval (list noexpand x592)))) (annotation? (lambda (x593) (quote #f))) (fx< <) (fx= =) (fx- -) (fx+ +) (noexpand (quote "noexpand"))) (begin (global-extend (quote local-syntax) (quote letrec-syntax) (quote #t)) (global-extend (quote local-syntax) (quote let-syntax) (quote #f)) (global-extend (quote core) (quote fluid-let-syntax) (lambda (e594 r595 w596 s597) ((lambda (tmp598) ((lambda (tmp599) (if (if tmp599 (apply (lambda (_600 var601 val602 e1603 e2604) (valid-bound-ids? var601)) tmp599) (quote #f)) (apply (lambda (_606 var607 val608 e1609 e2610) (let ((names (map (lambda (x611) (id-var-name x611 w596)) var607))) (begin (for-each (lambda (id613 n614) (let ((t615 (binding-type (lookup n614 r595)))) (if (memv t615 (quote (displaced-lexical))) (syntax-error (source-wrap id613 w596 s597) (quote "identifier out of context"))))) var607 names) (chi-body (cons e1609 e2610) (source-wrap e594 w596 s597) (extend-env names (let ((trans-r618 (macros-only-env r595))) (map (lambda (x619) (cons (quote macro) (eval-local-transformer (chi x619 trans-r618 w596)))) val608)) r595) w596)))) tmp599) ((lambda (_621) (syntax-error (source-wrap e594 w596 s597))) tmp598))) (syntax-dispatch tmp598 (quote (any #(each (any any)) any . each-any))))) e594))) (global-extend (quote core) (quote quote) (lambda (e622 r623 w624 s625) ((lambda (tmp626) ((lambda (tmp627) (if tmp627 (apply (lambda (_628 e629) (list (quote quote) (strip e629 w624))) tmp627) ((lambda (_630) (syntax-error (source-wrap e622 w624 s625))) tmp626))) (syntax-dispatch tmp626 (quote (any any))))) e622))) (global-extend (quote core) (quote syntax) (letrec ((regen (lambda (x631) (let ((t632 (car x631))) (if (memv t632 (quote (ref))) (cadr x631) (if (memv t632 (quote (primitive))) (cadr x631) (if (memv t632 (quote (quote))) (list (quote quote) (cadr x631)) (if (memv t632 (quote (lambda))) (list (quote lambda) (cadr x631) (regen (caddr x631))) (if (memv t632 (quote (map))) (let ((ls633 (map regen (cdr x631)))) (cons (if (fx= (length ls633) (quote 2)) (quote map) (quote map)) ls633)) (cons (car x631) (map regen (cdr x631))))))))))) (gen-vector (lambda (x634) (cond ((eq? (car x634) (quote list)) (cons (quote vector) (cdr x634))) ((eq? (car x634) (quote quote)) (list (quote quote) (list->vector (cadr x634)))) (else (list (quote list->vector) x634))))) (gen-append (lambda (x635 y636) (if (equal? y636 (quote (quote ()))) x635 (list (quote append) x635 y636)))) (gen-cons (lambda (x637 y638) (let ((t639 (car y638))) (if (memv t639 (quote (quote))) (if (eq? (car x637) (quote quote)) (list (quote quote) (cons (cadr x637) (cadr y638))) (if (eq? (cadr y638) (quote ())) (list (quote list) x637) (list (quote cons) x637 y638))) (if (memv t639 (quote (list))) (cons (quote list) (cons x637 (cdr y638))) (list (quote cons) x637 y638)))))) (gen-map (lambda (e640 map-env) (let ((formals (map cdr map-env)) (actuals (map (lambda (x641) (list (quote ref) (car x641))) map-env))) (cond ((eq? (car e640) (quote ref)) (car actuals)) ((andmap (lambda (x642) (and (eq? (car x642) (quote ref)) (memq (cadr x642) formals))) (cdr e640)) (cons (quote map) (cons (list (quote primitive) (car e640)) (map (let ((r643 (map cons formals actuals))) (lambda (x644) (cdr (assq (cadr x644) r643)))) (cdr e640))))) (else (cons (quote map) (cons (list (quote lambda) formals e640) actuals))))))) (gen-mappend (lambda (e645 map-env646) (list (quote apply) (quote (primitive append)) (gen-map e645 map-env646)))) (gen-ref (lambda (src647 var648 level649 maps) (if (fx= level649 (quote 0)) (values var648 maps) (if (null? maps) (syntax-error src647 (quote "missing ellipsis in syntax form")) (call-with-values (lambda () (gen-ref src647 var648 (fx- level649 (quote 1)) (cdr maps))) (lambda (outer-var outer-maps) (let ((b650 (assq outer-var (car maps)))) (if b650 (values (cdr b650) maps) (let ((inner-var (gen-var (quote tmp)))) (values inner-var (cons (cons (cons outer-var inner-var) (car maps)) outer-maps))))))))))) (gen-syntax (lambda (src651 e652 r653 maps654 ellipsis?655) (if (id? e652) (let ((label656 (id-var-name e652 (quote (()))))) (let ((b657 (lookup label656 r653))) (if (eq? (binding-type b657) (quote syntax)) (call-with-values (lambda () (let ((var.lev (binding-value b657))) (gen-ref src651 (car var.lev) (cdr var.lev) maps654))) (lambda (var658 maps659) (values (list (quote ref) var658) maps659))) (if (ellipsis?655 e652) (syntax-error src651 (quote "misplaced ellipsis in syntax form")) (values (list (quote quote) e652) maps654))))) ((lambda (tmp660) ((lambda (tmp661) (if (if tmp661 (apply (lambda (dots e662) (ellipsis?655 dots)) tmp661) (quote #f)) (apply (lambda (dots663 e664) (gen-syntax src651 e664 r653 maps654 (lambda (x665) (quote #f)))) tmp661) ((lambda (tmp666) (if (if tmp666 (apply (lambda (x667 dots668 y669) (ellipsis?655 dots668)) tmp666) (quote #f)) (apply (lambda (x670 dots671 y672) (let f673 ((y674 y672) (k675 (lambda (maps676) (call-with-values (lambda () (gen-syntax src651 x670 r653 (cons (quote ()) maps676) ellipsis?655)) (lambda (x677 maps678) (if (null? (car maps678)) (syntax-error src651 (quote "extra ellipsis in syntax form")) (values (gen-map x677 (car maps678)) (cdr maps678)))))))) ((lambda (tmp679) ((lambda (tmp680) (if (if tmp680 (apply (lambda (dots681 y682) (ellipsis?655 dots681)) tmp680) (quote #f)) (apply (lambda (dots683 y684) (f673 y684 (lambda (maps685) (call-with-values (lambda () (k675 (cons (quote ()) maps685))) (lambda (x686 maps687) (if (null? (car maps687)) (syntax-error src651 (quote "extra ellipsis in syntax form")) (values (gen-mappend x686 (car maps687)) (cdr maps687)))))))) tmp680) ((lambda (_688) (call-with-values (lambda () (gen-syntax src651 y674 r653 maps654 ellipsis?655)) (lambda (y689 maps690) (call-with-values (lambda () (k675 maps690)) (lambda (x691 maps692) (values (gen-append x691 y689) maps692)))))) tmp679))) (syntax-dispatch tmp679 (quote (any . any))))) y674))) tmp666) ((lambda (tmp693) (if tmp693 (apply (lambda (x694 y695) (call-with-values (lambda () (gen-syntax src651 x694 r653 maps654 ellipsis?655)) (lambda (x696 maps697) (call-with-values (lambda () (gen-syntax src651 y695 r653 maps697 ellipsis?655)) (lambda (y698 maps699) (values (gen-cons x696 y698) maps699)))))) tmp693) ((lambda (tmp700) (if tmp700 (apply (lambda (e1701 e2702) (call-with-values (lambda () (gen-syntax src651 (cons e1701 e2702) r653 maps654 ellipsis?655)) (lambda (e704 maps705) (values (gen-vector e704) maps705)))) tmp700) ((lambda (_706) (values (list (quote quote) e652) maps654)) tmp660))) (syntax-dispatch tmp660 (quote #(vector (any . each-any))))))) (syntax-dispatch tmp660 (quote (any . any)))))) (syntax-dispatch tmp660 (quote (any any . any)))))) (syntax-dispatch tmp660 (quote (any any))))) e652))))) (lambda (e707 r708 w709 s710) (let ((e711 (source-wrap e707 w709 s710))) ((lambda (tmp712) ((lambda (tmp713) (if tmp713 (apply (lambda (_714 x715) (call-with-values (lambda () (gen-syntax e711 x715 r708 (quote ()) ellipsis?)) (lambda (e716 maps717) (regen e716)))) tmp713) ((lambda (_718) (syntax-error e711)) tmp712))) (syntax-dispatch tmp712 (quote (any any))))) e711))))) (global-extend (quote core) (quote lambda) (lambda (e719 r720 w721 s722) ((lambda (tmp723) ((lambda (tmp724) (if tmp724 (apply (lambda (_725 c726) (chi-lambda-clause (source-wrap e719 w721 s722) c726 r720 w721 (lambda (vars727 body728) (list (quote lambda) vars727 body728)))) tmp724) (syntax-error tmp723))) (syntax-dispatch tmp723 (quote (any . any))))) e719))) (global-extend (quote core) (quote let) (letrec ((chi-let (lambda (e729 r730 w731 s732 constructor733 ids734 vals735 exps736) (if (not (valid-bound-ids? ids734)) (syntax-error e729 (quote "duplicate bound variable in")) (let ((labels737 (gen-labels ids734)) (new-vars738 (map gen-var ids734))) (let ((nw (make-binding-wrap ids734 labels737 w731)) (nr (extend-var-env labels737 new-vars738 r730))) (constructor733 s732 new-vars738 (map (lambda (x739) (chi x739 r730 w731)) vals735) (chi-body exps736 (source-wrap e729 nw s732) nr nw)))))))) (lambda (e740 r741 w742 s743) ((lambda (tmp744) ((lambda (tmp745) (if tmp745 (apply (lambda (_746 id747 val748 e1749 e2750) (chi-let e740 r741 w742 s743 build-let id747 val748 (cons e1749 e2750))) tmp745) ((lambda (tmp754) (if (if tmp754 (apply (lambda (_755 f756 id757 val758 e1759 e2760) (id? f756)) tmp754) (quote #f)) (apply (lambda (_761 f762 id763 val764 e1765 e2766) (chi-let e740 r741 w742 s743 build-named-let (cons f762 id763) val764 (cons e1765 e2766))) tmp754) ((lambda (_770) (syntax-error (source-wrap e740 w742 s743))) tmp744))) (syntax-dispatch tmp744 (quote (any any #(each (any any)) any . each-any)))))) (syntax-dispatch tmp744 (quote (any #(each (any any)) any . each-any))))) e740)))) (global-extend (quote core) (quote letrec) (lambda (e771 r772 w773 s774) ((lambda (tmp775) ((lambda (tmp776) (if tmp776 (apply (lambda (_777 id778 val779 e1780 e2781) (let ((ids782 id778)) (if (not (valid-bound-ids? ids782)) (syntax-error e771 (quote "duplicate bound variable in")) (let ((labels784 (gen-labels ids782)) (new-vars785 (map gen-var ids782))) (let ((w786 (make-binding-wrap ids782 labels784 w773)) (r787 (extend-var-env labels784 new-vars785 r772))) (build-letrec s774 new-vars785 (map (lambda (x788) (chi x788 r787 w786)) val779) (chi-body (cons e1780 e2781) (source-wrap e771 w786 s774) r787 w786))))))) tmp776) ((lambda (_791) (syntax-error (source-wrap e771 w773 s774))) tmp775))) (syntax-dispatch tmp775 (quote (any #(each (any any)) any . each-any))))) e771))) (global-extend (quote core) (quote set!) (lambda (e792 r793 w794 s795) ((lambda (tmp796) ((lambda (tmp797) (if (if tmp797 (apply (lambda (_798 id799 val800) (id? id799)) tmp797) (quote #f)) (apply (lambda (_801 id802 val803) (let ((val804 (chi val803 r793 w794)) (n805 (id-var-name id802 w794))) (let ((b806 (lookup n805 r793))) (let ((t807 (binding-type b806))) (if (memv t807 (quote (lexical))) (list (quote set!) (binding-value b806) val804) (if (memv t807 (quote (global))) (list (quote set!) n805 val804) (if (memv t807 (quote (displaced-lexical))) (syntax-error (wrap id802 w794) (quote "identifier out of context")) (syntax-error (source-wrap e792 w794 s795))))))))) tmp797) ((lambda (_808) (syntax-error (source-wrap e792 w794 s795))) tmp796))) (syntax-dispatch tmp796 (quote (any any any))))) e792))) (global-extend (quote begin) (quote begin) (quote ())) (global-extend (quote define) (quote define) (quote ())) (global-extend (quote define-syntax) (quote define-syntax) (quote ())) (global-extend (quote eval-when) (quote eval-when) (quote ())) (global-extend (quote core) (quote syntax-case) (letrec ((gen-syntax-case (lambda (x809 keys clauses r810) (if (null? clauses) (list (quote syntax-error) x809) ((lambda (tmp811) ((lambda (tmp812) (if tmp812 (apply (lambda (pat exp813) (if (and (id? pat) (andmap (lambda (x814) (not (free-id=? pat x814))) (cons (quote #(syntax-object ... ((top) #(ribcage #(pat exp) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x keys clauses r) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage (gen-syntax-case gen-clause build-dispatch-call convert-pattern) ((top) (top) (top) (top)) ("i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-wrap! set-syntax-object-expression! syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object self-evaluating? build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application get-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook annotation? fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i"))))) keys))) (let ((labels815 (list (gen-label))) (var816 (gen-var pat))) (list (list (quote lambda) (list var816) (chi exp813 (extend-env labels815 (list (cons (quote syntax) (cons var816 (quote 0)))) r810) (make-binding-wrap (list pat) labels815 (quote (()))))) x809)) (gen-clause x809 keys (cdr clauses) r810 pat (quote #t) exp813))) tmp812) ((lambda (tmp817) (if tmp817 (apply (lambda (pat818 fender exp819) (gen-clause x809 keys (cdr clauses) r810 pat818 fender exp819)) tmp817) ((lambda (_820) (syntax-error (car clauses) (quote "invalid syntax-case clause"))) tmp811))) (syntax-dispatch tmp811 (quote (any any any)))))) (syntax-dispatch tmp811 (quote (any any))))) (car clauses))))) (gen-clause (lambda (x821 keys822 clauses823 r824 pat825 fender826 exp827) (call-with-values (lambda () (convert-pattern pat825 keys822)) (lambda (p828 pvars) (cond ((not (distinct-bound-ids? (map car pvars))) (syntax-error pat825 (quote "duplicate pattern variable in syntax-case pattern"))) ((not (andmap (lambda (x829) (not (ellipsis? (car x829)))) pvars)) (syntax-error pat825 (quote "misplaced ellipsis in syntax-case pattern"))) (else (let ((y830 (gen-var (quote tmp)))) (list (list (quote lambda) (list y830) (let ((y831 y830)) (list (quote if) ((lambda (tmp832) ((lambda (tmp833) (if tmp833 (apply (lambda () y831) tmp833) ((lambda (_834) (list (quote if) y831 (build-dispatch-call pvars fender826 y831 r824) (list (quote quote) (quote #f)))) tmp832))) (syntax-dispatch tmp832 (quote #(atom #t))))) fender826) (build-dispatch-call pvars exp827 y831 r824) (gen-syntax-case x821 keys822 clauses823 r824)))) (if (eq? p828 (quote any)) (list (quote list) x821) (list (quote syntax-dispatch) x821 (list (quote quote) p828))))))))))) (build-dispatch-call (lambda (pvars835 exp836 y837 r838) (let ((ids839 (map car pvars835)) (levels (map cdr pvars835))) (let ((labels840 (gen-labels ids839)) (new-vars841 (map gen-var ids839))) (list (quote apply) (list (quote lambda) new-vars841 (chi exp836 (extend-env labels840 (map (lambda (var842 level843) (cons (quote syntax) (cons var842 level843))) new-vars841 (map cdr pvars835)) r838) (make-binding-wrap ids839 labels840 (quote (()))))) y837))))) (convert-pattern (lambda (pattern keys844) (let cvt ((p845 pattern) (n846 (quote 0)) (ids847 (quote ()))) (if (id? p845) (if (bound-id-member? p845 keys844) (values (vector (quote free-id) p845) ids847) (values (quote any) (cons (cons p845 n846) ids847))) ((lambda (tmp848) ((lambda (tmp849) (if (if tmp849 (apply (lambda (x850 dots851) (ellipsis? dots851)) tmp849) (quote #f)) (apply (lambda (x852 dots853) (call-with-values (lambda () (cvt x852 (fx+ n846 (quote 1)) ids847)) (lambda (p854 ids855) (values (if (eq? p854 (quote any)) (quote each-any) (vector (quote each) p854)) ids855)))) tmp849) ((lambda (tmp856) (if tmp856 (apply (lambda (x857 y858) (call-with-values (lambda () (cvt y858 n846 ids847)) (lambda (y859 ids860) (call-with-values (lambda () (cvt x857 n846 ids860)) (lambda (x861 ids862) (values (cons x861 y859) ids862)))))) tmp856) ((lambda (tmp863) (if tmp863 (apply (lambda () (values (quote ()) ids847)) tmp863) ((lambda (tmp864) (if tmp864 (apply (lambda (x865) (call-with-values (lambda () (cvt x865 n846 ids847)) (lambda (p867 ids868) (values (vector (quote vector) p867) ids868)))) tmp864) ((lambda (x869) (values (vector (quote atom) (strip p845 (quote (())))) ids847)) tmp848))) (syntax-dispatch tmp848 (quote #(vector each-any)))))) (syntax-dispatch tmp848 (quote ()))))) (syntax-dispatch tmp848 (quote (any . any)))))) (syntax-dispatch tmp848 (quote (any any))))) p845)))))) (lambda (e870 r871 w872 s873) (let ((e874 (source-wrap e870 w872 s873))) ((lambda (tmp875) ((lambda (tmp876) (if tmp876 (apply (lambda (_877 val878 key m879) (if (andmap (lambda (x880) (and (id? x880) (not (ellipsis? x880)))) key) (let ((x882 (gen-var (quote tmp)))) (list (list (quote lambda) (list x882) (gen-syntax-case x882 key m879 r871)) (chi val878 r871 (quote (()))))) (syntax-error e874 (quote "invalid literals list in")))) tmp876) (syntax-error tmp875))) (syntax-dispatch tmp875 (quote (any any each-any . each-any))))) e874))))) (set! sc-expand (let ((m885 (quote e)) (esew886 (quote (eval)))) (lambda (x887) (if (and (pair? x887) (equal? (car x887) noexpand)) (cadr x887) (chi-top x887 (quote ()) (quote ((top))) m885 esew886))))) (set! sc-expand3 (let ((m888 (quote e)) (esew889 (quote (eval)))) (lambda (x890 . rest) (if (and (pair? x890) (equal? (car x890) noexpand)) (cadr x890) (chi-top x890 (quote ()) (quote ((top))) (if (null? rest) m888 (car rest)) (if (or (null? rest) (null? (cdr rest))) esew889 (cadr rest))))))) (set! identifier? (lambda (x891) (nonsymbol-id? x891))) (set! datum->syntax-object (lambda (id892 datum) (begin (let ((x893 id892)) (if (not (nonsymbol-id? x893)) (error-hook (quote datum->syntax-object) (quote "invalid argument") x893))) (make-syntax-object datum (syntax-object-wrap id892))))) (set! syntax-object->datum (lambda (x894) (strip x894 (quote (()))))) (set! generate-temporaries (lambda (ls895) (begin (let ((x896 ls895)) (if (not (list? x896)) (error-hook (quote generate-temporaries) (quote "invalid argument") x896))) (map (lambda (x897) (wrap (gensym) (quote ((top))))) ls895)))) (set! free-identifier=? (lambda (x898 y899) (begin (let ((x900 x898)) (if (not (nonsymbol-id? x900)) (error-hook (quote free-identifier=?) (quote "invalid argument") x900))) (let ((x901 y899)) (if (not (nonsymbol-id? x901)) (error-hook (quote free-identifier=?) (quote "invalid argument") x901))) (free-id=? x898 y899)))) (set! bound-identifier=? (lambda (x902 y903) (begin (let ((x904 x902)) (if (not (nonsymbol-id? x904)) (error-hook (quote bound-identifier=?) (quote "invalid argument") x904))) (let ((x905 y903)) (if (not (nonsymbol-id? x905)) (error-hook (quote bound-identifier=?) (quote "invalid argument") x905))) (bound-id=? x902 y903)))) (set! syntax-error (lambda (object . messages) (begin (for-each (lambda (x906) (let ((x907 x906)) (if (not (string? x907)) (error-hook (quote syntax-error) (quote "invalid argument") x907)))) messages) (let ((message (if (null? messages) (quote "invalid syntax") (apply string-append messages)))) (error-hook (quote #f) message (strip object (quote (())))))))) (set! install-global-transformer (lambda (sym908 v909) (begin (let ((x910 sym908)) (if (not (symbol? x910)) (error-hook (quote define-syntax) (quote "invalid argument") x910))) (let ((x911 v909)) (if (not (procedure? x911)) (error-hook (quote define-syntax) (quote "invalid argument") x911))) (global-extend (quote macro) sym908 v909)))) (letrec ((match (lambda (e912 p913 w914 r915) (cond ((not r915) (quote #f)) ((eq? p913 (quote any)) (cons (wrap e912 w914) r915)) ((syntax-object? e912) (match* (let ((e916 (syntax-object-expression e912))) (if (annotation? e916) (annotation-expression e916) e916)) p913 (join-wraps w914 (syntax-object-wrap e912)) r915)) (else (match* (let ((e917 e912)) (if (annotation? e917) (annotation-expression e917) e917)) p913 w914 r915))))) (match* (lambda (e918 p919 w920 r921) (cond ((null? p919) (and (null? e918) r921)) ((pair? p919) (and (pair? e918) (match (car e918) (car p919) w920 (match (cdr e918) (cdr p919) w920 r921)))) ((eq? p919 (quote each-any)) (let ((l (match-each-any e918 w920))) (and l (cons l r921)))) (else (let ((t922 (vector-ref p919 (quote 0)))) (if (memv t922 (quote (each))) (if (null? e918) (match-empty (vector-ref p919 (quote 1)) r921) (let ((l923 (match-each e918 (vector-ref p919 (quote 1)) w920))) (and l923 (let collect ((l924 l923)) (if (null? (car l924)) r921 (cons (map car l924) (collect (map cdr l924)))))))) (if (memv t922 (quote (free-id))) (and (id? e918) (free-id=? (wrap e918 w920) (vector-ref p919 (quote 1))) r921) (if (memv t922 (quote (atom))) (and (equal? (vector-ref p919 (quote 1)) (strip e918 w920)) r921) (if (memv t922 (quote (vector))) (and (vector? e918) (match (vector->list e918) (vector-ref p919 (quote 1)) w920 r921))))))))))) (match-empty (lambda (p925 r926) (cond ((null? p925) r926) ((eq? p925 (quote any)) (cons (quote ()) r926)) ((pair? p925) (match-empty (car p925) (match-empty (cdr p925) r926))) ((eq? p925 (quote each-any)) (cons (quote ()) r926)) (else (let ((t927 (vector-ref p925 (quote 0)))) (if (memv t927 (quote (each))) (match-empty (vector-ref p925 (quote 1)) r926) (if (memv t927 (quote (free-id atom))) r926 (if (memv t927 (quote (vector))) (match-empty (vector-ref p925 (quote 1)) r926))))))))) (match-each-any (lambda (e928 w929) (cond ((annotation? e928) (match-each-any (annotation-expression e928) w929)) ((pair? e928) (let ((l930 (match-each-any (cdr e928) w929))) (and l930 (cons (wrap (car e928) w929) l930)))) ((null? e928) (quote ())) ((syntax-object? e928) (match-each-any (syntax-object-expression e928) (join-wraps w929 (syntax-object-wrap e928)))) (else (quote #f))))) (match-each (lambda (e931 p932 w933) (cond ((annotation? e931) (match-each (annotation-expression e931) p932 w933)) ((pair? e931) (let ((first934 (match (car e931) p932 w933 (quote ())))) (and first934 (let ((rest935 (match-each (cdr e931) p932 w933))) (and rest935 (cons first934 rest935)))))) ((null? e931) (quote ())) ((syntax-object? e931) (match-each (syntax-object-expression e931) p932 (join-wraps w933 (syntax-object-wrap e931)))) (else (quote #f)))))) (set! syntax-dispatch (lambda (e936 p937) (cond ((eq? p937 (quote any)) (list e936)) ((syntax-object? e936) (match* (let ((e938 (syntax-object-expression e936))) (if (annotation? e938) (annotation-expression e938) e938)) p937 (syntax-object-wrap e936) (quote ()))) (else (match* (let ((e939 e936)) (if (annotation? e939) (annotation-expression e939) e939)) p937 (quote (())) (quote ())))))))))
(install-global-transformer (quote with-syntax) (lambda (x940) ((lambda (tmp941) ((lambda (tmp942) (if tmp942 (apply (lambda (_943 e1944 e2945) (cons (quote #(syntax-object begin ((top) #(ribcage #(_ e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (cons e1944 e2945))) tmp942) ((lambda (tmp947) (if tmp947 (apply (lambda (_948 out in e1949 e2950) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) in (quote ()) (list out (cons (quote #(syntax-object begin ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (cons e1949 e2950))))) tmp947) ((lambda (tmp952) (if tmp952 (apply (lambda (_953 out954 in955 e1956 e2957) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (cons (quote #(syntax-object list ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) in955) (quote ()) (list out954 (cons (quote #(syntax-object begin ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (cons e1956 e2957))))) tmp952) (syntax-error tmp941))) (syntax-dispatch tmp941 (quote (any #(each (any any)) any . each-any)))))) (syntax-dispatch tmp941 (quote (any ((any any)) any . each-any)))))) (syntax-dispatch tmp941 (quote (any () any . each-any))))) x940)))
(install-global-transformer (quote syntax-rules) (lambda (x961) ((lambda (tmp962) ((lambda (tmp963) (if tmp963 (apply (lambda (_964 k965 keyword pattern966 template) (list (quote #(syntax-object lambda ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (quote (#(syntax-object x ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")))))) (cons (quote #(syntax-object syntax-case ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (cons (quote #(syntax-object x ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (cons k965 (map (lambda (tmp969 tmp968) (list (cons (quote #(syntax-object dummy ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) tmp968) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) tmp969))) template pattern966)))))) tmp963) (syntax-error tmp962))) (syntax-dispatch tmp962 (quote (any each-any . #(each ((any . any) any))))))) x961)))
(install-global-transformer (quote let*) (lambda (x970) ((lambda (tmp971) ((lambda (tmp972) (if (if tmp972 (apply (lambda (let* x973 v974 e1975 e2976) (andmap identifier? x973)) tmp972) (quote #f)) (apply (lambda (let*978 x979 v980 e1981 e2982) (let f983 ((bindings984 (map list x979 v980))) (if (null? bindings984) (cons (quote #(syntax-object let ((top) #(ribcage () () ()) #(ribcage #(f bindings) #((top) (top)) #("i" "i")) #(ribcage #(let* x v e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (cons (quote ()) (cons e1981 e2982))) ((lambda (tmp988) ((lambda (tmp989) (if tmp989 (apply (lambda (body binding) (list (quote #(syntax-object let ((top) #(ribcage #(body binding) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(f bindings) #((top) (top)) #("i" "i")) #(ribcage #(let* x v e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (list binding) body)) tmp989) (syntax-error tmp988))) (syntax-dispatch tmp988 (quote (any any))))) (list (f983 (cdr bindings984)) (car bindings984)))))) tmp972) (syntax-error tmp971))) (syntax-dispatch tmp971 (quote (any #(each (any any)) any . each-any))))) x970)))
(install-global-transformer (quote do) (lambda (orig-x) ((lambda (tmp990) ((lambda (tmp991) (if tmp991 (apply (lambda (_992 var init step e0 e1 c) ((lambda (tmp993) ((lambda (tmp994) (if tmp994 (apply (lambda (step995) ((lambda (tmp996) ((lambda (tmp997) (if tmp997 (apply (lambda () (list (quote #(syntax-object let ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))))) (quote #(syntax-object doloop ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))))) (map list var init) (list (quote #(syntax-object if ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))))) (list (quote #(syntax-object not ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))))) e0) (cons (quote #(syntax-object begin ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))))) (append c (list (cons (quote #(syntax-object doloop ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))))) step995))))))) tmp997) ((lambda (tmp1002) (if tmp1002 (apply (lambda (e11003 e2) (list (quote #(syntax-object let ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))))) (quote #(syntax-object doloop ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))))) (map list var init) (list (quote #(syntax-object if ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))))) e0 (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))))) (cons e11003 e2)) (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))))) (append c (list (cons (quote #(syntax-object doloop ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))))) step995))))))) tmp1002) (syntax-error tmp996))) (syntax-dispatch tmp996 (quote (any . each-any)))))) (syntax-dispatch tmp996 (quote ())))) e1)) tmp994) (syntax-error tmp993))) (syntax-dispatch tmp993 (quote each-any)))) (map (lambda (v s) ((lambda (tmp1010) ((lambda (tmp1011) (if tmp1011 (apply (lambda () v) tmp1011) ((lambda (tmp1012) (if tmp1012 (apply (lambda (e) e) tmp1012) ((lambda (_1013) (syntax-error orig-x)) tmp1010))) (syntax-dispatch tmp1010 (quote (any)))))) (syntax-dispatch tmp1010 (quote ())))) s)) var step))) tmp991) (syntax-error tmp990))) (syntax-dispatch tmp990 (quote (any #(each (any any . any)) (any . each-any) . each-any))))) orig-x)))
(install-global-transformer (quote quasiquote) (letrec ((quasicons (lambda (x1016 y) ((lambda (tmp1017) ((lambda (tmp1018) (if tmp1018 (apply (lambda (x1019 y1020) ((lambda (tmp1021) ((lambda (tmp1022) (if tmp1022 (apply (lambda (dy) ((lambda (tmp1023) ((lambda (tmp1024) (if tmp1024 (apply (lambda (dx) (list (quote #(syntax-object quote ((top) #(ribcage #(dx) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) (cons dx dy))) tmp1024) ((lambda (_1025) (if (null? dy) (list (quote #(syntax-object list ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) x1019) (list (quote #(syntax-object cons ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) x1019 y1020))) tmp1023))) (syntax-dispatch tmp1023 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) any))))) x1019)) tmp1022) ((lambda (tmp) (if tmp (apply (lambda (stuff) (cons (quote #(syntax-object list ((top) #(ribcage #(stuff) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) (cons x1019 stuff))) tmp) ((lambda (else) (list (quote #(syntax-object cons ((top) #(ribcage #(else) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) x1019 y1020)) tmp1021))) (syntax-dispatch tmp1021 (quote (#(free-id #(syntax-object list ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) . any)))))) (syntax-dispatch tmp1021 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) any))))) y1020)) tmp1018) (syntax-error tmp1017))) (syntax-dispatch tmp1017 (quote (any any))))) (list x1016 y)))) (quasiappend (lambda (x y1026) ((lambda (tmp1027) ((lambda (tmp1028) (if tmp1028 (apply (lambda (x1029 y1030) ((lambda (tmp1031) ((lambda (tmp1032) (if tmp1032 (apply (lambda () x1029) tmp1032) ((lambda (_) (list (quote #(syntax-object append ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) x1029 y1030)) tmp1031))) (syntax-dispatch tmp1031 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) ()))))) y1030)) tmp1028) (syntax-error tmp1027))) (syntax-dispatch tmp1027 (quote (any any))))) (list x y1026)))) (quasivector (lambda (x1033) ((lambda (tmp1034) ((lambda (x1035) ((lambda (tmp1036) ((lambda (tmp1037) (if tmp1037 (apply (lambda (x1038) (list (quote #(syntax-object quote ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) (list->vector x1038))) tmp1037) ((lambda (tmp1040) (if tmp1040 (apply (lambda (x1041) (cons (quote #(syntax-object vector ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) x1041)) tmp1040) ((lambda (_1043) (list (quote #(syntax-object list->vector ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) x1035)) tmp1036))) (syntax-dispatch tmp1036 (quote (#(free-id #(syntax-object list ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) . each-any)))))) (syntax-dispatch tmp1036 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) each-any))))) x1035)) tmp1034)) x1033))) (quasi (lambda (p lev) ((lambda (tmp1044) ((lambda (tmp1045) (if tmp1045 (apply (lambda (p1046) (if (= lev (quote 0)) p1046 (quasicons (quote (#(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i")))) #(syntax-object unquote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i")))))) (quasi (list p1046) (- lev (quote 1)))))) tmp1045) ((lambda (tmp1047) (if tmp1047 (apply (lambda (p1048 q) (if (= lev (quote 0)) (quasiappend p1048 (quasi q lev)) (quasicons (quasicons (quote (#(syntax-object quote ((top) #(ribcage #(p q) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i")))) #(syntax-object unquote-splicing ((top) #(ribcage #(p q) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i")))))) (quasi (list p1048) (- lev (quote 1)))) (quasi q lev)))) tmp1047) ((lambda (tmp1049) (if tmp1049 (apply (lambda (p1050) (quasicons (quote (#(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i")))) #(syntax-object quasiquote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i")))))) (quasi (list p1050) (+ lev (quote 1))))) tmp1049) ((lambda (tmp1051) (if tmp1051 (apply (lambda (p1052 q1053) (quasicons (quasi p1052 lev) (quasi q1053 lev))) tmp1051) ((lambda (tmp1054) (if tmp1054 (apply (lambda (x1055) (quasivector (quasi x1055 lev))) tmp1054) ((lambda (p1057) (list (quote #(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) p1057)) tmp1044))) (syntax-dispatch tmp1044 (quote #(vector each-any)))))) (syntax-dispatch tmp1044 (quote (any . any)))))) (syntax-dispatch tmp1044 (quote (#(free-id #(syntax-object quasiquote ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) any)))))) (syntax-dispatch tmp1044 (quote ((#(free-id #(syntax-object unquote-splicing ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) any) . any)))))) (syntax-dispatch tmp1044 (quote (#(free-id #(syntax-object unquote ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) any))))) p)))) (lambda (x1058) ((lambda (tmp1059) ((lambda (tmp1060) (if tmp1060 (apply (lambda (_1061 e1062) (quasi e1062 (quote 0))) tmp1060) (syntax-error tmp1059))) (syntax-dispatch tmp1059 (quote (any any))))) x1058))))
(install-global-transformer (quote include) (lambda (x1063) (letrec ((read-file (lambda (fn k) (let ((p1064 (open-input-file fn))) (let f ((x1065 (read p1064))) (if (eof-object? x1065) (begin (close-input-port p1064) (quote ())) (cons (datum->syntax-object k x1065) (f (read p1064))))))))) ((lambda (tmp1066) ((lambda (tmp1067) (if tmp1067 (apply (lambda (k1068 filename) (let ((fn1069 (syntax-object->datum filename))) ((lambda (tmp1070) ((lambda (tmp1071) (if tmp1071 (apply (lambda (exp) (cons (quote #(syntax-object begin ((top) #(ribcage #(exp) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(fn) #((top)) #("i")) #(ribcage #(k filename) #((top) (top)) #("i" "i")) #(ribcage (read-file) ((top)) ("i")) #(ribcage #(x) #((top)) #("i"))))) exp)) tmp1071) (syntax-error tmp1070))) (syntax-dispatch tmp1070 (quote each-any)))) (read-file fn1069 k1068)))) tmp1067) (syntax-error tmp1066))) (syntax-dispatch tmp1066 (quote (any any))))) x1063))))
(install-global-transformer (quote unquote) (lambda (x1073) ((lambda (tmp1074) ((lambda (tmp1075) (if tmp1075 (apply (lambda (_1076 e1077) (error (quote unquote) (quote "expression ,~s not valid outside of quasiquote") (syntax-object->datum e1077))) tmp1075) (syntax-error tmp1074))) (syntax-dispatch tmp1074 (quote (any any))))) x1073)))
(install-global-transformer (quote unquote-splicing) (lambda (x1078) ((lambda (tmp1079) ((lambda (tmp1080) (if tmp1080 (apply (lambda (_1081 e1082) (error (quote unquote-splicing) (quote "expression ,@~s not valid outside of quasiquote") (syntax-object->datum e1082))) tmp1080) (syntax-error tmp1079))) (syntax-dispatch tmp1079 (quote (any any))))) x1078)))
(install-global-transformer (quote case) (lambda (x1083) ((lambda (tmp1084) ((lambda (tmp1085) (if tmp1085 (apply (lambda (_1086 e1087 m1 m2) ((lambda (tmp1088) ((lambda (body1089) (list (quote #(syntax-object let ((top) #(ribcage #(body) #((top)) #("i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (list (list (quote #(syntax-object t ((top) #(ribcage #(body) #((top)) #("i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) e1087)) body1089)) tmp1088)) (let f1090 ((clause m1) (clauses m2)) (if (null? clauses) ((lambda (tmp1092) ((lambda (tmp1093) (if tmp1093 (apply (lambda (e11094 e21095) (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (cons e11094 e21095))) tmp1093) ((lambda (tmp1097) (if tmp1097 (apply (lambda (k1098 e11099 e21100) (list (quote #(syntax-object if ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (list (quote #(syntax-object memv ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (quote #(syntax-object t ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (list (quote #(syntax-object quote ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) k1098)) (cons (quote #(syntax-object begin ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (cons e11099 e21100)))) tmp1097) ((lambda (_1103) (syntax-error x1083)) tmp1092))) (syntax-dispatch tmp1092 (quote (each-any any . each-any)))))) (syntax-dispatch tmp1092 (quote (#(free-id #(syntax-object else ((top) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) any . each-any))))) clause) ((lambda (tmp1104) ((lambda (rest) ((lambda (tmp1105) ((lambda (tmp1106) (if tmp1106 (apply (lambda (k1107 e11108 e21109) (list (quote #(syntax-object if ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (list (quote #(syntax-object memv ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (quote #(syntax-object t ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (list (quote #(syntax-object quote ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) k1107)) (cons (quote #(syntax-object begin ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (cons e11108 e21109)) rest)) tmp1106) ((lambda (_1112) (syntax-error x1083)) tmp1105))) (syntax-dispatch tmp1105 (quote (each-any any . each-any))))) clause)) tmp1104)) (f1090 (car clauses) (cdr clauses))))))) tmp1085) (syntax-error tmp1084))) (syntax-dispatch tmp1084 (quote (any any any . each-any))))) x1083)))
(install-global-transformer (quote identifier-syntax) (lambda (x1113) ((lambda (tmp1114) ((lambda (tmp1115) (if tmp1115 (apply (lambda (_1116 e1117) (list (quote #(syntax-object lambda ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")))))) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (quote #(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (quote ()) (list (quote #(syntax-object id ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (quote (#(syntax-object identifier? ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")))) (#(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")))) #(syntax-object id ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))))) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) e1117)) (list (cons _1116 (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")))) #(syntax-object ... ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))))) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (cons e1117 (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")))) #(syntax-object ... ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")))))))))))) tmp1115) (syntax-error tmp1114))) (syntax-dispatch tmp1114 (quote (any any))))) x1113)))
