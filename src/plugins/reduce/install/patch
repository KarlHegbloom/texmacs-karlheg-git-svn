diff --recursive -u reduce.orig/package.red reduce/package.red
--- reduce.orig/package.red	Mon Jul 15 23:29:43 2002
+++ reduce/package.red	Mon Jul 15 23:29:23 2002
@@ -5,6 +5,7 @@
 put('ezgcd,'folder,'factor)$
 
 put('fmprint,'folder,'rprint)$
+put('tmprint,'folder,'rprint)$
 
 put('pretty,'folder,'rprint)$
 
diff --recursive -u reduce.orig/packages/rprint/tmprint.red reduce/packages/rprint/tmprint.red
--- reduce.orig/packages/rprint/tmprint.red	Mon Jul 15 23:30:30 2002
+++ reduce/packages/rprint/tmprint.red	Sat Aug 24 10:13:14 2002
@@ -1,5 +1,8 @@
-module fmprint; % Fancy output package for symbolic expressions.
-		% using TEX as intermediate language.
+module tmprint; % Output module for TeXmacs interface
+% this is fmprint with minor modifications
+
+% Fancy output package for symbolic expressions.
+% using TEX as intermediate language.
 		
 % Author: Herbert Melenk, using ideas of maprin.red (A.C.H, A.C.N).
  
@@ -62,7 +65,7 @@
 
 %  93-Dec-22 Vectors printed with sqare brackets.
 
-create!-package('(fmprint),nil);
+create!-package('(tmprint),nil);
 
 fluid  '(
 	 !*list
@@ -78,6 +81,7 @@
          outputhandler!*
          outputhandler!-stack!*
          posn!*
+         long!*
          obrkp!*    % outside-brackets-p
 	 );
 
@@ -107,7 +111,7 @@
 
 fancy!-switch!-on!* := int2id 16$
 fancy!-switch!-off!* := int2id 17$
-!*fancy!-lower := t;
+!*fancy!-lower := nil;
 
 global '(fancy_lower_digits fancy_print_df);
 
@@ -159,7 +163,7 @@
   if atom it then prin2 it else
   if eqcar(it,'ascii) then writechar(cadr it) else
   if eqcar(it,'tab) then
-     for i:=1:cdr it do prin2 "\>"
+     for i:=1:cdr it do prin2 ""
     else
   if eqcar(it,'bkt) then
      begin scalar m,b,l; integer n;
@@ -167,11 +171,12 @@
       l := b member '( !( !{ );
    %  if m then prin2 if l then "\left" else "\right"
    % else
-      if n> 0 then 
-      <<prin2 if n=1 then "\big" else if n=2 then "\Big" else
-	     if n=3 then "\bigg" else "\Bigg";
-	prin2 if l then "l" else "r";
-      >>;
+%      if n> 0 then 
+%      <<prin2 if n=1 then "\big" else if n=2 then "\Big" else
+%	     if n=3 then "\bigg" else "\Bigg";
+%	prin2 if l then "l" else "r";
+%      >>;
+      if l then prin2 "\left" else prin2 "\right";
       if b member '(!{ !}) then prin2 "\";
       prin2 b;
     end
@@ -234,12 +239,16 @@
   if numberp u and not testing!-width!* then fancy!-prin2number u
      else
   (begin scalar str,id; integer l;
-    str := stringp u; id := idp u and not digit u;
+    str := stringp u; id := idp u and not digit u; long!*:=nil;
     u:= if atom u then explode2 u where !*lower=!*fancy!-lower
         else {u};
+    if cdr u then long!*:=t;
+    if car u = '!\ then long!*:=nil;
     l := if numberp n then n else 2*length u;
     if id and not numberp n then 
        u:=fancy!-lower!-digits(fancy!-esc u);
+    if long!* then fancy!-line!* := '!{ . '!m . '!r .
+       '!h . '!t . '!a . '!m . '!\ . fancy!-line!*;
     for each x in u do
     <<if str and (x='!    or x='!_) 
 	 then fancy!-line!* := '!\ . fancy!-line!*;
@@ -247,6 +256,7 @@
 	(if id and !*fancy!-lower 
 	  then red!-char!-downcase x else x) . fancy!-line!*;
     >>;
+    if long!* then fancy!-line!* := '!} . fancy!-line!*;
     fancy!-pos!* := fancy!-pos!* #+ l;
     if fancy!-pos!* #> 2 #* (linelength nil #+1 ) then overflowed!*:=t;
   end) where !*lower = !*lower;
@@ -303,6 +313,9 @@
          q:=intern compress w;
          if stringp (x:=get(q,'fancy!-special!-symbol))
             then w:=explode2 x;
+         if cdr w then
+            if car w = '!\ then long!*:=nil else long!*:=t
+         else long!*:=nil;
          r:=nconc(r,w);
          if digit c then <<s:=t; w:={c}>> else w:=nil;
       >>
@@ -600,32 +613,26 @@
  
 symbolic procedure fancy!-inprint1(op,p,l);
    % main line (top level) infix printing, allow line break;
-  begin scalar lop,space;
-   space := flagp(op,'spaced);
+  begin scalar lop;
    for each v in l do
    <<lop := op;
      if op='plus and eqcar(v,'minus) then
        <<lop := 'minus; v:= cadr v>>;
-     if space then fancy!-prin2!*("\,",1);
      if 'failed = fancy!-oprin lop then
       <<fancy!-terpri!* nil; fancy!-oprin lop>>;
-     if space then fancy!-prin2!*("\,",1);
      fancy!-prinfit(negnumberchk v, p, nil)
    >>;
   end;
 
 symbolic procedure fancy!-inprint2(op,p,l);
    % second line
-  begin scalar lop,space,w;
-   space := flagp(op,'spaced);
+  begin scalar lop,w;
    for each v in l do
     if not testing!-width!* or w neq 'failed then
      <<lop:=op;
        if op='plus and eqcar(v,'minus) then
 	      <<lop := 'minus; v:= cadr v>>;
-       if space then fancy!-prin2!*("\,",1);
        fancy!-oprin lop;
-       if space then fancy!-prin2!*("\,",1);
        if w neq 'failed then w:=fancy!-maprint(negnumberchk v,p)
      >>;
    return w;
@@ -651,7 +658,7 @@
    goto loop;
   end; 
 
-put('times,'fancy!-prtch,"\,");
+put('times,'fancy!-prtch,"\*");
 
 symbolic procedure fancy!-oprin op;
  fancy!-level
@@ -678,12 +685,12 @@
 put('beta,'fancy!-special!-symbol,"\beta");
 put('gamma,'fancy!-special!-symbol,"\gamma");
 put('delta,'fancy!-special!-symbol,"\delta");
-put('epsilon,'fancy!-special!-symbol,"\epsilon");
+put('epsilon,'fancy!-special!-symbol,"\varepsilon");
 put('zeta,'fancy!-special!-symbol,"\zeta");
 put('eta,'fancy!-special!-symbol,"\eta");
 put('theta,'fancy!-special!-symbol,"\theta");
 put('iota,'fancy!-special!-symbol,"\iota");
-put('kappa,'fancy!-special!-symbol,"\kappa");
+put('kappa,'fancy!-special!-symbol,"\varkappa");
 put('lambda,'fancy!-special!-symbol,"\lambda");
 put('mu,'fancy!-special!-symbol,"\mu");
 put('nu,'fancy!-special!-symbol,"\nu");
@@ -708,42 +715,32 @@
     (!varphi 106)
        ),'fancy!-special!-symbol);
 
-put('infinity,'fancy!-special!-symbol,"\infty");
-
-% some symbols form the upper ASCII part of the symbol font
-
-put('partial!-df,'fancy!-special!-symbol,182);
-put('partial!-df,'fancy!-symbol!-length,8);
-put('empty!-set,'fancy!-special!-symbol,198);
-put('not,'fancy!-special!-symbol,216);
-put('not,'fancy!-infix!-symbol,216);
-
- % symbols as infix opertors
-put('leq,'fancy!-infix!-symbol,163);
-put('geq,'fancy!-infix!-symbol,179);
-put('neq,'fancy!-infix!-symbol,185);
-put('intersection,'fancy!-infix!-symbol,199);
-put('union,'fancy!-infix!-symbol,200);
-put('member,'fancy!-infix!-symbol,206);
-put('and,'fancy!-infix!-symbol,217);
-put('or,'fancy!-infix!-symbol,218);
-put('when,'fancy!-infix!-symbol,239);
+put('infinity,'fancy!-special!-symbol,"\infty ");
+put('partial!-df,'fancy!-special!-symbol,"\partial ");
+%put('partial!-df,'fancy!-symbol!-length,8);
+put('empty!-set,'fancy!-special!-symbol,"\emptyset ");
+put('not,'fancy!-special!-symbol,"\neg ");
+put('not,'fancy!-infix!-symbol,"\neg ");
+put('leq,'fancy!-infix!-symbol,"\leq ");
+put('geq,'fancy!-infix!-symbol,"\geq ");
+put('neq,'fancy!-infix!-symbol,"\neq ");
+put('intersection,'fancy!-infix!-symbol,"\cap ");
+put('union,'fancy!-infix!-symbol,"\cup ");
+put('member,'fancy!-infix!-symbol,"\in ");
+put('and,'fancy!-infix!-symbol,"\wedge ");
+put('or,'fancy!-infix!-symbol,"\vee ");
+put('when,'fancy!-infix!-symbol,"|");
 put('!*wcomma!*,'fancy!-infix!-symbol,",\,");
-
-put('replaceby,'fancy!-infix!-symbol,222);
-put('replaceby,'fancy!-symbol!-length,8);
-
- % symbols as prefix functions
-% put('gamma,'fancy!-functionsymbol,71);  % big Gamma
-%
-put('!~,'fancy!-functionsymbol,34);     % forall
-put('!~,'fancy!-symbol!-length,8);
-
- % arbint, arbcomplex.
-put('arbcomplex,'fancy!-functionsymbol,227); 
-put('arbint,'fancy!-functionsymbol,226);  
-
-flag('(arbcomplex arbint),'print!-indexed);
+put('replaceby,'fancy!-infix!-symbol,"\Rightarrow ");
+%put('replaceby,'fancy!-symbol!-length,8);
+%put('gamma,'fancy!-functionsymbol,71);  % big Gamma
+put('!~,'fancy!-functionsymbol,"\forall ");     % forall
+%put('!~,'fancy!-symbol!-length,8);
+
+% arbint, arbcomplex.
+%put('arbcomplex,'fancy!-functionsymbol,227); 
+%put('arbint,'fancy!-functionsymbol,226);  
+%flag('(arbcomplex arbint),'print!-indexed);
 
 % flag('(delta),'print!-indexed);         % Dirac delta symbol.
 % David Hartley voted against..
@@ -757,7 +754,7 @@
 symbolic procedure fancy!-condpri(u,p);
  fancy!-level
   begin scalar w;
-    if p>0 then fancy!-prin2 "\bigl(";
+    if p>0 then fancy!-prin2 "\left(";
     while (u := cdr u) and w neq 'failed do
       <<if not(caar u eq 't)
 	    then <<fancy!-prin2 'if; fancy!-prin2 " "; 
@@ -767,7 +764,7 @@
 	  if w neq 'failed then w := fancy!-maprin0 cadar u;
 	  if cdr u then <<fancy!-prin2 "\,"; 
 		       fancy!-prin2 'else; fancy!-prin2 "\,">>>>;
-     if p>0 then fancy!-prin2 "\bigr)";
+     if p>0 then fancy!-prin2 "\right)";
      if overflowed!* or w='failed then return 'failed;
    end;
 
@@ -983,7 +980,7 @@
       testing!-width!* := t;
       w := fancy!-maprint(l,get('expt,'infix));
       if w='failed then return w;
-      fancy!-prin2!*("\bigl",0);
+%      fancy!-prin2!*("\bigl",0);
       fancy!-prin2!*("|",1);
       fancy!-prin2!*('!_,0);
       fancy!-prin2!*("{",0);
@@ -1014,11 +1011,11 @@
 symbolic procedure fancy!-binomial(u,n);
   fancy!-level
    begin scalar w1,w2; 
-     fancy!-prin2!*("\left(\begin{array}{c}",2);
+     fancy!-prin2!*("\left(\begin{matrix}",2);
      w1 := fancy!-maprint(cadr u,0);
      fancy!-prin2!*("\\",0);
      w2 := fancy!-maprint(caddr u,0);
-     fancy!-prin2!*("\end{array}\right)",2);
+     fancy!-prin2!*("\end{matrix}\right)",2);
      if w1='failed or w2='failed then return 'failed;
    end;
 
@@ -1029,9 +1026,9 @@
   fancy!-level
    begin scalar w1,w2;
      if fancy!-mode!*>35 and fancy!-height(cadr u,1.0) > 3 then
-         fancy!-prin2!*("\Int",0)
+         fancy!-prin2!*("\Int ",0)
        else
-         fancy!-prin2!*("\int",0);
+         fancy!-prin2!*("\int ",0);
      w1:=fancy!-maprint(cadr u,0);
      fancy!-prin2!*("\,d\,",2);
      w2:=fancy!-maprint(caddr u,0);
@@ -1101,7 +1098,7 @@
      fancy!-prin2!*('!_,0);
      fancy!-prin2!*('!{,0);
      fancy!-maprint(var,0);
-     fancy!-prin2!*("\to",0);
+     fancy!-prin2!*("\rightarrow",0);
      fancy!-maprint(lo,0);
      fancy!-prin2!*('!},0);
      w:=fancy!-maprint(cadr u,0);
@@ -1303,10 +1300,8 @@
        % restore output line.
      fancy!-pos!* := fp; fancy!-line!* := fl;
        % TEX header
-     fancy!-prin2!*(bldmsg("\left%w\begin{array}{",
+     fancy!-prin2!*(bldmsg("\left%w\begin{matrix}",
                         if bkt then car bkt else "("),0);
-     for i:=1:cols do fancy!-prin2!*("c",0);
-     fancy!-prin2!*("}",0);
        % join elements.
      while fmat do
      <<row := car fmat; fmat:=cdr fmat;
@@ -1318,7 +1313,7 @@
 	     fancy!-line!* := "\\". fancy!-line!*;
        >>;
      >>;
-     fancy!-prin2!*(bldmsg("\end{array}\right%w",
+     fancy!-prin2!*(bldmsg("\end{matrix}\right%w",
                         if bkt then cdr bkt else ")"),0);
       % compute total horizontal extent of matrix
      fancy!-pos!* := fp + maxpos*(cols+1);
@@ -1423,6 +1418,167 @@
 
 module fancy_specfn;
 
+put('sin,'fancy!-prifn,'fancy!-sin);
+put('cos,'fancy!-prifn,'fancy!-cos);
+put('tan,'fancy!-prifn,'fancy!-tan);
+put('cot,'fancy!-prifn,'fancy!-cot);
+put('sec,'fancy!-prifn,'fancy!-sec);
+put('csc,'fancy!-prifn,'fancy!-csc);
+put('asin,'fancy!-prifn,'fancy!-asin);
+put('acos,'fancy!-prifn,'fancy!-acos);
+put('atan,'fancy!-prifn,'fancy!-atan);
+put('sinh,'fancy!-prifn,'fancy!-sinh);
+put('cosh,'fancy!-prifn,'fancy!-cosh);
+put('tanh,'fancy!-prifn,'fancy!-tanh);
+put('coth,'fancy!-prifn,'fancy!-coth);
+put('exp,'fancy!-prifn,'fancy!-exp);
+put('log,'fancy!-prifn,'fancy!-log);
+put('ln,'fancy!-prifn,'fancy!-ln);
+put('max,'fancy!-prifn,'fancy!-max);
+put('min,'fancy!-prifn,'fancy!-min);
+%put('repart,'fancy!-prifn,'fancy!-repart);
+%put('impart,'fancy!-prifn,'fancy!-impart);
+
+symbolic procedure fancy!-sin(u);
+ fancy!-level
+  begin
+   fancy!-prin2!*("\sin",0);
+   return fancy!-print!-function!-arguments cdr u;
+  end;
+
+symbolic procedure fancy!-cos(u);
+ fancy!-level
+  begin
+   fancy!-prin2!*("\cos",0);
+   return fancy!-print!-function!-arguments cdr u;
+  end;
+
+symbolic procedure fancy!-tan(u);
+ fancy!-level
+  begin
+   fancy!-prin2!*("\tan",0);
+   return fancy!-print!-function!-arguments cdr u;
+  end;
+
+symbolic procedure fancy!-cot(u);
+ fancy!-level
+  begin
+   fancy!-prin2!*("\cot",0);
+   return fancy!-print!-function!-arguments cdr u;
+  end;
+
+symbolic procedure fancy!-sec(u);
+ fancy!-level
+  begin
+   fancy!-prin2!*("\sec",0);
+   return fancy!-print!-function!-arguments cdr u;
+  end;
+
+symbolic procedure fancy!-csc(u);
+ fancy!-level
+  begin
+   fancy!-prin2!*("\csc",0);
+   return fancy!-print!-function!-arguments cdr u;
+  end;
+
+symbolic procedure fancy!-asin(u);
+ fancy!-level
+  begin
+   fancy!-prin2!*("\arcsin",0);
+   return fancy!-print!-function!-arguments cdr u;
+  end;
+
+symbolic procedure fancy!-acos(u);
+ fancy!-level
+  begin
+   fancy!-prin2!*("\arccos",0);
+   return fancy!-print!-function!-arguments cdr u;
+  end;
+
+symbolic procedure fancy!-atan(u);
+ fancy!-level
+  begin
+   fancy!-prin2!*("\arctan",0);
+   return fancy!-print!-function!-arguments cdr u;
+  end;
+
+symbolic procedure fancy!-sinh(u);
+ fancy!-level
+  begin
+   fancy!-prin2!*("\sinh",0);
+   return fancy!-print!-function!-arguments cdr u;
+  end;
+
+symbolic procedure fancy!-cosh(u);
+ fancy!-level
+  begin
+   fancy!-prin2!*("\cosh",0);
+   return fancy!-print!-function!-arguments cdr u;
+  end;
+
+symbolic procedure fancy!-tanh(u);
+ fancy!-level
+  begin
+   fancy!-prin2!*("\tanh",0);
+   return fancy!-print!-function!-arguments cdr u;
+  end;
+
+symbolic procedure fancy!-coth(u);
+ fancy!-level
+  begin
+   fancy!-prin2!*("\coth",0);
+   return fancy!-print!-function!-arguments cdr u;
+  end;
+
+symbolic procedure fancy!-exp(u);
+ fancy!-level
+  begin
+   fancy!-prin2!*("\exp",0);
+   return fancy!-print!-function!-arguments cdr u;
+  end;
+
+symbolic procedure fancy!-log(u);
+ fancy!-level
+  begin
+   fancy!-prin2!*("\log",0);
+   return fancy!-print!-function!-arguments cdr u;
+  end;
+
+symbolic procedure fancy!-ln(u);
+ fancy!-level
+  begin
+   fancy!-prin2!*("\ln",0);
+   return fancy!-print!-function!-arguments cdr u;
+  end;
+
+symbolic procedure fancy!-max(u);
+ fancy!-level
+  begin
+   fancy!-prin2!*("\max",0);
+   return fancy!-print!-function!-arguments cdr u;
+  end;
+
+symbolic procedure fancy!-min(u);
+ fancy!-level
+  begin
+   fancy!-prin2!*("\min",0);
+   return fancy!-print!-function!-arguments cdr u;
+  end;
+
+symbolic procedure fancy!-repart(u);
+ fancy!-level
+  begin
+   fancy!-prin2!*("\Re",0);
+   return fancy!-print!-function!-arguments cdr u;
+  end;
+
+symbolic procedure fancy!-impart(u);
+ fancy!-level
+  begin
+   fancy!-prin2!*("\Im",0);
+   return fancy!-print!-function!-arguments cdr u;
+  end;
+
 put('besseli,'fancy!-prifn,'fancy!-bessel);
 put('besselj,'fancy!-prifn,'fancy!-bessel);
 put('bessely,'fancy!-prifn,'fancy!-bessel);
@@ -1453,20 +1609,21 @@
    a1 :=cdr cadr u;
    a2 := cdr caddr u;
    a3 := cadddr u;
-   fancy!-special!-symbol(get('empty!*,'fancy!-special!-symbol),nil);
+   %fancy!-special!-symbol(get('empty!*,'fancy!-special!-symbol),nil);
+   fancy!-prin2!*("{}",0);
    w:=fancy!-print!-one!-index length a1;
    if testing!-width!* and w eq 'failed then return w;
    fancy!-prin2!*("F",nil);
    w:=fancy!-print!-one!-index length a2;
    if testing!-width!* and w eq 'failed then return w;
-   fancy!-prin2!*("(",nil);
+   fancy!-prin2!*("\left(\left.",nil);
    w := w eq 'failed or fancy!-print!-indexlist1(a1,'!^,'!*comma!*);
    w := w eq 'failed or fancy!-print!-indexlist1(a2,'!_,'!*comma!*);
    fancy!-prin2!*("\,",1);
-   w := w eq 'failed or fancy!-special!-symbol(124,1);    % vertical bar
-   fancy!-prin2!*("\,",1);
+   %w := w eq 'failed or fancy!-special!-symbol(124,1);    % vertical bar
+   fancy!-prin2!*("\right|\,",1);
    w := w eq 'failed or fancy!-prinfit(a3,0,nil);
-   fancy!-prin2!*(")",nil);
+   fancy!-prin2!*("\right)",nil);
    return w;
   end;
    
@@ -1491,12 +1648,13 @@
 	fancy!-print!-indexlist1({m,n},'!^,nil);
    w := w eq 'failed or
 	fancy!-print!-indexlist1({p,q},'!_,nil);
-   fancy!-prin2!*("(",nil);
+   fancy!-prin2!*("\left(",nil);
    w := w eq 'failed or fancy!-prinfit(a3,0,nil);
-   w := w eq 'failed or fancy!-special!-symbol(124,1);    % vertical bar
+   %w := w eq 'failed or fancy!-special!-symbol(124,1);    % vertical bar
+   fancy!-prin2!*("\left|",1);
    w := w eq 'failed or fancy!-print!-indexlist1(a1,'!^,'!*comma!*);
    w := w eq 'failed or fancy!-print!-indexlist1(a2,'!_,'!*comma!*);
-   fancy!-prin2!*(")",nil);
+   fancy!-prin2!*("\right.\right)",nil);
    return w;
   end;
      
diff --recursive -u reduce.orig/xr/bin/texmacs.red reduce/xr/bin/texmacs.red
--- reduce.orig/xr/bin/texmacs.red	Mon Jul 15 23:36:51 2002
+++ reduce/xr/bin/texmacs.red	Mon Jul 15 23:33:30 2002
@@ -10,7 +10,7 @@
 
 % Redefine printprompt to cooperate with XR's expectations
 
-remflag ('(printprompt),'lose)$
+remflag ('(printprompt yesp),'lose)$
 
 symbolic (remd 'printprompt)$
 symbolic procedure printprompt u;
@@ -48,10 +48,10 @@
                  rds nil>>;
         if ofl!* then <<ofl:= ofl!*; wrs nil>>;
         if null !*lessspace then terpri();
-      	prin2 int2id 3;
+      	prin2 int2id 1;
         if atom u then prin2 u else lpri u;
         if null !*lessspace then terpri();
-        y := setpchar compress list('!",int2id 1,'!?,int2id 2,'!");
+        y := setpchar compress list('!",int2id 2,'!");
         x := yesp1();
         setpchar y;
         if ofl then wrs cdr ofl;
@@ -130,7 +130,7 @@
 
 % This line is needed whichever REDUCE you're running!
 
-load_package fmprint$
+load_package tmprint$
 
 
 % And get everything cleaned up and ready to go -- our
