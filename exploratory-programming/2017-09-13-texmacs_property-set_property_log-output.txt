  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" test-preference?) (tm-define-overloaded (set-preference which what) (with val (if (string? what) what (object->string what)) (when (!= (get-preference which) val) (cpp-set-preference which val) (notify-preference which) (save-preferences)))))
    => ((quote set-preference) #:check-mark (list "*" test-preference?))
 => cons <> cur-props
    => cur-props => (((quote set-preference) #:check-mark (list "*" test-preference?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set preference @which to @what") (tm-define-overloaded (set-preference which what) (with val (if (string? what) what (object->string what)) (when (!= (get-preference which) val) (cpp-set-preference which val) (notify-preference which) (save-preferences)))))
   => ((quote set-preference) #:synopsis (quote ("Set preference @which to @what")))
 => cons <> cur-props
   => cur-props => (((quote set-preference) #:synopsis (quote ("Set preference @which to @what"))) ((quote set-preference) #:check-mark (list "*" test-preference?)))

(property-set! var prop what conds*)
  <= (set-preference #:synopsis ("Set preference @which to @what") ())

(property-set! var prop what conds*)
  <= (set-preference #:check-mark ("*" #<procedure test-preference? (which what)>) ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Revert preference @which to default setting") (tm-define-overloaded (reset-preference which) (when (cpp-has-preference? which) (cpp-reset-preference which) (notify-preference which) (save-preferences))))
   => ((quote reset-preference) #:synopsis (quote ("Revert preference @which to default setting")))
 => cons <> cur-props
   => cur-props => (((quote reset-preference) #:synopsis (quote ("Revert preference @which to default setting"))))

(property-set! var prop what conds*)
  <= (reset-preference #:synopsis ("Revert preference @which to default setting") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Notify that the preference @which was changed") (tm-define-overloaded (notify-preference which) ((get-call-back which) which (get-preference which))))
   => ((quote notify-preference) #:synopsis (quote ("Notify that the preference @which was changed")))
 => cons <> cur-props
   => cur-props => (((quote notify-preference) #:synopsis (quote ("Notify that the preference @which was changed"))))

(property-set! var prop what conds*)
  <= (notify-preference #:synopsis ("Notify that the preference @which was changed") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Get preference @which") (tm-define-overloaded (get-preference which) (let* ((def (or (ahash-ref preferences-default which) "default")) (s? (string? def)) (r (cpp-get-preference which (if s? def (object->string def))))) (if s? r (string->object r)))))
   => ((quote get-preference) #:synopsis (quote ("Get preference @which")))
 => cons <> cur-props
   => cur-props => (((quote get-preference) #:synopsis (quote ("Get preference @which"))))

(property-set! var prop what conds*)
  <= (get-preference #:synopsis ("Get preference @which") ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" preference-on?) (tm-define-overloaded (toggle-preference which) (with what (get-preference which) (set-preference which (cond ((== what "on") "off") ((== what "off") "on") (else what))))))
    => ((quote toggle-preference) #:check-mark (list "v" preference-on?))
 => cons <> cur-props
    => cur-props => (((quote toggle-preference) #:check-mark (list "v" preference-on?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle the preference @which") (tm-define-overloaded (toggle-preference which) (with what (get-preference which) (set-preference which (cond ((== what "on") "off") ((== what "off") "on") (else what))))))
   => ((quote toggle-preference) #:synopsis (quote ("Toggle the preference @which")))
 => cons <> cur-props
   => cur-props => (((quote toggle-preference) #:synopsis (quote ("Toggle the preference @which"))) ((quote toggle-preference) #:check-mark (list "v" preference-on?)))

(property-set! var prop what conds*)
  <= (toggle-preference #:synopsis ("Toggle the preference @which") ())

(property-set! var prop what conds*)
  <= (toggle-preference #:check-mark ("v" #<procedure preference-on? (which)>) ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Appends @val to the list of values of preference @which") (tm-define-overloaded (append-preference which val) (with cur (get-preference which) (if (== cur "default") (set! cur (quote ()))) (set-preference which (rcons cur val)))))
   => ((quote append-preference) #:synopsis (quote ("Appends @val to the list of values of preference @which")))
 => cons <> cur-props
   => cur-props => (((quote append-preference) #:synopsis (quote ("Appends @val to the list of values of preference @which"))))

(property-set! var prop what conds*)
  <= (append-preference #:synopsis ("Appends @val to the list of values of preference @which") ())

  (define-option-argument opt decl)
    <= ((where "Remote server") (tm-define-overloaded (detect-remote-plugins where) (load-remote-plugins) (ahash-set! remote-plugins-table where (get-remote-plugin-info where)) (update-remote-tables) (save-remote-plugins)))
    => cons <> cur-props <= ((quote detect-remote-plugins) #:arguments (quote (where)))
    => cons <> cur-props <= ((quote detect-remote-plugins) (quote (#:argument where)) (quote ("Remote server")))
    => cur-props => (((quote detect-remote-plugins) (quote (#:argument where)) (quote ("Remote server"))) ((quote detect-remote-plugins) #:arguments (quote (where))))

(property-set! var prop what conds*)
  <= (detect-remote-plugins (#:argument where) ("Remote server") ())

(property-set! var prop what conds*)
  <= (detect-remote-plugins #:arguments (where) ())

  (define-option-proposals opt decl)
    <= ((where (remote-connection-servers)) (tm-define-overloaded (update-remote-plugins where) (detect-remote-plugins where)))
    => cons <> cur-props <= ((quote update-remote-plugins) (quote (#:proposals where)) (lambda () (remote-connection-servers)))
    => cur-props => (((quote update-remote-plugins) (quote (#:proposals where)) (lambda () (remote-connection-servers))))

  (define-option-argument opt decl)
    <= ((where "Remote server") (tm-define-overloaded (update-remote-plugins where) (detect-remote-plugins where)))
    => cons <> cur-props <= ((quote update-remote-plugins) #:arguments (quote (where)))
    => cons <> cur-props <= ((quote update-remote-plugins) (quote (#:argument where)) (quote ("Remote server")))
    => cur-props => (((quote update-remote-plugins) (quote (#:argument where)) (quote ("Remote server"))) ((quote update-remote-plugins) #:arguments (quote (where))) ((quote update-remote-plugins) (quote (#:proposals where)) (lambda () (remote-connection-servers))))

(property-set! var prop what conds*)
  <= (update-remote-plugins (#:argument where) ("Remote server") ())

(property-set! var prop what conds*)
  <= (update-remote-plugins #:arguments (where) ())

(property-set! var prop what conds*)
  <= (update-remote-plugins (#:proposals where) #<procedure #f ()> ())

  (define-option-proposals opt decl)
    <= ((where (remote-connection-servers)) (tm-define-overloaded (remove-remote-plugins where) (load-remote-plugins) (ahash-remove! remote-plugins-table where) (update-remote-tables) (save-remote-plugins)))
    => cons <> cur-props <= ((quote remove-remote-plugins) (quote (#:proposals where)) (lambda () (remote-connection-servers)))
    => cur-props => (((quote remove-remote-plugins) (quote (#:proposals where)) (lambda () (remote-connection-servers))))

  (define-option-argument opt decl)
    <= ((where "Remote server") (tm-define-overloaded (remove-remote-plugins where) (load-remote-plugins) (ahash-remove! remote-plugins-table where) (update-remote-tables) (save-remote-plugins)))
    => cons <> cur-props <= ((quote remove-remote-plugins) #:arguments (quote (where)))
    => cons <> cur-props <= ((quote remove-remote-plugins) (quote (#:argument where)) (quote ("Remote server")))
    => cur-props => (((quote remove-remote-plugins) (quote (#:argument where)) (quote ("Remote server"))) ((quote remove-remote-plugins) #:arguments (quote (where))) ((quote remove-remote-plugins) (quote (#:proposals where)) (lambda () (remote-connection-servers))))

(property-set! var prop what conds*)
  <= (remove-remote-plugins (#:argument where) ("Remote server") ())

(property-set! var prop what conds*)
  <= (remove-remote-plugins #:arguments (where) ())

(property-set! var prop what conds*)
  <= (remove-remote-plugins (#:proposals where) #<procedure #f ()> ())

(property-set! var prop what conds*)
  <= (boolean? #:secure #t ())

(property-set! var prop what conds*)
  <= (null? #:secure #t ())

(property-set! var prop what conds*)
  <= (symbol? #:secure #t ())

(property-set! var prop what conds*)
  <= (string? #:secure #t ())

(property-set! var prop what conds*)
  <= (pair? #:secure #t ())

(property-set! var prop what conds*)
  <= (list? #:secure #t ())

(property-set! var prop what conds*)
  <= (equal? #:secure #t ())

(property-set! var prop what conds*)
  <= (== #:secure #t ())

(property-set! var prop what conds*)
  <= (not #:secure #t ())

(property-set! var prop what conds*)
  <= (string-length #:secure #t ())

(property-set! var prop what conds*)
  <= (substring #:secure #t ())

(property-set! var prop what conds*)
  <= (string-append #:secure #t ())

(property-set! var prop what conds*)
  <= (string->list #:secure #t ())

(property-set! var prop what conds*)
  <= (list->string #:secure #t ())

(property-set! var prop what conds*)
  <= (string-ref #:secure #t ())

(property-set! var prop what conds*)
  <= (string-set! #:secure #t ())

(property-set! var prop what conds*)
  <= (+ #:secure #t ())

(property-set! var prop what conds*)
  <= (- #:secure #t ())

(property-set! var prop what conds*)
  <= (* #:secure #t ())

(property-set! var prop what conds*)
  <= (/ #:secure #t ())

(property-set! var prop what conds*)
  <= (gcd #:secure #t ())

(property-set! var prop what conds*)
  <= (lcm #:secure #t ())

(property-set! var prop what conds*)
  <= (quotient #:secure #t ())

(property-set! var prop what conds*)
  <= (remainder #:secure #t ())

(property-set! var prop what conds*)
  <= (modulo #:secure #t ())

(property-set! var prop what conds*)
  <= (abs #:secure #t ())

(property-set! var prop what conds*)
  <= (log #:secure #t ())

(property-set! var prop what conds*)
  <= (exp #:secure #t ())

(property-set! var prop what conds*)
  <= (sqrt #:secure #t ())

(property-set! var prop what conds*)
  <= (car #:secure #t ())

(property-set! var prop what conds*)
  <= (cdr #:secure #t ())

(property-set! var prop what conds*)
  <= (caar #:secure #t ())

(property-set! var prop what conds*)
  <= (cadr #:secure #t ())

(property-set! var prop what conds*)
  <= (cdar #:secure #t ())

(property-set! var prop what conds*)
  <= (cddr #:secure #t ())

(property-set! var prop what conds*)
  <= (caaar #:secure #t ())

(property-set! var prop what conds*)
  <= (caadr #:secure #t ())

(property-set! var prop what conds*)
  <= (cadar #:secure #t ())

(property-set! var prop what conds*)
  <= (caddr #:secure #t ())

(property-set! var prop what conds*)
  <= (cdaar #:secure #t ())

(property-set! var prop what conds*)
  <= (cdadr #:secure #t ())

(property-set! var prop what conds*)
  <= (cddar #:secure #t ())

(property-set! var prop what conds*)
  <= (cdddr #:secure #t ())

(property-set! var prop what conds*)
  <= (caaaar #:secure #t ())

(property-set! var prop what conds*)
  <= (caaadr #:secure #t ())

(property-set! var prop what conds*)
  <= (caadar #:secure #t ())

(property-set! var prop what conds*)
  <= (caaddr #:secure #t ())

(property-set! var prop what conds*)
  <= (cadaar #:secure #t ())

(property-set! var prop what conds*)
  <= (cadadr #:secure #t ())

(property-set! var prop what conds*)
  <= (caddar #:secure #t ())

(property-set! var prop what conds*)
  <= (cadddr #:secure #t ())

(property-set! var prop what conds*)
  <= (cdaaar #:secure #t ())

(property-set! var prop what conds*)
  <= (cdaadr #:secure #t ())

(property-set! var prop what conds*)
  <= (cdadar #:secure #t ())

(property-set! var prop what conds*)
  <= (cdaddr #:secure #t ())

(property-set! var prop what conds*)
  <= (cddaar #:secure #t ())

(property-set! var prop what conds*)
  <= (cddadr #:secure #t ())

(property-set! var prop what conds*)
  <= (cdddar #:secure #t ())

(property-set! var prop what conds*)
  <= (cddddr #:secure #t ())

(property-set! var prop what conds*)
  <= (cons #:secure #t ())

(property-set! var prop what conds*)
  <= (list #:secure #t ())

(property-set! var prop what conds*)
  <= (append #:secure #t ())

(property-set! var prop what conds*)
  <= (length #:secure #t ())

(property-set! var prop what conds*)
  <= (reverse #:secure #t ())

(property-set! var prop what conds*)
  <= (texmacs-version #:secure #t ())

(property-set! var prop what conds*)
  <= (texmacs-version-release* #:secure #t ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (interactive fun . args) (lazy-define-force fun) (if (null? args) (set! args (compute-interactive-args fun))) (with fun-args (build-interactive-args fun args 0 #t) (tm-interactive fun fun-args))))
    => ((quote interactive) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote interactive) #:interactive (list #t)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Call @fun with interactively specified arguments @args") (tm-define-overloaded (interactive fun . args) (lazy-define-force fun) (if (null? args) (set! args (compute-interactive-args fun))) (with fun-args (build-interactive-args fun args 0 #t) (tm-interactive fun fun-args))))
   => ((quote interactive) #:synopsis (quote ("Call @fun with interactively specified arguments @args")))
 => cons <> cur-props
   => cur-props => (((quote interactive) #:synopsis (quote ("Call @fun with interactively specified arguments @args"))) ((quote interactive) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (interactive #:synopsis ("Call @fun with interactively specified arguments @args") ())

(property-set! var prop what conds*)
  <= (interactive #:interactive (#t) ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Define the formal language @lan") (tm-define-overloaded (define-language$impl lan . gr) (quasiquote (define-language-impl (symbol->string (quote (unquote lan))) (quote (unquote gr))))))
   => ((quote define-language$impl) #:synopsis (quote ("Define the formal language @lan")))
 => cons <> cur-props
   => cur-props => (((quote define-language$impl) #:synopsis (quote ("Define the formal language @lan"))))

(property-set! var prop what conds*)
  <= (define-language$impl #:synopsis ("Define the formal language @lan") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Promise that the languages @lans are defined in the module @m") (tm-define-overloaded (lazy-language$impl m . lans) (quasiquote (for-each (lambda (lan) (lazy-language-impl lan (quote (unquote m)))) (quote (unquote lans))))))
   => ((quote lazy-language$impl) #:synopsis (quote ("Promise that the languages @lans are defined in the module @m")))
 => cons <> cur-props
   => cur-props => (((quote lazy-language$impl) #:synopsis (quote ("Promise that the languages @lans are defined in the module @m"))))

(property-set! var prop what conds*)
  <= (lazy-language$impl #:synopsis ("Promise that the languages @lans are defined in the module @m") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Execute promise to define the language @lan") (tm-define-overloaded (lazy-language-force$impl lan) (quasiquote (lazy-language-force-impl (quote (unquote lan))))))
   => ((quote lazy-language-force$impl) #:synopsis (quote ("Execute promise to define the language @lan")))
 => cons <> cur-props
   => cur-props => (((quote lazy-language-force$impl) #:synopsis (quote ("Execute promise to define the language @lan"))))

(property-set! var prop what conds*)
  <= (lazy-language-force$impl #:synopsis ("Execute promise to define the language @lan") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Get rightmost path until where @x can be parsed in @lan") (tm-define-overloaded (semantic-end$impl lan gr in) (quasiquote (let* ((lan2 (symbol->string (quote (unquote lan)))) (gr2 (symbol->string (quote (unquote gr)))) (in2 (unquote in))) (packrat-parse lan2 gr2 in2)))))
   => ((quote semantic-end$impl) #:synopsis (quote ("Get rightmost path until where @x can be parsed in @lan")))
 => cons <> cur-props
   => cur-props => (((quote semantic-end$impl) #:synopsis (quote ("Get rightmost path until where @x can be parsed in @lan"))))

(property-set! var prop what conds*)
  <= (semantic-end$impl #:synopsis ("Get rightmost path until where @x can be parsed in @lan") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Get semantic selections englobing @in at @pos") (tm-define-overloaded (semantic-context$impl lan gr in pos) (quasiquote (let* ((lan2 (symbol->string (quote (unquote lan)))) (gr2 (symbol->string (quote (unquote gr)))) (in2 (unquote in)) (pos1 (unquote pos)) (pos2 (if (number? pos1) (list pos1) pos1))) (packrat-context lan2 gr2 in2 pos2)))))
   => ((quote semantic-context$impl) #:synopsis (quote ("Get semantic selections englobing @in at @pos")))
 => cons <> cur-props
   => cur-props => (((quote semantic-context$impl) #:synopsis (quote ("Get semantic selections englobing @in at @pos"))))

(property-set! var prop what conds*)
  <= (semantic-context$impl #:synopsis ("Get semantic selections englobing @in at @pos") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make widgets") (tm-define-overloaded ($list$impl . l) (quasiquote (gui-normalize (list (unquote-splicing l))))))
   => ((quote $list$impl) #:synopsis (quote ("Make widgets")))
 => cons <> cur-props
   => cur-props => (((quote $list$impl) #:synopsis (quote ("Make widgets"))))

(property-set! var prop what conds*)
  <= ($list$impl #:synopsis ("Make widgets") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Begin primitive for content generation") (tm-define-overloaded ($begin$impl . l) (quasiquote (cons* (quote list) ($list (unquote-splicing l))))))
   => ((quote $begin$impl) #:synopsis (quote ("Begin primitive for content generation")))
 => cons <> cur-props
   => cur-props => (((quote $begin$impl) #:synopsis (quote ("Begin primitive for content generation"))))

(property-set! var prop what conds*)
  <= ($begin$impl #:synopsis ("Begin primitive for content generation") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("When primitive for content generation") (tm-define-overloaded ($if$impl pred? . l) (cond ((== (length l) 1) (quasiquote (cons* (quote list) (if (unquote pred?) ($list (unquote (car l))) (quote ()))))) ((== (length l) 2) (quasiquote (cons* (quote list) (if (unquote pred?) ($list (unquote (car l))) ($list (unquote (cadr l))))))) (else (texmacs-error "$if" "invalid number of arguments")))))
   => ((quote $if$impl) #:synopsis (quote ("When primitive for content generation")))
 => cons <> cur-props
   => cur-props => (((quote $if$impl) #:synopsis (quote ("When primitive for content generation"))))

(property-set! var prop what conds*)
  <= ($if$impl #:synopsis ("When primitive for content generation") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("When primitive for content generation") (tm-define-overloaded ($when$impl pred? . l) (quasiquote (cons* (quote list) (if (unquote pred?) ($list (unquote-splicing l)) (quote ()))))))
   => ((quote $when$impl) #:synopsis (quote ("When primitive for content generation")))
 => cons <> cur-props
   => cur-props => (((quote $when$impl) #:synopsis (quote ("When primitive for content generation"))))

(property-set! var prop what conds*)
  <= ($when$impl #:synopsis ("When primitive for content generation") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("For primitive for content generation") (tm-define-overloaded ($for*$impl var-vals . l) (quasiquote (list (quote for) (lambda ((unquote (car var-vals))) ($list (unquote-splicing l))) (lambda () (unquote (cadr var-vals)))))))
   => ((quote $for*$impl) #:synopsis (quote ("For primitive for content generation")))
 => cons <> cur-props
   => cur-props => (((quote $for*$impl) #:synopsis (quote ("For primitive for content generation"))))

(property-set! var prop what conds*)
  <= ($for*$impl #:synopsis ("For primitive for content generation") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Cond primitive for content generation") (tm-define-overloaded ($cond$impl . l) (quasiquote (cons* (quote list) (cond (unquote-splicing (cond$sub l)))))))
   => ((quote $cond$impl) #:synopsis (quote ("Cond primitive for content generation")))
 => cons <> cur-props
   => cur-props => (((quote $cond$impl) #:synopsis (quote ("Cond primitive for content generation"))))

(property-set! var prop what conds*)
  <= ($cond$impl #:synopsis ("Cond primitive for content generation") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Let* primitive for content generation") (tm-define-overloaded ($let$impl decls . l) (quasiquote (let (unquote decls) (cons* (quote list) ($list (unquote-splicing l)))))))
   => ((quote $let$impl) #:synopsis (quote ("Let* primitive for content generation")))
 => cons <> cur-props
   => cur-props => (((quote $let$impl) #:synopsis (quote ("Let* primitive for content generation"))))

(property-set! var prop what conds*)
  <= ($let$impl #:synopsis ("Let* primitive for content generation") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Let* primitive for content generation") (tm-define-overloaded ($let*$impl decls . l) (quasiquote (let* (unquote decls) (cons* (quote list) ($list (unquote-splicing l)))))))
   => ((quote $let*$impl) #:synopsis (quote ("Let* primitive for content generation")))
 => cons <> cur-props
   => cur-props => (((quote $let*$impl) #:synopsis (quote ("Let* primitive for content generation"))))

(property-set! var prop what conds*)
  <= ($let*$impl #:synopsis ("Let* primitive for content generation") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("With primitive for content generation") (tm-define-overloaded ($with$impl var val . l) (quasiquote (with (unquote var) (unquote val) (cons* (quote list) ($list (unquote-splicing l)))))))
   => ((quote $with$impl) #:synopsis (quote ("With primitive for content generation")))
 => cons <> cur-props
   => cur-props => (((quote $with$impl) #:synopsis (quote ("With primitive for content generation"))))

(property-set! var prop what conds*)
  <= ($with$impl #:synopsis ("With primitive for content generation") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Execute one command") (tm-define-overloaded ($execute$impl cmd . l) (quasiquote (begin (unquote cmd) (cons* (quote list) ($list (unquote-splicing l)))))))
   => ((quote $execute$impl) #:synopsis (quote ("Execute one command")))
 => cons <> cur-props
   => cur-props => (((quote $execute$impl) #:synopsis (quote ("Execute one command"))))

(property-set! var prop what conds*)
  <= ($execute$impl #:synopsis ("Execute one command") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("For primitive for content generation") (tm-define-overloaded ($for$impl var-val . l) (when (nlist-2? var-val) (texmacs-error "$for" "syntax error in ~S" var-val)) (with fun (quasiquote (lambda ((unquote (car var-val))) ($list (unquote-splicing l)))) (quasiquote (cons* (quote list) (append-map (unquote fun) (unquote (cadr var-val))))))))
   => ((quote $for$impl) #:synopsis (quote ("For primitive for content generation")))
 => cons <> cur-props
   => cur-props => (((quote $for$impl) #:synopsis (quote ("For primitive for content generation"))))

(property-set! var prop what conds*)
  <= ($for$impl #:synopsis ("For primitive for content generation") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make dynamic widgets") (tm-define-overloaded ($dynamic$impl w) (quasiquote (cons* (quote list) (unquote w)))))
   => ((quote $dynamic$impl) #:synopsis (quote ("Make dynamic widgets")))
 => cons <> cur-props
   => cur-props => (((quote $dynamic$impl) #:synopsis (quote ("Make dynamic widgets"))))

(property-set! var prop what conds*)
  <= ($dynamic$impl #:synopsis ("Make dynamic widgets") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Promise widgets") (tm-define-overloaded ($promise$impl cmd) (quasiquote (list (quote promise) (lambda () (unquote cmd))))))
   => ((quote $promise$impl) #:synopsis (quote ("Promise widgets")))
 => cons <> cur-props
   => cur-props => (((quote $promise$impl) #:synopsis (quote ("Promise widgets"))))

(property-set! var prop what conds*)
  <= ($promise$impl #:synopsis ("Promise widgets") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make dynamic link to another widget") (tm-define-overloaded ($menu-link$impl w) (quasiquote (list (quote link) (quote (unquote w))))))
   => ((quote $menu-link$impl) #:synopsis (quote ("Make dynamic link to another widget")))
 => cons <> cur-props
   => cur-props => (((quote $menu-link$impl) #:synopsis (quote ("Make dynamic link to another widget"))))

(property-set! var prop what conds*)
  <= ($menu-link$impl #:synopsis ("Make dynamic link to another widget") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Delayed when primitive for content generation") (tm-define-overloaded ($delayed-when$impl pred? . l) (quasiquote (cons* (quote if) (lambda () (unquote pred?)) ($list (unquote-splicing l))))))
   => ((quote $delayed-when$impl) #:synopsis (quote ("Delayed when primitive for content generation")))
 => cons <> cur-props
   => cur-props => (((quote $delayed-when$impl) #:synopsis (quote ("Delayed when primitive for content generation"))))

(property-set! var prop what conds*)
  <= ($delayed-when$impl #:synopsis ("Delayed when primitive for content generation") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make possibly inert (whence greyed) widgets") (tm-define-overloaded ($assuming$impl pred? . l) (quasiquote (cons* (quote when) (lambda () (unquote pred?)) ($list (unquote-splicing l))))))
   => ((quote $assuming$impl) #:synopsis (quote ("Make possibly inert (whence greyed) widgets")))
 => cons <> cur-props
   => cur-props => (((quote $assuming$impl) #:synopsis (quote ("Make possibly inert (whence greyed) widgets"))))

(property-set! var prop what conds*)
  <= ($assuming$impl #:synopsis ("Make possibly inert (whence greyed) widgets") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make a refresh widget") (tm-define-overloaded ($refresh$impl s kind) (quasiquote (list (quote refresh) (quote (unquote s)) (unquote kind)))))
   => ((quote $refresh$impl) #:synopsis (quote ("Make a refresh widget")))
 => cons <> cur-props
   => cur-props => (((quote $refresh$impl) #:synopsis (quote ("Make a refresh widget"))))

(property-set! var prop what conds*)
  <= ($refresh$impl #:synopsis ("Make a refresh widget") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make a refreshable widget") (tm-define-overloaded ($refreshable$impl kind . l) (quasiquote (cons* (quote refreshable) (lambda () (unquote kind)) ($list (unquote-splicing l))))))
   => ((quote $refreshable$impl) #:synopsis (quote ("Make a refreshable widget")))
 => cons <> cur-props
   => cur-props => (((quote $refreshable$impl) #:synopsis (quote ("Make a refreshable widget"))))

(property-set! var prop what conds*)
  <= ($refreshable$impl #:synopsis ("Make a refreshable widget") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make extensible glue") (tm-define-overloaded ($glue$impl hext? vext? minw minh) (quasiquote (list (quote glue) (unquote hext?) (unquote vext?) (unquote minw) (unquote minh)))))
   => ((quote $glue$impl) #:synopsis (quote ("Make extensible glue")))
 => cons <> cur-props
   => cur-props => (((quote $glue$impl) #:synopsis (quote ("Make extensible glue"))))

(property-set! var prop what conds*)
  <= ($glue$impl #:synopsis ("Make extensible glue") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make extensible colored glue") (tm-define-overloaded ($colored-glue$impl col hext? vext? minw minh) (quasiquote (list (quote color) (unquote col) (unquote hext?) (unquote vext?) (unquote minw) (unquote minh)))))
   => ((quote $colored-glue$impl) #:synopsis (quote ("Make extensible colored glue")))
 => cons <> cur-props
   => cur-props => (((quote $colored-glue$impl) #:synopsis (quote ("Make extensible colored glue"))))

(property-set! var prop what conds*)
  <= ($colored-glue$impl #:synopsis ("Make extensible colored glue") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Horizontal layout of widgets") (tm-define-overloaded ($hlist$impl . l) (quasiquote (cons* (quote hlist) ($list (unquote-splicing l))))))
   => ((quote $hlist$impl) #:synopsis (quote ("Horizontal layout of widgets")))
 => cons <> cur-props
   => cur-props => (((quote $hlist$impl) #:synopsis (quote ("Horizontal layout of widgets"))))

(property-set! var prop what conds*)
  <= ($hlist$impl #:synopsis ("Horizontal layout of widgets") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Vertical layout of widgets") (tm-define-overloaded ($vlist$impl . l) (quasiquote (cons* (quote vlist) ($list (unquote-splicing l))))))
   => ((quote $vlist$impl) #:synopsis (quote ("Vertical layout of widgets")))
 => cons <> cur-props
   => cur-props => (((quote $vlist$impl) #:synopsis (quote ("Vertical layout of widgets"))))

(property-set! var prop what conds*)
  <= ($vlist$impl #:synopsis ("Vertical layout of widgets") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Align two column table") (tm-define-overloaded ($aligned$impl . l) (quasiquote (cons* (quote aligned) ($list (unquote-splicing l))))))
   => ((quote $aligned$impl) #:synopsis (quote ("Align two column table")))
 => cons <> cur-props
   => cur-props => (((quote $aligned$impl) #:synopsis (quote ("Align two column table"))))

(property-set! var prop what conds*)
  <= ($aligned$impl #:synopsis ("Align two column table") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Item in an aligned list") (tm-define-overloaded ($aligned-item$impl . l) (quasiquote (cons* (quote aligned-item) ($list (unquote-splicing l))))))
   => ((quote $aligned-item$impl) #:synopsis (quote ("Item in an aligned list")))
 => cons <> cur-props
   => cur-props => (((quote $aligned-item$impl) #:synopsis (quote ("Item in an aligned list"))))

(property-set! var prop what conds*)
  <= ($aligned-item$impl #:synopsis ("Item in an aligned list") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("A tab bar") (tm-define-overloaded ($tabs$impl . l) (quasiquote (cons* (quote tabs) ($list (unquote-splicing l))))))
   => ((quote $tabs$impl) #:synopsis (quote ("A tab bar")))
 => cons <> cur-props
   => cur-props => (((quote $tabs$impl) #:synopsis (quote ("A tab bar"))))

(property-set! var prop what conds*)
  <= ($tabs$impl #:synopsis ("A tab bar") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("One tab of a tab bar") (tm-define-overloaded ($tab$impl . l) (quasiquote (cons* (quote tab) ($list (unquote-splicing l))))))
   => ((quote $tab$impl) #:synopsis (quote ("One tab of a tab bar")))
 => cons <> cur-props
   => cur-props => (((quote $tab$impl) #:synopsis (quote ("One tab of a tab bar"))))

(property-set! var prop what conds*)
  <= ($tab$impl #:synopsis ("One tab of a tab bar") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("An icon tab bar") (tm-define-overloaded ($icon-tabs$impl . l) (quasiquote (cons* (quote icon-tabs) ($list (unquote-splicing l))))))
   => ((quote $icon-tabs$impl) #:synopsis (quote ("An icon tab bar")))
 => cons <> cur-props
   => cur-props => (((quote $icon-tabs$impl) #:synopsis (quote ("An icon tab bar"))))

(property-set! var prop what conds*)
  <= ($icon-tabs$impl #:synopsis ("An icon tab bar") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("One icon tab of an icon tab bar") (tm-define-overloaded ($icon-tab$impl . l) (quasiquote (cons* (quote icon-tab) ($list (unquote-splicing l))))))
   => ((quote $icon-tab$impl) #:synopsis (quote ("One icon tab of an icon tab bar")))
 => cons <> cur-props
   => cur-props => (((quote $icon-tab$impl) #:synopsis (quote ("One icon tab of an icon tab bar"))))

(property-set! var prop what conds*)
  <= ($icon-tab$impl #:synopsis ("One icon tab of an icon tab bar") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Horizontal layout of widgets") (tm-define-overloaded ($horizontal$impl . l) (quasiquote (cons* (quote horizontal) ($list (unquote-splicing l))))))
   => ((quote $horizontal$impl) #:synopsis (quote ("Horizontal layout of widgets")))
 => cons <> cur-props
   => cur-props => (((quote $horizontal$impl) #:synopsis (quote ("Horizontal layout of widgets"))))

(property-set! var prop what conds*)
  <= ($horizontal$impl #:synopsis ("Horizontal layout of widgets") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Vertical layout of widgets") (tm-define-overloaded ($vertical$impl . l) (quasiquote (cons* (quote vertical) ($list (unquote-splicing l))))))
   => ((quote $vertical$impl) #:synopsis (quote ("Vertical layout of widgets")))
 => cons <> cur-props
   => cur-props => (((quote $vertical$impl) #:synopsis (quote ("Vertical layout of widgets"))))

(property-set! var prop what conds*)
  <= ($vertical$impl #:synopsis ("Vertical layout of widgets") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Tile layout of widgets") (tm-define-overloaded ($tile$impl columns . l) (quasiquote (cons* (quote tile) (unquote columns) ($list (unquote-splicing l))))))
   => ((quote $tile$impl) #:synopsis (quote ("Tile layout of widgets")))
 => cons <> cur-props
   => cur-props => (((quote $tile$impl) #:synopsis (quote ("Tile layout of widgets"))))

(property-set! var prop what conds*)
  <= ($tile$impl #:synopsis ("Tile layout of widgets") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make a scrollable widget") (tm-define-overloaded ($scrollable$impl . l) (quasiquote (cons* (quote scrollable) ($list (unquote-splicing l))))))
   => ((quote $scrollable$impl) #:synopsis (quote ("Make a scrollable widget")))
 => cons <> cur-props
   => cur-props => (((quote $scrollable$impl) #:synopsis (quote ("Make a scrollable widget"))))

(property-set! var prop what conds*)
  <= ($scrollable$impl #:synopsis ("Make a scrollable widget") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Resize the widget") (tm-define-overloaded ($resize$impl w h . l) (quasiquote (cons* (quote resize) (quote (unquote w)) (quote (unquote h)) ($list (unquote-splicing l))))))
   => ((quote $resize$impl) #:synopsis (quote ("Resize the widget")))
 => cons <> cur-props
   => cur-props => (((quote $resize$impl) #:synopsis (quote ("Resize the widget"))))

(property-set! var prop what conds*)
  <= ($resize$impl #:synopsis ("Resize the widget") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Widget which is split horizontally into two parts") (tm-define-overloaded ($hsplit$impl l r) (quasiquote (list (quote hsplit) (unquote l) (unquote r)))))
   => ((quote $hsplit$impl) #:synopsis (quote ("Widget which is split horizontally into two parts")))
 => cons <> cur-props
   => cur-props => (((quote $hsplit$impl) #:synopsis (quote ("Widget which is split horizontally into two parts"))))

(property-set! var prop what conds*)
  <= ($hsplit$impl #:synopsis ("Widget which is split horizontally into two parts") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Widget which is split vertically into two parts") (tm-define-overloaded ($vsplit$impl t b) (quasiquote (list (quote vsplit) (unquote t) (unquote b)))))
   => ((quote $vsplit$impl) #:synopsis (quote ("Widget which is split vertically into two parts")))
 => cons <> cur-props
   => cur-props => (((quote $vsplit$impl) #:synopsis (quote ("Widget which is split vertically into two parts"))))

(property-set! var prop what conds*)
  <= ($vsplit$impl #:synopsis ("Widget which is split vertically into two parts") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Horizontal separator") (tm-define-overloaded $/ (string->symbol "|")))
   => ((quote $/) #:synopsis (quote ("Horizontal separator")))
 => cons <> cur-props
   => cur-props => (((quote $/) #:synopsis (quote ("Horizontal separator"))))

(property-set! var prop what conds*)
  <= ($/ #:synopsis ("Horizontal separator") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Vertical separator") (tm-define-overloaded $--- (quote ---)))
   => ((quote $---) #:synopsis (quote ("Vertical separator")))
 => cons <> cur-props
   => cur-props => (((quote $---) #:synopsis (quote ("Vertical separator"))))

(property-set! var prop what conds*)
  <= ($--- #:synopsis ("Vertical separator") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make mini widgets") (tm-define-overloaded ($mini$impl pred? . l) (quasiquote (cons* (quote mini) (lambda () (unquote pred?)) ($list (unquote-splicing l))))))
   => ((quote $mini$impl) #:synopsis (quote ("Make mini widgets")))
 => cons <> cur-props
   => cur-props => (((quote $mini$impl) #:synopsis (quote ("Make mini widgets"))))

(property-set! var prop what conds*)
  <= ($mini$impl #:synopsis ("Make mini widgets") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make minibar") (tm-define-overloaded (gui$minibar$impl . l) (quasiquote (cons* (quote minibar) ($list (unquote-splicing l))))))
   => ((quote gui$minibar$impl) #:synopsis (quote ("Make minibar")))
 => cons <> cur-props
   => cur-props => (((quote gui$minibar$impl) #:synopsis (quote ("Make minibar"))))

(property-set! var prop what conds*)
  <= (gui$minibar$impl #:synopsis ("Make minibar") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Change the style of a widget") (tm-define-overloaded ($widget-style$impl st . l) (quasiquote (cons* (quote style) (unquote st) ($list (unquote-splicing l))))))
   => ((quote $widget-style$impl) #:synopsis (quote ("Change the style of a widget")))
 => cons <> cur-props
   => cur-props => (((quote $widget-style$impl) #:synopsis (quote ("Change the style of a widget"))))

(property-set! var prop what conds*)
  <= ($widget-style$impl #:synopsis ("Change the style of a widget") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Extend the size of a widget") (tm-define-overloaded ($widget-extend$impl w . l) (quasiquote (cons* (quote extend) (unquote w) ($list (unquote-splicing l))))))
   => ((quote $widget-extend$impl) #:synopsis (quote ("Extend the size of a widget")))
 => cons <> cur-props
   => cur-props => (((quote $widget-extend$impl) #:synopsis (quote ("Extend the size of a widget"))))

(property-set! var prop what conds*)
  <= ($widget-extend$impl #:synopsis ("Extend the size of a widget") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make pullright button") (tm-define-overloaded ($->$impl text . l) (if developer-mode? (ahash-set! all-translations text #t)) (quasiquote (cons* (quote ->) (unquote text) ($list (unquote-splicing l))))))
   => ((quote $->$impl) #:synopsis (quote ("Make pullright button")))
 => cons <> cur-props
   => cur-props => (((quote $->$impl) #:synopsis (quote ("Make pullright button"))))

(property-set! var prop what conds*)
  <= ($->$impl #:synopsis ("Make pullright button") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make pulldown button") (tm-define-overloaded ($=>$impl text . l) (if developer-mode? (ahash-set! all-translations text #t)) (quasiquote (cons* (quote =>) (unquote text) ($list (unquote-splicing l))))))
   => ((quote $=>$impl) #:synopsis (quote ("Make pulldown button")))
 => cons <> cur-props
   => cur-props => (((quote $=>$impl) #:synopsis (quote ("Make pulldown button"))))

(property-set! var prop what conds*)
  <= ($=>$impl #:synopsis ("Make pulldown button") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make button") (tm-define-overloaded ($>$impl text . cmds) (if developer-mode? (ahash-set! all-translations text #t)) (quasiquote (list (unquote text) (lambda () (unquote-splicing cmds))))))
   => ((quote $>$impl) #:synopsis (quote ("Make button")))
 => cons <> cur-props
   => cur-props => (((quote $>$impl) #:synopsis (quote ("Make button"))))

(property-set! var prop what conds*)
  <= ($>$impl #:synopsis ("Make button") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make button") (tm-define-overloaded ($check$impl text check pred?) (if developer-mode? (ahash-set! all-translations text #t)) (quasiquote (list (quote check) (unquote text) (unquote check) (lambda () (unquote pred?))))))
   => ((quote $check$impl) #:synopsis (quote ("Make button")))
 => cons <> cur-props
   => cur-props => (((quote $check$impl) #:synopsis (quote ("Make button"))))

(property-set! var prop what conds*)
  <= ($check$impl #:synopsis ("Make button") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make balloon") (tm-define-overloaded ($balloon$impl text balloon) (if developer-mode? (ahash-set! all-translations text #t)) (quasiquote (list (quote balloon) (unquote text) (unquote balloon)))))
   => ((quote $balloon$impl) #:synopsis (quote ("Make balloon")))
 => cons <> cur-props
   => cur-props => (((quote $balloon$impl) #:synopsis (quote ("Make balloon"))))

(property-set! var prop what conds*)
  <= ($balloon$impl #:synopsis ("Make balloon") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make text concatenation") (tm-define-overloaded ($concat-text$impl . l) (quasiquote (quote (concat (unquote-splicing l))))))
   => ((quote $concat-text$impl) #:synopsis (quote ("Make text concatenation")))
 => cons <> cur-props
   => cur-props => (((quote $concat-text$impl) #:synopsis (quote ("Make text concatenation"))))

(property-set! var prop what conds*)
  <= ($concat-text$impl #:synopsis ("Make text concatenation") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make verbatim text") (tm-define-overloaded ($verbatim-text$impl . l) (quasiquote (quote (verbatim (unquote-splicing l))))))
   => ((quote $verbatim-text$impl) #:synopsis (quote ("Make verbatim text")))
 => cons <> cur-props
   => cur-props => (((quote $verbatim-text$impl) #:synopsis (quote ("Make verbatim text"))))

(property-set! var prop what conds*)
  <= ($verbatim-text$impl #:synopsis ("Make verbatim text") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make text to be translated with arguments") (tm-define-overloaded ($replace-text$impl str . x) (if developer-mode? (ahash-set! all-translations (car x) #t)) (quasiquote (quote (replace (unquote str) (unquote-splicing x))))))
   => ((quote $replace-text$impl) #:synopsis (quote ("Make text to be translated with arguments")))
 => cons <> cur-props
   => cur-props => (((quote $replace-text$impl) #:synopsis (quote ("Make text to be translated with arguments"))))

(property-set! var prop what conds*)
  <= ($replace-text$impl #:synopsis ("Make text to be translated with arguments") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make icon") (tm-define-overloaded ($icon$impl name) (quasiquote (list (quote icon) (unquote name)))))
   => ((quote $icon$impl) #:synopsis (quote ("Make icon")))
 => cons <> cur-props
   => cur-props => (((quote $icon$impl) #:synopsis (quote ("Make icon"))))

(property-set! var prop what conds*)
  <= ($icon$impl #:synopsis ("Make icon") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make a menu symbol") (tm-define-overloaded ($symbol$impl sym . l) (if (null? l) (quasiquote (list (quote symbol) (unquote sym))) (quasiquote (list (quote symbol) (unquote sym) (lambda () (unquote (car l))))))))
   => ((quote $symbol$impl) #:synopsis (quote ("Make a menu symbol")))
 => cons <> cur-props
   => cur-props => (((quote $symbol$impl) #:synopsis (quote ("Make a menu symbol"))))

(property-set! var prop what conds*)
  <= ($symbol$impl #:synopsis ("Make a menu symbol") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make a menu group") (tm-define-overloaded ($menu-group$impl text) (quasiquote (list (quote group) (unquote (process-translate text))))))
   => ((quote $menu-group$impl) #:synopsis (quote ("Make a menu group")))
 => cons <> cur-props
   => cur-props => (((quote $menu-group$impl) #:synopsis (quote ("Make a menu group"))))

(property-set! var prop what conds*)
  <= ($menu-group$impl #:synopsis ("Make a menu group") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make text") (tm-define-overloaded ($menu-text$impl text) (if developer-mode? (ahash-set! all-translations text #t)) (quasiquote (list (quote text) (unquote (process-translate text))))))
   => ((quote $menu-text$impl) #:synopsis (quote ("Make text")))
 => cons <> cur-props
   => cur-props => (((quote $menu-text$impl) #:synopsis (quote ("Make text"))))

(property-set! var prop what conds*)
  <= ($menu-text$impl #:synopsis ("Make text") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make input field") (tm-define-overloaded ($input$impl cmd type proposals width) (quasiquote (list (quote input) (lambda (answer) (unquote cmd)) (unquote type) (lambda () (unquote proposals)) (unquote width)))))
   => ((quote $input$impl) #:synopsis (quote ("Make input field")))
 => cons <> cur-props
   => cur-props => (((quote $input$impl) #:synopsis (quote ("Make input field"))))

(property-set! var prop what conds*)
  <= ($input$impl #:synopsis ("Make input field") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make input toggle") (tm-define-overloaded ($toggle$impl cmd on) (quasiquote (list (quote toggle) (lambda (answer) (unquote cmd)) (lambda () (unquote on))))))
   => ((quote $toggle$impl) #:synopsis (quote ("Make input toggle")))
 => cons <> cur-props
   => cur-props => (((quote $toggle$impl) #:synopsis (quote ("Make input toggle"))))

(property-set! var prop what conds*)
  <= ($toggle$impl #:synopsis ("Make input toggle") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make input enumeration field") (tm-define-overloaded ($enum$impl cmd vals val width) (quasiquote (list (quote enum) (lambda (answer) (unquote cmd)) (lambda () (unquote vals)) (lambda () (unquote val)) (unquote width)))))
   => ((quote $enum$impl) #:synopsis (quote ("Make input enumeration field")))
 => cons <> cur-props
   => cur-props => (((quote $enum$impl) #:synopsis (quote ("Make input enumeration field"))))

(property-set! var prop what conds*)
  <= ($enum$impl #:synopsis ("Make input enumeration field") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make a choice list") (tm-define-overloaded ($choice$impl cmd vals val) (quasiquote (list (quote choice) (lambda (answer) (unquote cmd)) (lambda () (unquote vals)) (lambda () (unquote val))))))
   => ((quote $choice$impl) #:synopsis (quote ("Make a choice list")))
 => cons <> cur-props
   => cur-props => (((quote $choice$impl) #:synopsis (quote ("Make a choice list"))))

(property-set! var prop what conds*)
  <= ($choice$impl #:synopsis ("Make a choice list") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make a multiple choice list") (tm-define-overloaded ($choices$impl cmd vals mc) (quasiquote (list (quote choices) (lambda (answer) (unquote cmd)) (lambda () (unquote vals)) (lambda () (unquote mc))))))
   => ((quote $choices$impl) #:synopsis (quote ("Make a multiple choice list")))
 => cons <> cur-props
   => cur-props => (((quote $choices$impl) #:synopsis (quote ("Make a multiple choice list"))))

(property-set! var prop what conds*)
  <= ($choices$impl #:synopsis ("Make a multiple choice list") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make a scrollable choice list with a filter on top") (tm-define-overloaded ($filtered-choice$impl cmd vals val filterstr) (quasiquote (list (quote filtered-choice) (lambda (answer filter) (unquote cmd)) (lambda () (unquote vals)) (lambda () (unquote val)) (lambda () (unquote filterstr))))))
   => ((quote $filtered-choice$impl) #:synopsis (quote ("Make a scrollable choice list with a filter on top")))
 => cons <> cur-props
   => cur-props => (((quote $filtered-choice$impl) #:synopsis (quote ("Make a scrollable choice list with a filter on top"))))

(property-set! var prop what conds*)
  <= ($filtered-choice$impl #:synopsis ("Make a scrollable choice list with a filter on top") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make a tree view of the data") (tm-define-overloaded ($tree-view$impl cmd data roles) (quasiquote (list (quote tree-view) (lambda x (apply (unquote cmd) (reverse x))) (lambda () (unquote data)) (lambda () (unquote roles))))))
   => ((quote $tree-view$impl) #:synopsis (quote ("Make a tree view of the data")))
 => cons <> cur-props
   => cur-props => (((quote $tree-view$impl) #:synopsis (quote ("Make a tree view of the data"))))

(property-set! var prop what conds*)
  <= ($tree-view$impl #:synopsis ("Make a tree view of the data") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make TeXmacs output field") (tm-define-overloaded ($texmacs-output$impl doc tmstyle) (quasiquote (list (quote texmacs-output) (lambda () (unquote doc)) (lambda () (unquote tmstyle))))))
   => ((quote $texmacs-output$impl) #:synopsis (quote ("Make TeXmacs output field")))
 => cons <> cur-props
   => cur-props => (((quote $texmacs-output$impl) #:synopsis (quote ("Make TeXmacs output field"))))

(property-set! var prop what conds*)
  <= ($texmacs-output$impl #:synopsis ("Make TeXmacs output field") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make TeXmacs input field") (tm-define-overloaded ($texmacs-input$impl doc tmstyle name) (quasiquote (list (quote texmacs-input) (lambda () (unquote doc)) (lambda () (unquote tmstyle)) (lambda () (unquote name))))))
   => ((quote $texmacs-input$impl) #:synopsis (quote ("Make TeXmacs input field")))
 => cons <> cur-props
   => cur-props => (((quote $texmacs-input$impl) #:synopsis (quote ("Make TeXmacs input field"))))

(property-set! var prop what conds*)
  <= ($texmacs-input$impl #:synopsis ("Make TeXmacs input field") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make an ink widget") (tm-define-overloaded ($ink$impl cmd) (quasiquote (list (quote ink) (lambda (answer) (unquote cmd))))))
   => ((quote $ink$impl) #:synopsis (quote ("Make an ink widget")))
 => cons <> cur-props
   => cur-props => (((quote $ink$impl) #:synopsis (quote ("Make an ink widget"))))

(property-set! var prop what conds*)
  <= ($ink$impl #:synopsis ("Make an ink widget") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make form") (tm-define-overloaded ($form$impl name . l) (quasiquote ($let* ((form-name (unquote name)) (form-entries (list)) (form-text-entries (list))) (unquote-splicing l)))))
   => ((quote $form$impl) #:synopsis (quote ("Make form")))
 => cons <> cur-props
   => cur-props => (((quote $form$impl) #:synopsis (quote ("Make form"))))

(property-set! var prop what conds*)
  <= ($form$impl #:synopsis ("Make form") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Inits the value of @field in form @name to the @selected value and returns the list @l unmodified") (tm-define-overloaded (form-proposals-sel name field l selected) (if (nnull? l) (form-named-set name field selected)) l))
   => ((quote form-proposals-sel) #:synopsis (quote ("Inits the value of @field in form @name to the @selected value and returns the list @l unmodified")))
 => cons <> cur-props
   => cur-props => (((quote form-proposals-sel) #:synopsis (quote ("Inits the value of @field in form @name to the @selected value and returns the list @l unmodified"))))

(property-set! var prop what conds*)
  <= (form-proposals-sel #:synopsis ("Inits the value of @field in form @name to the @selected value and returns the list @l unmodified") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make a textual input field for the current form") (tm-define-overloaded ($form-input$impl field type proposals width) (quasiquote ($execute (begin (set! form-entries (append form-entries (list (unquote field)))) (set! form-text-entries (append form-text-entries (list (unquote field))))) ($input (form-named-set form-name (unquote field) answer) (with nr (number->string (length form-text-entries)) (string-append (unquote field) "#form-" form-name "-" nr ":" (unquote type))) (form-proposals form-name (unquote field) (unquote proposals)) (unquote width))))))
   => ((quote $form-input$impl) #:synopsis (quote ("Make a textual input field for the current form")))
 => cons <> cur-props
   => cur-props => (((quote $form-input$impl) #:synopsis (quote ("Make a textual input field for the current form"))))

(property-set! var prop what conds*)
  <= ($form-input$impl #:synopsis ("Make a textual input field for the current form") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make an enumeration field for the current form") (tm-define-overloaded ($form-enum$impl field proposals selected width) (quasiquote ($execute (set! form-entries (append form-entries (list (unquote field)))) ($enum (form-named-set form-name (unquote field) answer) (form-proposals-sel form-name (unquote field) (unquote proposals) (unquote selected)) (unquote selected) (unquote width))))))
   => ((quote $form-enum$impl) #:synopsis (quote ("Make an enumeration field for the current form")))
 => cons <> cur-props
   => cur-props => (((quote $form-enum$impl) #:synopsis (quote ("Make an enumeration field for the current form"))))

(property-set! var prop what conds*)
  <= ($form-enum$impl #:synopsis ("Make an enumeration field for the current form") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make a single choice field for the current form") (tm-define-overloaded ($form-choice$impl field proposals selected) (quasiquote ($execute (set! form-entries (append form-entries (list (unquote field)))) ($choice (form-named-set form-name (unquote field) answer) (form-proposals-sel form-name (unquote field) (unquote proposals) (unquote selected)) (unquote selected))))))
   => ((quote $form-choice$impl) #:synopsis (quote ("Make a single choice field for the current form")))
 => cons <> cur-props
   => cur-props => (((quote $form-choice$impl) #:synopsis (quote ("Make a single choice field for the current form"))))

(property-set! var prop what conds*)
  <= ($form-choice$impl #:synopsis ("Make a single choice field for the current form") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make a multiple choice field for the current form") (tm-define-overloaded ($form-choices$impl field proposals selected) (quasiquote ($execute (set! form-entries (append form-entries (list (unquote field)))) ($choices (form-named-set-multiple form-name (unquote field) answer) (begin (form-named-set-multiple form-name (unquote field) (unquote selected)) (unquote proposals)) (unquote selected))))))
   => ((quote $form-choices$impl) #:synopsis (quote ("Make a multiple choice field for the current form")))
 => cons <> cur-props
   => cur-props => (((quote $form-choices$impl) #:synopsis (quote ("Make a multiple choice field for the current form"))))

(property-set! var prop what conds*)
  <= ($form-choices$impl #:synopsis ("Make a multiple choice field for the current form") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make a toggle field for the current form") (tm-define-overloaded ($form-toggle$impl field on?) (quasiquote ($execute (set! form-entries (append form-entries (list (unquote field)))) ($toggle (form-named-set form-name (unquote field) answer) (unquote on?))))))
   => ((quote $form-toggle$impl) #:synopsis (quote ("Make a toggle field for the current form")))
 => cons <> cur-props
   => cur-props => (((quote $form-toggle$impl) #:synopsis (quote ("Make a toggle field for the current form"))))

(property-set! var prop what conds*)
  <= ($form-toggle$impl #:synopsis ("Make a toggle field for the current form") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Helper routine for kbd-wildcards macro") (tm-define-overloaded (kbd-wildcards-body l) (cond ((null? l) (noop)) ((== (car l) (quote pre)) (kbd-wildcards-sub (cdr l) #f)) ((== (car l) (quote post)) (kbd-wildcards-sub (cdr l) #t)) (else (kbd-wildcards-sub l #t)))))
   => ((quote kbd-wildcards-body) #:synopsis (quote ("Helper routine for kbd-wildcards macro")))
 => cons <> cur-props
   => cur-props => (((quote kbd-wildcards-body) #:synopsis (quote ("Helper routine for kbd-wildcards macro"))))

(property-set! var prop what conds*)
  <= (kbd-wildcards-body #:synopsis ("Helper routine for kbd-wildcards macro") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Add entries in @l to the keyboard wildcard table") (tm-define-overloaded (kbd-wildcards$impl . l) (quasiquote (kbd-wildcards-body (unquote (list (quote quasiquote) l))))))
   => ((quote kbd-wildcards$impl) #:synopsis (quote ("Add entries in @l to the keyboard wildcard table")))
 => cons <> cur-props
   => cur-props => (((quote kbd-wildcards$impl) #:synopsis (quote ("Add entries in @l to the keyboard wildcard table"))))

(property-set! var prop what conds*)
  <= (kbd-wildcards$impl #:synopsis ("Add entries in @l to the keyboard wildcard table") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Find the command associated to the keystroke @key") (tm-define-overloaded (kbd-find-key-binding key) (lazy-keyboard-force) (ctx-resolve (kbd-get-map key) #f)))
   => ((quote kbd-find-key-binding) #:synopsis (quote ("Find the command associated to the keystroke @key")))
 => cons <> cur-props
   => cur-props => (((quote kbd-find-key-binding) #:synopsis (quote ("Find the command associated to the keystroke @key"))))

(property-set! var prop what conds*)
  <= (kbd-find-key-binding #:synopsis ("Find the command associated to the keystroke @key") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Find keyboard binding for command @com") (tm-define-overloaded (kbd-find-inv-binding com) (lazy-keyboard-force) (with r (ctx-resolve (kbd-get-inv com) #f) (if r r ""))))
   => ((quote kbd-find-inv-binding) #:synopsis (quote ("Find keyboard binding for command @com")))
 => cons <> cur-props
   => cur-props => (((quote kbd-find-inv-binding) #:synopsis (quote ("Find keyboard binding for command @com"))))

(property-set! var prop what conds*)
  <= (kbd-find-inv-binding #:synopsis ("Find keyboard binding for command @com") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Find system keyboard binding for command @com") (tm-define-overloaded (kbd-find-inv-system-binding com) (and-with b (tm->stree (kbd-system-rewrite (kbd-find-inv-binding com))) (when (tm-is? b (quote render-key)) (set! b (tm-ref b 0))) (when (tm-is? b (quote with)) (set! b (tm-ref b (- (tm-arity b) 1)))) (and (string? b) b))))
   => ((quote kbd-find-inv-system-binding) #:synopsis (quote ("Find system keyboard binding for command @com")))
 => cons <> cur-props
   => cur-props => (((quote kbd-find-inv-system-binding) #:synopsis (quote ("Find system keyboard binding for command @com"))))

(property-set! var prop what conds*)
  <= (kbd-find-inv-system-binding #:synopsis ("Find system keyboard binding for command @com") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Find modeless keyboard binding for command @cmd") (tm-define-overloaded (kbd-find-rev-binding cmd) (lazy-keyboard-force) (cond ((tree? cmd) (kbd-find-rev-binding (tree->stree cmd))) ((string? cmd) (with l (kbd-get-rev (object->string (string->object cmd))) (and l (nnull? l) (string? (car l)) (string->tmstring (car l))))) (else #f))))
   => ((quote kbd-find-rev-binding) #:synopsis (quote ("Find modeless keyboard binding for command @cmd")))
 => cons <> cur-props
   => cur-props => (((quote kbd-find-rev-binding) #:synopsis (quote ("Find modeless keyboard binding for command @cmd"))))

(property-set! var prop what conds*)
  <= (kbd-find-rev-binding #:synopsis ("Find modeless keyboard binding for command @cmd") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Helper routine for kbd-map macro") (tm-define-overloaded (kbd-binding conds key2 cmd help) (with key (kbd-pre-rewrite key2) (kbd-sub-bindings conds key) (kbd-insert-key-binding conds key (list cmd help)))))
   => ((quote kbd-binding) #:synopsis (quote ("Helper routine for kbd-map macro")))
 => cons <> cur-props
   => cur-props => (((quote kbd-binding) #:synopsis (quote ("Helper routine for kbd-map macro"))))

(property-set! var prop what conds*)
  <= (kbd-binding #:synopsis ("Helper routine for kbd-map macro") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Add entries in @l to the keyboard mapping") (tm-define-overloaded (kbd-map$impl . l) (quasiquote (begin (unquote-splicing (kbd-map-body (quote ()) l))))))
   => ((quote kbd-map$impl) #:synopsis (quote ("Add entries in @l to the keyboard mapping")))
 => cons <> cur-props
   => cur-props => (((quote kbd-map$impl) #:synopsis (quote ("Add entries in @l to the keyboard mapping"))))

(property-set! var prop what conds*)
  <= (kbd-map$impl #:synopsis ("Add entries in @l to the keyboard mapping") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Remove entries in @l from keyboard mapping") (tm-define-overloaded (kbd-unmap$impl . l) (quasiquote (begin (unquote-splicing (kbd-remove-body (quote ()) l))))))
   => ((quote kbd-unmap$impl) #:synopsis (quote ("Remove entries in @l from keyboard mapping")))
 => cons <> cur-props
   => cur-props => (((quote kbd-unmap$impl) #:synopsis (quote ("Remove entries in @l from keyboard mapping"))))

(property-set! var prop what conds*)
  <= (kbd-unmap$impl #:synopsis ("Remove entries in @l from keyboard mapping") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Helper routine for kbd-commands macro") (tm-define-overloaded (kbd-command-pre arg) (with (cmd help . action) arg (list cmd help (list (quote unquote) (quasiquote (lambda () (unquote-splicing action))))))))
   => ((quote kbd-command-pre) #:synopsis (quote ("Helper routine for kbd-commands macro")))
 => cons <> cur-props
   => cur-props => (((quote kbd-command-pre) #:synopsis (quote ("Helper routine for kbd-commands macro"))))

(property-set! var prop what conds*)
  <= (kbd-command-pre #:synopsis ("Helper routine for kbd-commands macro") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Helper routine for kbd-commands macro") (tm-define-overloaded (kbd-command arg) (with (cmd help action) arg (kbd-set-command! cmd (cons help action)))))
   => ((quote kbd-command) #:synopsis (quote ("Helper routine for kbd-commands macro")))
 => cons <> cur-props
   => cur-props => (((quote kbd-command) #:synopsis (quote ("Helper routine for kbd-commands macro"))))

(property-set! var prop what conds*)
  <= (kbd-command #:synopsis ("Helper routine for kbd-commands macro") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Add backslashed commands in @l to keyboard mapping") (tm-define-overloaded (kbd-commands$impl . l) (quasiquote (for-each kbd-command (unquote (list (quote quasiquote) (map kbd-command-pre l)))))))
   => ((quote kbd-commands$impl) #:synopsis (quote ("Add backslashed commands in @l to keyboard mapping")))
 => cons <> cur-props
   => cur-props => (((quote kbd-commands$impl) #:synopsis (quote ("Add backslashed commands in @l to keyboard mapping"))))

(property-set! var prop what conds*)
  <= (kbd-commands$impl #:synopsis ("Add backslashed commands in @l to keyboard mapping") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Add symbols in @l to keyboard mapping") (tm-define-overloaded (kbd-symbols$impl . l) (define (fun s) (list s (string-append "insert#<" s ">") (list (quote kbd-insert) (string-append "<" s ">")))) (quasiquote (kbd-commands (unquote-splicing (map fun l))))))
   => ((quote kbd-symbols$impl) #:synopsis (quote ("Add symbols in @l to keyboard mapping")))
 => cons <> cur-props
   => cur-props => (((quote kbd-symbols$impl) #:synopsis (quote ("Add symbols in @l to keyboard mapping"))))

(property-set! var prop what conds*)
  <= (kbd-symbols$impl #:synopsis ("Add symbols in @l to keyboard mapping") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Expand links and conditional menus in menu @p.") (tm-define-overloaded (menu-expand p) (cond ((npair? p) (replace-procedures p)) ((string? (car p)) p) ((symbol? (car p)) (with result (ahash-ref menu-expand-table (car p)) (if result ((car result) p) p))) ((match? (car p) (quote (check #:menu-wide-label #:string? #:%1))) (with a (cdar p) (list (list (quote check) (menu-expand (car a)) (cadr a) ((caddr a))) (replace-procedures (cadr p))))) ((match? (car p) (quote #:menu-wide-label)) (replace-procedures p)) (else (menu-expand-list p)))))
   => ((quote menu-expand) #:synopsis (quote ("Expand links and conditional menus in menu @p.")))
 => cons <> cur-props
   => cur-props => (((quote menu-expand) #:synopsis (quote ("Expand links and conditional menus in menu @p."))))

  ((define-property which)  opt decl)
    <= ((#:type)  ((-> object object)) (tm-define-overloaded (menu-expand p) (cond ((npair? p) (replace-procedures p)) ((string? (car p)) p) ((symbol? (car p)) (with result (ahash-ref menu-expand-table (car p)) (if result ((car result) p) p))) ((match? (car p) (quote (check #:menu-wide-label #:string? #:%1))) (with a (cdar p) (list (list (quote check) (menu-expand (car a)) (cadr a) ((caddr a))) (replace-procedures (cadr p))))) ((match? (car p) (quote #:menu-wide-label)) (replace-procedures p)) (else (menu-expand-list p)))))
   => ((quote menu-expand) #:type (quote ((-> object object))))
 => cons <> cur-props
   => cur-props => (((quote menu-expand) #:type (quote ((-> object object)))) ((quote menu-expand) #:synopsis (quote ("Expand links and conditional menus in menu @p."))))

(property-set! var prop what conds*)
  <= (menu-expand #:type ((-> object object)) ())

(property-set! var prop what conds*)
  <= (menu-expand #:synopsis ("Expand links and conditional menus in menu @p.") ())

  (define-option-argument opt decl)
    <= ((style "menu style") (tm-define-overloaded (make-menu-widget p style) ((wrap-catch make-menu-main) p style)))
    => cons <> cur-props <= ((quote make-menu-widget) #:arguments (quote (p style)))
    => cons <> cur-props <= ((quote make-menu-widget) (quote (#:argument style)) (quote ("menu style")))
    => cur-props => (((quote make-menu-widget) (quote (#:argument style)) (quote ("menu style"))) ((quote make-menu-widget) #:arguments (quote (p style))))

  (define-option-argument opt decl)
    <= ((p "a scheme object which represents the menu") (tm-define-overloaded (make-menu-widget p style) ((wrap-catch make-menu-main) p style)))
    => cons <> cur-props <= ((quote make-menu-widget) #:arguments (quote (p style)))
    => cons <> cur-props <= ((quote make-menu-widget) (quote (#:argument p)) (quote ("a scheme object which represents the menu")))
    => cur-props => (((quote make-menu-widget) (quote (#:argument p)) (quote ("a scheme object which represents the menu"))) ((quote make-menu-widget) #:arguments (quote (p style))) ((quote make-menu-widget) (quote (#:argument style)) (quote ("menu style"))) ((quote make-menu-widget) #:arguments (quote (p style))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Transform a menu into a widget.") (tm-define-overloaded (make-menu-widget p style) ((wrap-catch make-menu-main) p style)))
   => ((quote make-menu-widget) #:synopsis (quote ("Transform a menu into a widget.")))
 => cons <> cur-props
   => cur-props => (((quote make-menu-widget) #:synopsis (quote ("Transform a menu into a widget."))) ((quote make-menu-widget) (quote (#:argument p)) (quote ("a scheme object which represents the menu"))) ((quote make-menu-widget) #:arguments (quote (p style))) ((quote make-menu-widget) (quote (#:argument style)) (quote ("menu style"))) ((quote make-menu-widget) #:arguments (quote (p style))))

(property-set! var prop what conds*)
  <= (make-menu-widget #:synopsis ("Transform a menu into a widget.") ())

(property-set! var prop what conds*)
  <= (make-menu-widget (#:argument p) ("a scheme object which represents the menu") ())

(property-set! var prop what conds*)
  <= (make-menu-widget #:arguments (p style) ())

(property-set! var prop what conds*)
  <= (make-menu-widget (#:argument style) ("menu style") ())

(property-set! var prop what conds*)
  <= (make-menu-widget #:arguments (p style) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (top-window menu-promise name . opts) (with (bufs qqq) (decode-options opts) (let* ((win (alt-window-handle)) (del (make-window-deleter win bufs)) (qui (object->command (lambda () (qqq) (del)))) (men (menu-promise)) (scm (list (quote vertical) men)) (wid (make-menu-widget scm 0))) (alt-window-create-quit win wid name qui) (alt-window-show win)))))
    => ((quote top-window) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote top-window) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (top-window #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (dialogue-window menu-promise cmd name . opts) (with (bufs qqq) (decode-options opts) (let* ((win (alt-window-handle)) (del (make-window-deleter win bufs)) (qui (object->command (lambda () (qqq) (del)))) (lbd (lambda x (apply cmd x) (del))) (men (menu-promise lbd)) (scm (list (quote vertical) men)) (wid (make-menu-widget scm 0))) (alt-window-create-quit win wid name qui) (alt-window-show win)))))
    => ((quote dialogue-window) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote dialogue-window) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (dialogue-window #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (interactive-window wid-promise cmd name) (let* ((win (alt-window-handle)) (lbd (lambda x (apply cmd x) (alt-window-delete win))) (com (object->command (menu-protect lbd))) (wid (wid-promise com))) (alt-window-create win wid name #t) (alt-window-show win))))
    => ((quote interactive-window) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote interactive-window) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (interactive-window #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (interactive-print done u) (with p (lambda (com) (widget-printer com u)) (interactive-window p done "Print document"))))
    => ((quote interactive-print) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote interactive-print) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (interactive-print #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (interactive-rgb-picker cmd l) (with cmd* (lambda (col) (when col (cmd col))) (dialogue-window rgb-color-picker cmd* "Choose color"))))
    => ((quote interactive-rgb-picker) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote interactive-rgb-picker) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (interactive-rgb-picker #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (interactive-color cmd proposals) (if (not (qt-gui?)) (interactive-rgb-picker cmd proposals) (with p (lambda (com) (widget-color-picker com #f proposals)) (with cmd* (lambda (t) (when t (cmd (tm->stree t)))) (interactive-window p cmd* "Choose color"))))))
    => ((quote interactive-color) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote interactive-color) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (interactive-color #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (interactive-background cmd proposals) (if (not (qt-gui?)) (interactive-rgb-picker cmd proposals) (with p (lambda (com) (widget-color-picker com #f proposals)) (with cmd* (lambda (t) (when t (cmd (tm->stree t)))) (interactive-window p cmd* "Choose background"))))))
    => ((quote interactive-background) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote interactive-background) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (interactive-background #:interactive (#t) ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Display command @cmd with its standard outputs @out and @err") (tm-define-overloaded (report-system-error win-name cmd out err) (when (list? cmd) (set! cmd (string-recompose cmd " "))) (set! out (utf8->cork out)) (set! err (utf8->cork err)) (dialogue-window (system-error-widget cmd out err) noop win-name) #f))
   => ((quote report-system-error) #:synopsis (quote ("Display command @cmd with its standard outputs @out and @err")))
 => cons <> cur-props
   => cur-props => (((quote report-system-error) #:synopsis (quote ("Display command @cmd with its standard outputs @out and @err"))))

(property-set! var prop what conds*)
  <= (report-system-error #:synopsis ("Display command @cmd with its standard outputs @out and @err") ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (show-message msg title) (dialogue-window (message-widget msg) noop title)))
    => ((quote show-message) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote show-message) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (show-message #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (widget-call-back handle) (and-with fun (ahash-ref widget-call-back-table handle) (fun))))
    => ((quote widget-call-back) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote widget-call-back) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (widget-call-back #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (widget-with$impl prefix . body) (quasiquote (let ((new-prefix (unquote prefix)) (old-prefix widget-prefix)) (set! widget-prefix new-prefix) (let ((result (begin (unquote-splicing body)))) (set! widget-prefix old-prefix) result)))))
    => ((quote widget-with$impl) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote widget-with$impl) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (widget-with$impl #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (widget-delay$impl . body) (quasiquote (delayed (#:idle 1) (unquote-splicing body)))))
    => ((quote widget-delay$impl) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote widget-delay$impl) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (widget-delay$impl #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (widget-ref handle . opt-prefix) (if (tree? handle) (set! handle (tree->string handle))) (let* ((prefix (widget-get-prefix opt-prefix)) (l (id->trees (string-append prefix handle)))) (and l (nnull? l) (car l)))))
    => ((quote widget-ref) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote widget-ref) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (widget-ref #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (widget-set! handle new-tree . opt-prefix) (if (tree? handle) (set! handle (tree->string handle))) (and-with old-tree (apply widget-ref (cons handle opt-prefix)) (tree-set! old-tree (tree-copy (tm->tree new-tree))))))
    => ((quote widget-set!) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote widget-set!) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (widget-set! #:secure (#t) ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Generate a content builder from a scheme program @w") (tm-define-overloaded (build-content w) (cond ((list? w) (with (options . body) (build-options w) (with l (cons (car w) body) (build-with options (quasiquote (list (unquote (build-content-list l)))))))) ((== w (quote ---)) (quasiquote (list (quote (gui-hrule))))) ((== w (quote ===)) (quasiquote (list (quote (gui-medskip))))) ((== w (quote >>>)) (quasiquote (list (quote (htab "1em"))))) ((symbol? w) (quasiquote (list (quote (unquote w))))) (else (quasiquote (list (unquote w)))))))
   => ((quote build-content) #:synopsis (quote ("Generate a content builder from a scheme program @w")))
 => cons <> cur-props
   => cur-props => (((quote build-content) #:synopsis (quote ("Generate a content builder from a scheme program @w"))))

(property-set! var prop what conds*)
  <= (build-content #:synopsis ("Generate a content builder from a scheme program @w") ())

  (define-option-require opt decl)
    <= (((tm-is? w (quote sequence))) (tm-define-overloaded (build-content w) (with (options . body) (build-options w) (build-with options (begin (build-content-list body))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote sequence))) (tm-define-overloaded (build-content w) (with (options . body) (build-options w) (build-with options (begin (build-content-list body))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote let))) (tm-define-overloaded (build-content w) (with (options bindings . body) (build-options w) (build-with options (begin (quasiquote (let* (unquote bindings) (unquote (build-content-list body)))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote let))) (tm-define-overloaded (build-content w) (with (options bindings . body) (build-options w) (build-with options (begin (quasiquote (let* (unquote bindings) (unquote (build-content-list body)))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote quote))) (tm-define-overloaded (build-content w) (with (options x) (build-options w) (build-with options (begin (quasiquote (list (quote (unquote x)))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote quote))) (tm-define-overloaded (build-content w) (with (options x) (build-options w) (build-with options (begin (quasiquote (list (quote (unquote x)))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote with))) (tm-define-overloaded (build-content w) (with (options . body) (build-options w) (build-with options (begin (let* ((bindings (with-bindings options)) (fun (lambda (x) (quasiquote (with (unquote-splicing bindings) (unquote x))))) (builder (build-content-list body))) (quasiquote (map (unquote fun) (unquote builder)))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote with))) (tm-define-overloaded (build-content w) (with (options . body) (build-options w) (build-with options (begin (let* ((bindings (with-bindings options)) (fun (lambda (x) (quasiquote (with (unquote-splicing bindings) (unquote x))))) (builder (build-content-list body))) (quasiquote (map (unquote fun) (unquote builder)))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote concat))) (tm-define-overloaded (build-content w) (with (options . body) (build-options w) (build-with options (begin (quasiquote (list (concat (unquote (build-content-list body))))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote concat))) (tm-define-overloaded (build-content w) (with (options . body) (build-options w) (build-with options (begin (quasiquote (list (concat (unquote (build-content-list body))))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote document))) (tm-define-overloaded (build-content w) (with (options . body) (build-options w) (build-with options (begin (quasiquote (list (document (unquote (build-content-list body))))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote document))) (tm-define-overloaded (build-content w) (with (options . body) (build-options w) (build-with options (begin (quasiquote (list (document (unquote (build-content-list body))))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote command))) (tm-define-overloaded (build-content w) (with (options . cmds) (build-options w) (build-with options (begin (quasiquote (list (widget-new-call-back (lambda () (unquote-splicing cmds))))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote command))) (tm-define-overloaded (build-content w) (with (options . cmds) (build-options w) (build-with options (begin (quasiquote (list (widget-new-call-back (lambda () (unquote-splicing cmds))))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote instruct))) (tm-define-overloaded (build-content w) (with (options . cmds) (build-options w) (build-with options (begin (quasiquote (begin (unquote-splicing cmds) (quote ()))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote instruct))) (tm-define-overloaded (build-content w) (with (options . cmds) (build-options w) (build-with options (begin (quasiquote (begin (unquote-splicing cmds) (quote ()))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote entry))) (tm-define-overloaded (build-content w) (with (options name val type) (build-options w) (build-with options (begin (quasiquote (list (unquote (widget-entry name val type)))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote entry))) (tm-define-overloaded (build-content w) (with (options name val type) (build-options w) (build-with options (begin (quasiquote (list (unquote (widget-entry name val type)))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote internal))) (tm-define-overloaded (build-content w) (with (options var val) (build-options w) (build-with options (build-content (begin (quasiquote (instruct (widget-internal-set! aux-handle (unquote var) (unquote val))))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote internal))) (tm-define-overloaded (build-content w) (with (options var val) (build-options w) (build-with options (build-content (begin (quasiquote (instruct (widget-internal-set! aux-handle (unquote var) (unquote val))))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote short-input))) (tm-define-overloaded (build-content w) (with (options name val) (build-options w) (build-with options (build-content (begin (quasiquote ((quote short-input) (unquote name) (entry (unquote name) (unquote val) "content")))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote short-input))) (tm-define-overloaded (build-content w) (with (options name val) (build-options w) (build-with options (build-content (begin (quasiquote ((quote short-input) (unquote name) (entry (unquote name) (unquote val) "content")))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote input))) (tm-define-overloaded (build-content w) (with (options name val) (build-options w) (build-with options (build-content (begin (quasiquote ((quote wide-input) (unquote name) "0%" (entry (unquote name) (unquote val) "content")))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote input))) (tm-define-overloaded (build-content w) (with (options name val) (build-options w) (build-with options (build-content (begin (quasiquote ((quote wide-input) (unquote name) "0%" (entry (unquote name) (unquote val) "content")))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote block-input))) (tm-define-overloaded (build-content w) (with (options name val) (build-options w) (build-with options (build-content (begin (quasiquote ((quote block-input) (unquote name) (entry (unquote name) (unquote val) "content")))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote block-input))) (tm-define-overloaded (build-content w) (with (options name val) (build-options w) (build-with options (build-content (begin (quasiquote ((quote block-input) (unquote name) (entry (unquote name) (unquote val) "content")))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote canvas-input))) (tm-define-overloaded (build-content w) (with (options name y1 y2 val) (build-options w) (build-with options (build-content (begin (quasiquote ((quote canvas-input) (unquote name) (unquote y1) (unquote y2) "0%" "0%" (entry (unquote name) (unquote val) "content")))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote canvas-input))) (tm-define-overloaded (build-content w) (with (options name y1 y2 val) (build-options w) (build-with options (build-content (begin (quasiquote ((quote canvas-input) (unquote name) (unquote y1) (unquote y2) "0%" "0%" (entry (unquote name) (unquote val) "content")))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote hidden-input))) (tm-define-overloaded (build-content w) (with (options name val . body) (build-options w) (build-with options (build-content (begin (quasiquote ((quote hidden-input) (unquote name) (entry (unquote name) (unquote val) "string") (document (unquote-splicing body))))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote hidden-input))) (tm-define-overloaded (build-content w) (with (options name val . body) (build-options w) (build-with options (build-content (begin (quasiquote ((quote hidden-input) (unquote name) (entry (unquote name) (unquote val) "string") (document (unquote-splicing body))))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote button))) (tm-define-overloaded (build-content w) (with (options body . cmds) (build-options w) (build-with options (build-content (begin (quasiquote ((quote button) (concat (unquote body)) (command (unquote-splicing cmds))))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote button))) (tm-define-overloaded (build-content w) (with (options body . cmds) (build-options w) (build-with options (build-content (begin (quasiquote ((quote button) (concat (unquote body)) (command (unquote-splicing cmds))))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote toggle))) (tm-define-overloaded (build-content w) (with (options name val) (build-options w) (build-with options (build-content (begin (quasiquote ((quote toggle-box) (unquote name) (entry (unquote name) (unquote val) "boolean")))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote toggle))) (tm-define-overloaded (build-content w) (with (options name val) (build-options w) (build-with options (build-content (begin (quasiquote ((quote toggle-box) (unquote name) (entry (unquote name) (unquote val) "boolean")))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote toggle-button))) (tm-define-overloaded (build-content w) (with (options name val . body) (build-options w) (build-with options (build-content (begin (quasiquote ((quote toggle-button) (unquote name) (entry (unquote name) (unquote val) "boolean") (concat (unquote-splicing body))))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote toggle-button))) (tm-define-overloaded (build-content w) (with (options name val . body) (build-options w) (build-with options (build-content (begin (quasiquote ((quote toggle-button) (unquote name) (entry (unquote name) (unquote val) "boolean") (concat (unquote-splicing body))))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote radio))) (tm-define-overloaded (build-content w) (with (options name val) (build-options w) (build-with options (build-content (begin (quasiquote ((quote radio-box) (unquote name) (unquote val)))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote radio))) (tm-define-overloaded (build-content w) (with (options name val) (build-options w) (build-with options (build-content (begin (quasiquote ((quote radio-box) (unquote name) (unquote val)))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote radio-button))) (tm-define-overloaded (build-content w) (with (options name val . body) (build-options w) (build-with options (build-content (begin (quasiquote ((quote radio-button) (unquote name) (unquote val) (concat (unquote-splicing body))))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote radio-button))) (tm-define-overloaded (build-content w) (with (options name val . body) (build-options w) (build-with options (build-content (begin (quasiquote ((quote radio-button) (unquote name) (unquote val) (concat (unquote-splicing body))))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote header-bar))) (tm-define-overloaded (build-content w) (with (options . body) (build-options w) (build-with options (build-content (begin (quasiquote ((quote header-bar) (concat (unquote-splicing body))))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote header-bar))) (tm-define-overloaded (build-content w) (with (options . body) (build-options w) (build-with options (build-content (begin (quasiquote ((quote header-bar) (concat (unquote-splicing body))))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote pagelet))) (tm-define-overloaded (build-content w) (with (options name val . body) (build-options w) (build-with options (build-content (begin (quasiquote ((quote pagelet) (unquote name) (unquote val) (document (unquote-splicing body))))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote pagelet))) (tm-define-overloaded (build-content w) (with (options name val . body) (build-options w) (build-with options (build-content (begin (quasiquote ((quote pagelet) (unquote name) (unquote val) (document (unquote-splicing body))))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote cell))) (tm-define-overloaded (build-content w) (with (options . body) (build-options w) (build-with options (build-content (begin (cond ((== body (quote (>>>))) (quasiquote (gui-tab))) (else (quasiquote ((quote cell) (concat (unquote-splicing body))))))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote cell))) (tm-define-overloaded (build-content w) (with (options . body) (build-options w) (build-with options (build-content (begin (cond ((== body (quote (>>>))) (quasiquote (gui-tab))) (else (quasiquote ((quote cell) (concat (unquote-splicing body))))))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote row))) (tm-define-overloaded (build-content w) (with (options . body) (build-options w) (build-with options (build-content (begin (let* ((make-cell (lambda (x) (if (func? x (quote cell)) x (quasiquote (cell (unquote x)))))) (body* (map make-cell body))) (quasiquote ((quote row) (unquote-splicing body*))))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote row))) (tm-define-overloaded (build-content w) (with (options . body) (build-options w) (build-with options (build-content (begin (let* ((make-cell (lambda (x) (if (func? x (quote cell)) x (quasiquote (cell (unquote x)))))) (body* (map make-cell body))) (quasiquote ((quote row) (unquote-splicing body*))))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote table))) (tm-define-overloaded (build-content w) (with (options . body) (build-options w) (build-with options (build-content (begin (let* ((make-row (lambda (x) (if (func? x (quote row)) x (quasiquote (row (unquote-splicing x)))))) (body* (map make-row body))) (quasiquote ((quote table) (unquote-splicing body*))))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote table))) (tm-define-overloaded (build-content w) (with (options . body) (build-options w) (build-with options (build-content (begin (let* ((make-row (lambda (x) (if (func? x (quote row)) x (quasiquote (row (unquote-splicing x)))))) (body* (map make-row body))) (quasiquote ((quote table) (unquote-splicing body*))))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote dense-tile))) (tm-define-overloaded (build-content w) (with (options . rows) (build-options w) (build-with options (build-content (begin (tm-build-table dense-tile rows)))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote dense-tile))) (tm-define-overloaded (build-content w) (with (options . rows) (build-options w) (build-with options (build-content (begin (tm-build-table dense-tile rows)))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote short-tile))) (tm-define-overloaded (build-content w) (with (options . rows) (build-options w) (build-with options (build-content (begin (tm-build-table short-tile rows)))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote short-tile))) (tm-define-overloaded (build-content w) (with (options . rows) (build-options w) (build-with options (build-content (begin (tm-build-table short-tile rows)))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote association-tile))) (tm-define-overloaded (build-content w) (with (options . rows) (build-options w) (build-with options (build-content (begin (tm-build-table association-tile rows)))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote association-tile))) (tm-define-overloaded (build-content w) (with (options . rows) (build-options w) (build-with options (build-content (begin (tm-build-table association-tile rows)))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote tile))) (tm-define-overloaded (build-content w) (with (options . rows) (build-options w) (build-with options (build-content (begin (tm-build-table wide-tile rows)))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote tile))) (tm-define-overloaded (build-content w) (with (options . rows) (build-options w) (build-with options (build-content (begin (tm-build-table wide-tile rows)))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote dense-bar))) (tm-define-overloaded (build-content w) (with (options . cells) (build-options w) (build-with options (build-content (begin (tm-build-table dense-tile (list cells))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote dense-bar))) (tm-define-overloaded (build-content w) (with (options . cells) (build-options w) (build-with options (build-content (begin (tm-build-table dense-tile (list cells))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote short-bar))) (tm-define-overloaded (build-content w) (with (options . cells) (build-options w) (build-with options (build-content (begin (tm-build-table short-tile (list cells))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote short-bar))) (tm-define-overloaded (build-content w) (with (options . cells) (build-options w) (build-with options (build-content (begin (tm-build-table short-tile (list cells))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote bar))) (tm-define-overloaded (build-content w) (with (options . cells) (build-options w) (build-with options (build-content (begin (tm-build-table wide-tile (list cells))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote bar))) (tm-define-overloaded (build-content w) (with (options . cells) (build-options w) (build-with options (build-content (begin (tm-build-table wide-tile (list cells))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote form))) (tm-define-overloaded (build-content w) (with (options proto . body) (build-options w) (build-with options (begin (with (name . vars) proto (with f (lambda (x) (if (string? x) (cons x #f) (cons (car x) (cadr x)))) (set! vars (map f vars))) (quasiquote (let* ((form-name (unquote name)) (form-vars (map car (quote (unquote vars)))) (form-type (quote (unquote vars))) (form-types (map cdr form-type)) (form-suggest (quote ())) (form-memo (form-load form-name form-vars)) (form-position (map (cut cons <> 0) form-vars))) (letrec ((form-auto (lambda (var type) (form-get-proposal var type 0 form-memo form-suggest))) (form-field-values (lambda () (map widget-ref form-vars))) (form-return-values (lambda () (map form->type (form-field-values) form-types))) (form-ok? (lambda () (== (form-field-values) (map type->form (form-return-values) form-types)))) (form-memorize (lambda () (form-save form-name form-vars (form-field-values))))) (unquote (build-content-list body)))))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote form))) (tm-define-overloaded (build-content w) (with (options proto . body) (build-options w) (build-with options (begin (with (name . vars) proto (with f (lambda (x) (if (string? x) (cons x #f) (cons (car x) (cadr x)))) (set! vars (map f vars))) (quasiquote (let* ((form-name (unquote name)) (form-vars (map car (quote (unquote vars)))) (form-type (quote (unquote vars))) (form-types (map cdr form-type)) (form-suggest (quote ())) (form-memo (form-load form-name form-vars)) (form-position (map (cut cons <> 0) form-vars))) (letrec ((form-auto (lambda (var type) (form-get-proposal var type 0 form-memo form-suggest))) (form-field-values (lambda () (map widget-ref form-vars))) (form-return-values (lambda () (map form->type (form-field-values) form-types))) (form-ok? (lambda () (== (form-field-values) (map type->form (form-return-values) form-types)))) (form-memorize (lambda () (form-save form-name form-vars (form-field-values))))) (unquote (build-content-list body)))))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote suggestions))) (tm-define-overloaded (build-content w) (with (options var l) (build-options w) (build-with options (begin (quasiquote (begin (set! form-suggest (assoc-set! form-suggest (unquote var) (unquote l))) (quote ()))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote suggestions))) (tm-define-overloaded (build-content w) (with (options var l) (build-options w) (build-with options (begin (quasiquote (begin (set! form-suggest (assoc-set! form-suggest (unquote var) (unquote l))) (quote ()))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote form-previous))) (tm-define-overloaded (build-content w) (with (options) (build-options w) (build-with options (build-content (begin (quasiquote (button "<less>" (set! form-position (form-equalize form-position)) (let* ((start (- (if (null? form-suggest) 1 0) (length form-memo))) (lengths (map length (map cdr form-suggest))) (end (if (null? lengths) 0 (max 0 (- (apply max lengths) 1))))) (set! form-position (form-increment form-position -1 start end))) (for-each (cut form-fill-out <> <> <> form-memo form-suggest) form-vars (map cdr form-type) (map cdr form-position))))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote form-previous))) (tm-define-overloaded (build-content w) (with (options) (build-options w) (build-with options (build-content (begin (quasiquote (button "<less>" (set! form-position (form-equalize form-position)) (let* ((start (- (if (null? form-suggest) 1 0) (length form-memo))) (lengths (map length (map cdr form-suggest))) (end (if (null? lengths) 0 (max 0 (- (apply max lengths) 1))))) (set! form-position (form-increment form-position -1 start end))) (for-each (cut form-fill-out <> <> <> form-memo form-suggest) form-vars (map cdr form-type) (map cdr form-position))))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote form-next))) (tm-define-overloaded (build-content w) (with (options) (build-options w) (build-with options (build-content (begin (quasiquote (button "<gtr>" (set! form-position (form-equalize form-position)) (let* ((start (- (if (null? form-suggest) 1 0) (length form-memo))) (lengths (map length (map cdr form-suggest))) (end (if (null? lengths) 0 (max 0 (- (apply max lengths) 1))))) (set! form-position (form-increment form-position 1 start end))) (for-each (cut form-fill-out <> <> <> form-memo form-suggest) form-vars (map cdr form-type) (map cdr form-position))))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote form-next))) (tm-define-overloaded (build-content w) (with (options) (build-options w) (build-with options (build-content (begin (quasiquote (button "<gtr>" (set! form-position (form-equalize form-position)) (let* ((start (- (if (null? form-suggest) 1 0) (length form-memo))) (lengths (map length (map cdr form-suggest))) (end (if (null? lengths) 0 (max 0 (- (apply max lengths) 1))))) (set! form-position (form-increment form-position 1 start end))) (for-each (cut form-fill-out <> <> <> form-memo form-suggest) form-vars (map cdr form-type) (map cdr form-position))))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote form-cancel))) (tm-define-overloaded (build-content w) (with (options) (build-options w) (build-with options (build-content (begin (quasiquote (button "Cancel" (dismiss)))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote form-cancel))) (tm-define-overloaded (build-content w) (with (options) (build-options w) (build-with options (build-content (begin (quasiquote (button "Cancel" (dismiss)))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote form-done))) (tm-define-overloaded (build-content w) (with (options body fun) (build-options w) (build-with options (build-content (begin (quasiquote (button (unquote body) (when (form-ok?) (with args (form-return-values) (form-memorize) (dismiss) (delayed (#:idle 1) (apply (unquote fun) args))))))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote form-done))) (tm-define-overloaded (build-content w) (with (options body fun) (build-options w) (build-with options (build-content (begin (quasiquote (button (unquote body) (when (form-ok?) (with args (form-return-values) (form-memorize) (dismiss) (delayed (#:idle 1) (apply (unquote fun) args))))))))))))

  (define-option-proposals opt decl)
    <= ((num (quote ("1" "x" "a+b"))) (tm-define-overloaded (make-test num den) (insert (quasiquote (frac (unquote num) (unquote den))))))
    => cons <> cur-props <= ((quote make-test) (quote (#:proposals num)) (lambda () (quote ("1" "x" "a+b"))))
    => cur-props => (((quote make-test) (quote (#:proposals num)) (lambda () (quote ("1" "x" "a+b")))))

  (define-option-argument opt decl)
    <= ((den "content" "Denominator") (tm-define-overloaded (make-test num den) (insert (quasiquote (frac (unquote num) (unquote den))))))
    => cons <> cur-props <= ((quote make-test) #:arguments (quote (num den)))
    => cons <> cur-props <= ((quote make-test) (quote (#:argument den)) (quote ("content" "Denominator")))
    => cur-props => (((quote make-test) (quote (#:argument den)) (quote ("content" "Denominator"))) ((quote make-test) #:arguments (quote (num den))) ((quote make-test) (quote (#:proposals num)) (lambda () (quote ("1" "x" "a+b")))))

  (define-option-argument opt decl)
    <= ((num "content" "Numerator") (tm-define-overloaded (make-test num den) (insert (quasiquote (frac (unquote num) (unquote den))))))
    => cons <> cur-props <= ((quote make-test) #:arguments (quote (num den)))
    => cons <> cur-props <= ((quote make-test) (quote (#:argument num)) (quote ("content" "Numerator")))
    => cur-props => (((quote make-test) (quote (#:argument num)) (quote ("content" "Numerator"))) ((quote make-test) #:arguments (quote (num den))) ((quote make-test) (quote (#:argument den)) (quote ("content" "Denominator"))) ((quote make-test) #:arguments (quote (num den))) ((quote make-test) (quote (#:proposals num)) (lambda () (quote ("1" "x" "a+b")))))

(property-set! var prop what conds*)
  <= (make-test (#:argument num) ("content" "Numerator") ())

(property-set! var prop what conds*)
  <= (make-test #:arguments (num den) ())

(property-set! var prop what conds*)
  <= (make-test (#:argument den) ("content" "Denominator") ())

(property-set! var prop what conds*)
  <= (make-test #:arguments (num den) ())

(property-set! var prop what conds*)
  <= (make-test (#:proposals num) #<procedure #f ()> ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Standard form for a simple function application") (tm-define-overloaded (interactive-form fun prompts vars types defaults) (with name (or (procedure-string-name fun) "Enter function arguments") (quasiquote (form ((unquote name) (unquote-splicing (map list vars types))) (unquote-splicing (list-filter (map interactive-proposals vars defaults) identity)) (unquote (interactive-fields prompts vars types)) === (bar (form-previous) (form-next) >>> (form-cancel) (form-done "Ok" (unquote fun))))))))
   => ((quote interactive-form) #:synopsis (quote ("Standard form for a simple function application")))
 => cons <> cur-props
   => cur-props => (((quote interactive-form) #:synopsis (quote ("Standard form for a simple function application"))))

(property-set! var prop what conds*)
  <= (interactive-form #:synopsis ("Standard form for a simple function application") ())

  (define-option-require opt decl)
    <= (((tm-is? w (quote widget-1))) (tm-define-overloaded (build-content w) (with (options) (build-options w) (build-with options (build-content-list (quasiquote ("Hallo, hier komt een lange regel met tekst." (concat "Links" >>> "Rechts"))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote widget-1))) (tm-define-overloaded (build-content w) (with (options) (build-options w) (build-with options (build-content-list (quasiquote ("Hallo, hier komt een lange regel met tekst." (concat "Links" >>> "Rechts"))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote widget-2))) (tm-define-overloaded (build-content w) (with (options) (build-options w) (build-with options (build-content-list (quasiquote ((concat "a+" (frac "1" "2")))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote widget-2))) (tm-define-overloaded (build-content w) (with (options) (build-options w) (build-with options (build-content-list (quasiquote ((concat "a+" (frac "1" "2")))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote widget-3))) (tm-define-overloaded (build-content w) (with (options given) (build-options w) (build-with options (build-content-list (quasiquote ((center (concat (strong "Different types of data") (vspace "0.5em"))) (let ((hidden "Secret text")) (internal "internal" (+ 1 1)) (input "visible" "") === (with (#:button-shape "invisible") (bar (button "Parameter" (display* (unquote given) "
")) (button "Hidden" (display* hidden "
")) (button "Internal" (display* (internal-ref "internal") "
")) (button "Visible" (display* (widget-ref "visible") "
")) >>> (button "Done" (dismiss))))))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote widget-3))) (tm-define-overloaded (build-content w) (with (options given) (build-options w) (build-with options (build-content-list (quasiquote ((center (concat (strong "Different types of data") (vspace "0.5em"))) (let ((hidden "Secret text")) (internal "internal" (+ 1 1)) (input "visible" "") === (with (#:button-shape "invisible") (bar (button "Parameter" (display* (unquote given) "
")) (button "Hidden" (display* hidden "
")) (button "Internal" (display* (internal-ref "internal") "
")) (button "Visible" (display* (widget-ref "visible") "
")) >>> (button "Done" (dismiss))))))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote widget-4))) (tm-define-overloaded (build-content w) (with (options) (build-options w) (build-with options (build-content-list (quasiquote ((short-bar (toggle "pressed?" #f) (toggle (#:box-shape "square") "second?" #f) (toggle-button "third?" #f "Toggle")) (hidden-input "color" "red" (short-bar "Green" (radio (#:box-color "pastel green") "color" "green") "Red" (radio (#:box-color "pastel red") "color" "red") "Blue" (radio (#:box-color "pastel blue") "color" "blue"))) (short-bar (button "Toggles" (display* (widget-ref "pressed?") ", " (widget-ref "second?") ", " (widget-ref "third?") "
")) (button "Radio buttons" (display* (widget-ref "color") "
")) (button "Done" (dismiss))))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote widget-4))) (tm-define-overloaded (build-content w) (with (options) (build-options w) (build-with options (build-content-list (quasiquote ((short-bar (toggle "pressed?" #f) (toggle (#:box-shape "square") "second?" #f) (toggle-button "third?" #f "Toggle")) (hidden-input "color" "red" (short-bar "Green" (radio (#:box-color "pastel green") "color" "green") "Red" (radio (#:box-color "pastel red") "color" "red") "Blue" (radio (#:box-color "pastel blue") "color" "blue"))) (short-bar (button "Toggles" (display* (widget-ref "pressed?") ", " (widget-ref "second?") ", " (widget-ref "third?") "
")) (button "Radio buttons" (display* (widget-ref "color") "
")) (button "Done" (dismiss))))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote widget-5))) (tm-define-overloaded (build-content w) (with (options) (build-options w) (build-with options (build-content-list (quasiquote ((association-tile (#:font-shape "italic") ("From:" (input "First" "")) ("To:" (input "Second" ""))) === (bar (button "Copy" (widget-set! "Second" (widget-ref "First"))) (button "Clear" (widget-set! "Second" "")) >>> (button "Done" (dismiss))))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote widget-5))) (tm-define-overloaded (build-content w) (with (options) (build-options w) (build-with options (build-content-list (quasiquote ((association-tile (#:font-shape "italic") ("From:" (input "First" "")) ("To:" (input "Second" ""))) === (bar (button "Copy" (widget-set! "Second" (widget-ref "First"))) (button "Clear" (widget-set! "Second" "")) >>> (button "Done" (dismiss))))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote widget-6))) (tm-define-overloaded (build-content w) (with (options) (build-options w) (build-with options (build-content-list (quasiquote ((let ((nr 0) (busy #f) (sync (lambda () (widget-set! "Output" (tree (number->string nr))))) (inc (lambda () (set! nr (+ nr 1)) (sync)))) (input "Output" "0") === (bar (button "Start" (when (not busy) (set! busy #t) (widget-delayed (#:while busy) (#:every 1000) (inc)))) (button "End" (set! busy #f)) (button "Reset" (set! nr 0) (sync)) (button "Increase" (inc)) >>> (button "Done" (dismiss)))))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote widget-6))) (tm-define-overloaded (build-content w) (with (options) (build-options w) (build-with options (build-content-list (quasiquote ((let ((nr 0) (busy #f) (sync (lambda () (widget-set! "Output" (tree (number->string nr))))) (inc (lambda () (set! nr (+ nr 1)) (sync)))) (input "Output" "0") === (bar (button "Start" (when (not busy) (set! busy #t) (widget-delayed (#:while busy) (#:every 1000) (inc)))) (button "End" (set! busy #f)) (button "Reset" (set! nr 0) (sync)) (button "Increase" (inc)) >>> (button "Done" (dismiss)))))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote widget-7))) (tm-define-overloaded (build-content w) (with (options) (build-options w) (build-with options (build-content-list (quasiquote ((hidden-input "page" "1" (header-bar (radio-button "page" "1" "First") (radio-button "page" "2" "Second") (radio-button "page" "3" "Third")) (pagelet "page" "1" "Hallo" "Hop") (pagelet "page" "2" "Blah" "Boem") (pagelet "page" "3" "Einde verhaal")))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote widget-7))) (tm-define-overloaded (build-content w) (with (options) (build-options w) (build-with options (build-content-list (quasiquote ((hidden-input "page" "1" (header-bar (radio-button "page" "1" "First") (radio-button "page" "2" "Second") (radio-button "page" "3" "Third")) (pagelet "page" "1" "Hallo" "Hop") (pagelet "page" "2" "Blah" "Boem") (pagelet "page" "3" "Einde verhaal")))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote widget-8))) (tm-define-overloaded (build-content w) (with (options) (build-options w) (build-with options (build-content-list (quasiquote ("Input:" (math (block-input "input" "")) === "Output:" (math (block-input "output" "")) === (bar (button "Differentiate" (widget->script "tmin" "input") (script->widget "output" "diff(tmin,x)")) (button "Integrate" (widget->script "tmin" "input") (script->widget "output" "integrate(tmin,x)")) (button "Taylor series" (widget->script "tmin" "input") (script->widget "output" "taylor(tmin,x,0,25)")) >>> (button "Done" (dismiss))))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote widget-8))) (tm-define-overloaded (build-content w) (with (options) (build-options w) (build-with options (build-content-list (quasiquote ("Input:" (math (block-input "input" "")) === "Output:" (math (block-input "output" "")) === (bar (button "Differentiate" (widget->script "tmin" "input") (script->widget "output" "diff(tmin,x)")) (button "Integrate" (widget->script "tmin" "input") (script->widget "output" "integrate(tmin,x)")) (button "Taylor series" (widget->script "tmin" "input") (script->widget "output" "taylor(tmin,x,0,25)")) >>> (button "Done" (dismiss))))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote widget-9))) (tm-define-overloaded (build-content w) (with (options) (build-options w) (build-with options (build-content-list (quasiquote ((form ("test" "first" "second") (suggestions "first" (quote ("hallo" "hop"))) (association-tile ("First input:" (input "first" #:auto)) ("Second input:" (input "second" #:auto))) === (bar (form-previous) (form-next) >>> (form-cancel) (form-done "Ok" (lambda (x y) (display* x ", " y "
"))))))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote widget-9))) (tm-define-overloaded (build-content w) (with (options) (build-options w) (build-with options (build-content-list (quasiquote ((form ("test" "first" "second") (suggestions "first" (quote ("hallo" "hop"))) (association-tile ("First input:" (input "first" #:auto)) ("Second input:" (input "second" #:auto))) === (bar (form-previous) (form-next) >>> (form-cancel) (form-done "Ok" (lambda (x y) (display* x ", " y "
"))))))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote widget-10))) (tm-define-overloaded (build-content w) (with (options) (build-options w) (build-with options (build-content-list (quasiquote ((canvas-input "canvas" "-6em" "6em" "") === (bar (button "Display" (display* (widget-ref "canvas") "
")) >>> (button "Done" (dismiss))))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote widget-10))) (tm-define-overloaded (build-content w) (with (options) (build-options w) (build-with options (build-content-list (quasiquote ((canvas-input "canvas" "-6em" "6em" "") === (bar (button "Display" (display* (widget-ref "canvas") "
")) >>> (button "Done" (dismiss))))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote print-widget))) (tm-define-overloaded (build-content w) (with (options) (build-options w) (build-with options (build-content-list (quasiquote ((center (short-tile (#:cell-halign * 1 "r") (#:cell-lsep * -1 "2em") ("Printer:" (short-input (#:short-width "10em") "printer" "default") (button (small "Configure") (#:button-shape "invisible") (with name (tree->string (widget-ref "printer")) (widget-popup "Printer configuration" (quasiquote (configure-printer-widget (unquote name))))))) ("Options:" (short-input (#:short-width "10em") "options" "default") (button (small "Configure") (with type (tree->string (widget-ref "printer")) (widget-popup "Printer options configuration" (quasiquote (configure-printer-options-widget (unquote type))))))))) --- (center (short-tile (#:cell-halign * 1 "r") ("Pages:" (concat (short-input (#:short-width "2em") "first" "1") " -- " (short-input (#:short-width "2em") "last" "1"))) ("Copies:" (short-input (#:short-width "2em") "number" "1")))) --- (bar (button "Preview" (noop)) (button "Export" (noop)) >>> (button "Cancel" (dismiss)) (button "Print" (noop))))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote print-widget))) (tm-define-overloaded (build-content w) (with (options) (build-options w) (build-with options (build-content-list (quasiquote ((center (short-tile (#:cell-halign * 1 "r") (#:cell-lsep * -1 "2em") ("Printer:" (short-input (#:short-width "10em") "printer" "default") (button (small "Configure") (#:button-shape "invisible") (with name (tree->string (widget-ref "printer")) (widget-popup "Printer configuration" (quasiquote (configure-printer-widget (unquote name))))))) ("Options:" (short-input (#:short-width "10em") "options" "default") (button (small "Configure") (with type (tree->string (widget-ref "printer")) (widget-popup "Printer options configuration" (quasiquote (configure-printer-options-widget (unquote type))))))))) --- (center (short-tile (#:cell-halign * 1 "r") ("Pages:" (concat (short-input (#:short-width "2em") "first" "1") " -- " (short-input (#:short-width "2em") "last" "1"))) ("Copies:" (short-input (#:short-width "2em") "number" "1")))) --- (bar (button "Preview" (noop)) (button "Export" (noop)) >>> (button "Cancel" (dismiss)) (button "Print" (noop))))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote configure-printer-widget))) (tm-define-overloaded (build-content w) (with (options which) (build-options w) (build-with options (build-content-list (quasiquote ((let ((name (unquote which)) (cmd (if (== name "default") "lpr" (string-append "lpr -P" name)))) (form ("configure-printer" "name" "command" "paper" "dpi") (suggestions "name" (list name)) (suggestions "command" (list cmd)) (suggestions "paper" (list "a4")) (suggestions "dpi" (list "600")) (association-tile ("Printer name:" (input "name" #:auto)) ("Printing command:" (input "command" #:auto)) ("Paper format:" (input "paper" #:auto)) ("Dots per inch:" (input "dpi" #:auto))) === (bar (form-previous) (form-next) >>> (form-cancel) (form-done "Save" ignore)))))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote configure-printer-widget))) (tm-define-overloaded (build-content w) (with (options which) (build-options w) (build-with options (build-content-list (quasiquote ((let ((name (unquote which)) (cmd (if (== name "default") "lpr" (string-append "lpr -P" name)))) (form ("configure-printer" "name" "command" "paper" "dpi") (suggestions "name" (list name)) (suggestions "command" (list cmd)) (suggestions "paper" (list "a4")) (suggestions "dpi" (list "600")) (association-tile ("Printer name:" (input "name" #:auto)) ("Printing command:" (input "command" #:auto)) ("Paper format:" (input "paper" #:auto)) ("Dots per inch:" (input "dpi" #:auto))) === (bar (form-previous) (form-next) >>> (form-cancel) (form-done "Save" ignore)))))))))))

  (define-option-require opt decl)
    <= (((tm-is? w (quote configure-printer-options-widget))) (tm-define-overloaded (build-content w) (with (options which) (build-options w) (build-with options (build-content-list (quasiquote ((let ((type (unquote which))) (form ("configure-printer-options" "type" "parity" "reduce") (suggestions "type" (list type)) (suggestions "parity" (list "all")) (suggestions "reduce" (list "1")) (suggestions "booklet" (list "false")) (association-tile ("Printer options type:" (input "type" #:auto)) ("Filter pages:" (input "parity" #:auto)) ("Document pages per page:" (input "reduce" #:auto)) ("Reorder pages as booklet:" (toggle "booklet" #:auto))) === (bar (form-previous) (form-next) >>> (form-cancel) (form-done "Save" ignore)))))))))))
    => (define-option-match opt decl) <= ((lambda (w) (tm-is? w (quote configure-printer-options-widget))) (tm-define-overloaded (build-content w) (with (options which) (build-options w) (build-with options (build-content-list (quasiquote ((let ((type (unquote which))) (form ("configure-printer-options" "type" "parity" "reduce") (suggestions "type" (list type)) (suggestions "parity" (list "all")) (suggestions "reduce" (list "1")) (suggestions "booklet" (list "false")) (association-tile ("Printer options type:" (input "type" #:auto)) ("Filter pages:" (input "parity" #:auto)) ("Document pages per page:" (input "reduce" #:auto)) ("Reorder pages as booklet:" (toggle "booklet" #:auto))) === (bar (form-previous) (form-next) >>> (form-cancel) (form-done "Save" ignore)))))))))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Define a smart table @t with entries @l") (tm-define-overloaded (smart-table$impl t . l) (quasiquote (begin (when (not (defined? (quote (unquote t)))) (tm-define (unquote t) (make-ahash-table))) (unquote-splicing (smart-table-insert t (quote ()) l))))))
   => ((quote smart-table$impl) #:synopsis (quote ("Define a smart table @t with entries @l")))
 => cons <> cur-props
   => cur-props => (((quote smart-table$impl) #:synopsis (quote ("Define a smart table @t with entries @l"))))

(property-set! var prop what conds*)
  <= (smart-table$impl #:synopsis ("Define a smart table @t with entries @l") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Get the entry @key in the table @t") (tm-define-overloaded (smart-ref t key) (let ((fun (ahash-ref t key))) (and fun (fun)))))
   => ((quote smart-ref) #:synopsis (quote ("Get the entry @key in the table @t")))
 => cons <> cur-props
   => cur-props => (((quote smart-ref) #:synopsis (quote ("Get the entry @key in the table @t"))))

(property-set! var prop what conds*)
  <= (smart-ref #:synopsis ("Get the entry @key in the table @t") ())

  (define-option-argument opt decl)
    <= ((l "A list of the form @(tuple plugin expr)") (tm-define-overloaded (plugin-math-input l) (set! current-plugin-input-stree (caddr l)) (set! plugin-input-current-plugin (cadr l)) (tm-with-output-to-string plugin-input-caller)))
    => cons <> cur-props <= ((quote plugin-math-input) #:arguments (quote (l)))
    => cons <> cur-props <= ((quote plugin-math-input) (quote (#:argument l)) (quote ("A list of the form @(tuple plugin expr)")))
    => cur-props => (((quote plugin-math-input) (quote (#:argument l)) (quote ("A list of the form @(tuple plugin expr)"))) ((quote plugin-math-input) #:arguments (quote (l))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Convert mathematical input to a string") (tm-define-overloaded (plugin-math-input l) (set! current-plugin-input-stree (caddr l)) (set! plugin-input-current-plugin (cadr l)) (tm-with-output-to-string plugin-input-caller)))
   => ((quote plugin-math-input) #:synopsis (quote ("Convert mathematical input to a string")))
 => cons <> cur-props
   => cur-props => (((quote plugin-math-input) #:synopsis (quote ("Convert mathematical input to a string"))) ((quote plugin-math-input) (quote (#:argument l)) (quote ("A list of the form @(tuple plugin expr)"))) ((quote plugin-math-input) #:arguments (quote (l))))

(property-set! var prop what conds*)
  <= (plugin-math-input #:synopsis ("Convert mathematical input to a string") ())

(property-set! var prop what conds*)
  <= (plugin-math-input (#:argument l) ("A list of the form @(tuple plugin expr)") ())

(property-set! var prop what conds*)
  <= (plugin-math-input #:arguments (l) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (texmacs-version-release* t) (texmacs-version-release (tree->string t))))
    => ((quote texmacs-version-release*) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote texmacs-version-release*) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (texmacs-version-release* #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (ext-map fun to) (with (op . args) (tree->list to) (with f (lambda (x) (list (quote compound) fun x)) (list (quote quote) (cons (quote tuple) (map f args)))))))
    => ((quote ext-map) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote ext-map) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (ext-map #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (ext-concat-tuple tup sep fin) (with (op . l) (tree->list tup) (cond ((null? l) "") ((null? (cdr l)) (car l)) (else (quasiquote (concat (unquote (car l)) (unquote-splicing (map (lambda (x) (list (quote concat) sep x)) (cDdr l))) (unquote (if (tm-equal? fin (quote (uninit))) sep fin)) (unquote (cAr l)))))))))
    => ((quote ext-concat-tuple) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote ext-concat-tuple) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (ext-concat-tuple #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (ext-select body args) (with (op body2 . pat) (tree->list args) (list (quote quote) (cons (quote tuple) (select body (map rewrite-select pat)))))))
    => ((quote ext-select) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote ext-select) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (ext-select #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (ext-language-suffix) (with s (language-to-locale (get-output-language)) (if (>= (string-length s) 2) (substring s 0 2) "en"))))
    => ((quote ext-language-suffix) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote ext-language-suffix) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (ext-language-suffix #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (ext-listing body) (if (tm-func? body (quote document)) (quasiquote (tformat (twith "table-width" "1par") (twith "table-hmode" "exact") (twith "table-hyphen" "y") (cwith "1" "-1" "1" "1" "cell-halign" "r") (cwith "1" "-1" "1" "1" "cell-lsep" "0em") (cwith "1" "-1" "2" "2" "cell-halign" "l") (cwith "1" "-1" "2" "2" "cell-rsep" "0em") (cwith "1" "-1" "2" "2" "cell-hpart" "1") (cwith "1" "-1" "2" "2" "cell-hyphen" "t") (cwith "1" "-1" "1" "-1" "cell-background" (if (equal (mod (value "cell-row-nr") "2") "0") "#f4f4ff" "")) (table (unquote-splicing (map (lambda (row) (ext-listing-row body row)) (.. 0 (tm-arity body))))))) body)))
    => ((quote ext-listing) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote ext-listing) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (ext-listing #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (ext-first-last t) (if (tree-compound? t) t (let* ((s (tree->string t)) (i (string-search-forwards " " 0 s)) (m (number->string i)) (e (number->string (string-length s)))) (if (< i 0) t (quasiquote (concat (range (unquote t) "0" (unquote m)) (name (range (unquote t) (unquote m) (unquote e))))))))))
    => ((quote ext-first-last) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote ext-first-last) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (ext-first-last #:secure (#t) ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Add current cursor position into the history") (tm-define-overloaded (cursor-history-add p) (if (cursor-same? (future-get) p) (with pos (car (future-get)) (future-set (cdr (future-get))) (history-set (cons pos (history-get)))) (when (not (cursor-same? (history-get) p)) (with pos (position-new) (position-set pos p) (history-set (cons pos (history-get))))))))
   => ((quote cursor-history-add) #:synopsis (quote ("Add current cursor position into the history")))
 => cons <> cur-props
   => cur-props => (((quote cursor-history-add) #:synopsis (quote ("Add current cursor position into the history"))))

(property-set! var prop what conds*)
  <= (cursor-history-add #:synopsis ("Add current cursor position into the history") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Does there exist a previous position in history?") (tm-define-overloaded (cursor-has-history?) (nnull? (history-get))))
   => ((quote cursor-has-history?) #:synopsis (quote ("Does there exist a previous position in history?")))
 => cons <> cur-props
   => cur-props => (((quote cursor-has-history?) #:synopsis (quote ("Does there exist a previous position in history?"))))

(property-set! var prop what conds*)
  <= (cursor-has-history? #:synopsis ("Does there exist a previous position in history?") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Go to previous position in history") (tm-define-overloaded (cursor-history-backward) (when (nnull? (history-get)) (with pos (car (history-get)) (history-set (cdr (history-get))) (if (position-valid? pos) (begin (future-set (cons pos (future-get))) (if (== (cursor-path) (position-get pos)) (cursor-history-backward) (begin (go-to (position-get pos)) (cursor-show-if-hidden)))) (begin (position-delete pos) (cursor-history-backward)))))))
   => ((quote cursor-history-backward) #:synopsis (quote ("Go to previous position in history")))
 => cons <> cur-props
   => cur-props => (((quote cursor-history-backward) #:synopsis (quote ("Go to previous position in history"))))

(property-set! var prop what conds*)
  <= (cursor-history-backward #:synopsis ("Go to previous position in history") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Does there exist a next position in history?") (tm-define-overloaded (cursor-has-future?) (nnull? (future-get))))
   => ((quote cursor-has-future?) #:synopsis (quote ("Does there exist a next position in history?")))
 => cons <> cur-props
   => cur-props => (((quote cursor-has-future?) #:synopsis (quote ("Does there exist a next position in history?"))))

(property-set! var prop what conds*)
  <= (cursor-has-future? #:synopsis ("Does there exist a next position in history?") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Go to next position in history") (tm-define-overloaded (cursor-history-forward) (when (nnull? (future-get)) (with pos (car (future-get)) (future-set (cdr (future-get))) (if (position-valid? pos) (begin (history-set (cons pos (history-get))) (if (== (cursor-path) (position-get pos)) (cursor-history-forward) (begin (go-to (position-get pos)) (cursor-show-if-hidden)))) (begin (position-delete pos) (cursor-future-backward)))))))
   => ((quote cursor-history-forward) #:synopsis (quote ("Go to next position in history")))
 => cons <> cur-props
   => cur-props => (((quote cursor-history-forward) #:synopsis (quote ("Go to next position in history"))))

(property-set! var prop what conds*)
  <= (cursor-history-forward #:synopsis ("Go to next position in history") ())

  (define-option-proposals opt decl)
    <= ((name (list-abbrs)) (tm-define-overloaded (go-to-buffer name) (cond ((in? name (buffer-list)) (switch-to-buffer name)) ((abbr->buffer name) (switch-to-buffer (abbr->buffer name))) ((in? (unix->url name) (buffer-list)) (switch-to-buffer (unix->url name))) (else (set-message (quasiquote (concat "Error: no buffer " (verbatim (unquote name)))) "switch to buffer")))))
    => cons <> cur-props <= ((quote go-to-buffer) (quote (#:proposals name)) (lambda () (list-abbrs)))
    => cur-props => (((quote go-to-buffer) (quote (#:proposals name)) (lambda () (list-abbrs))))

  (define-option-argument opt decl)
    <= ((name "Switch to buffer") (tm-define-overloaded (go-to-buffer name) (cond ((in? name (buffer-list)) (switch-to-buffer name)) ((abbr->buffer name) (switch-to-buffer (abbr->buffer name))) ((in? (unix->url name) (buffer-list)) (switch-to-buffer (unix->url name))) (else (set-message (quasiquote (concat "Error: no buffer " (verbatim (unquote name)))) "switch to buffer")))))
    => cons <> cur-props <= ((quote go-to-buffer) #:arguments (quote (name)))
    => cons <> cur-props <= ((quote go-to-buffer) (quote (#:argument name)) (quote ("Switch to buffer")))
    => cur-props => (((quote go-to-buffer) (quote (#:argument name)) (quote ("Switch to buffer"))) ((quote go-to-buffer) #:arguments (quote (name))) ((quote go-to-buffer) (quote (#:proposals name)) (lambda () (list-abbrs))))

(property-set! var prop what conds*)
  <= (go-to-buffer (#:argument name) ("Switch to buffer") ())

(property-set! var prop what conds*)
  <= (go-to-buffer #:arguments (name) ())

(property-set! var prop what conds*)
  <= (go-to-buffer (#:proposals name) #<procedure #f ()> ())

  (define-option-argument opt decl)
    <= ((by "Replace by") (tm-define-overloaded (replace-start-forward what by) (replace-start what by #t)))
    => cons <> cur-props <= ((quote replace-start-forward) #:arguments (quote (what by)))
    => cons <> cur-props <= ((quote replace-start-forward) (quote (#:argument by)) (quote ("Replace by")))
    => cur-props => (((quote replace-start-forward) (quote (#:argument by)) (quote ("Replace by"))) ((quote replace-start-forward) #:arguments (quote (what by))))

  (define-option-argument opt decl)
    <= ((what "Find text") (tm-define-overloaded (replace-start-forward what by) (replace-start what by #t)))
    => cons <> cur-props <= ((quote replace-start-forward) #:arguments (quote (what by)))
    => cons <> cur-props <= ((quote replace-start-forward) (quote (#:argument what)) (quote ("Find text")))
    => cur-props => (((quote replace-start-forward) (quote (#:argument what)) (quote ("Find text"))) ((quote replace-start-forward) #:arguments (quote (what by))) ((quote replace-start-forward) (quote (#:argument by)) (quote ("Replace by"))) ((quote replace-start-forward) #:arguments (quote (what by))))

(property-set! var prop what conds*)
  <= (replace-start-forward (#:argument what) ("Find text") ())

(property-set! var prop what conds*)
  <= (replace-start-forward #:arguments (what by) ())

(property-set! var prop what conds*)
  <= (replace-start-forward (#:argument by) ("Replace by") ())

(property-set! var prop what conds*)
  <= (replace-start-forward #:arguments (what by) ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Assign @ref with @t.") (tm-define-overloaded (tree-set-diff ref t) (let* ((p (tree->path ref)) (l (tree-common-left ref t)) (r (tree-common-right (tm-range ref l (tm-length ref)) (tm-range t l (tm-length t))))) (cond ((not p) (texmacs-error "tree-set-diff" "~S isn't part of a document" ref)) ((tm-equal? ref t) ref) ((tree-inside? t ref) (with q (tree->path t) (tree-remove-node! ref (list-ref q (length p))) (tree-set-diff ref t))) ((and (tm-atomic? ref) (tm-atomic? t) (= (+ l r) (tm-length ref)) (< (tm-length ref) (tm-length t))) (tree-insert! ref l (substring (tm->string t) l (- (tm-length t) r)))) ((and (tm-atomic? ref) (tm-atomic? t) (= (+ l r) (tm-length t)) (> (tm-length ref) (tm-length t))) (tree-remove! ref l (- (- (tm-length ref) r) l))) ((not (tm-compound? t)) (tree-assign! ref t)) ((and (tm-compound? ref) (= l (tm-arity ref)) (= l (tm-arity t))) (tree-assign-node! ref (tm-car t))) ((and (tm-compound? ref) (= (+ l r) (tm-arity ref)) (< (tm-arity ref) (tm-arity t))) (tree-insert! ref l (sublist (tm-cdr t) l (- (tm-arity t) r))) (if (== (tm-car ref) (tm-car t)) ref (tree-assign-node! ref (tm-car t)))) ((and (tm-compound? ref) (= (+ l r) (tm-arity t)) (> (tm-arity ref) (tm-arity t)) (not (tree-is-buffer? ref))) (tree-remove! ref l (- (- (tm-arity ref) r) l)) (if (== (tm-car ref) (tm-car t)) ref (tree-assign-node! ref (tm-car t)))) (else (with pos (tree-focus-index ref (tm-cdr t)) (if (or (not pos) (tree-is-buffer? ref)) (tree-assign! ref t) (let* ((tl (tm->list t)) (head (list-head tl (+ pos 1))) (mid (list-ref tl (+ pos 1))) (tail (list-tail tl (+ pos 2))) (merged (append head tail))) (tree-set-diff! ref mid) (tree-insert-node! ref pos merged)))))))))
   => ((quote tree-set-diff) #:synopsis (quote ("Assign @ref with @t.")))
 => cons <> cur-props
   => cur-props => (((quote tree-set-diff) #:synopsis (quote ("Assign @ref with @t."))))

  ((define-property which)  opt decl)
    <= ((#:type)  ((-> tree content void)) (tm-define-overloaded (tree-set-diff ref t) (let* ((p (tree->path ref)) (l (tree-common-left ref t)) (r (tree-common-right (tm-range ref l (tm-length ref)) (tm-range t l (tm-length t))))) (cond ((not p) (texmacs-error "tree-set-diff" "~S isn't part of a document" ref)) ((tm-equal? ref t) ref) ((tree-inside? t ref) (with q (tree->path t) (tree-remove-node! ref (list-ref q (length p))) (tree-set-diff ref t))) ((and (tm-atomic? ref) (tm-atomic? t) (= (+ l r) (tm-length ref)) (< (tm-length ref) (tm-length t))) (tree-insert! ref l (substring (tm->string t) l (- (tm-length t) r)))) ((and (tm-atomic? ref) (tm-atomic? t) (= (+ l r) (tm-length t)) (> (tm-length ref) (tm-length t))) (tree-remove! ref l (- (- (tm-length ref) r) l))) ((not (tm-compound? t)) (tree-assign! ref t)) ((and (tm-compound? ref) (= l (tm-arity ref)) (= l (tm-arity t))) (tree-assign-node! ref (tm-car t))) ((and (tm-compound? ref) (= (+ l r) (tm-arity ref)) (< (tm-arity ref) (tm-arity t))) (tree-insert! ref l (sublist (tm-cdr t) l (- (tm-arity t) r))) (if (== (tm-car ref) (tm-car t)) ref (tree-assign-node! ref (tm-car t)))) ((and (tm-compound? ref) (= (+ l r) (tm-arity t)) (> (tm-arity ref) (tm-arity t)) (not (tree-is-buffer? ref))) (tree-remove! ref l (- (- (tm-arity ref) r) l)) (if (== (tm-car ref) (tm-car t)) ref (tree-assign-node! ref (tm-car t)))) (else (with pos (tree-focus-index ref (tm-cdr t)) (if (or (not pos) (tree-is-buffer? ref)) (tree-assign! ref t) (let* ((tl (tm->list t)) (head (list-head tl (+ pos 1))) (mid (list-ref tl (+ pos 1))) (tail (list-tail tl (+ pos 2))) (merged (append head tail))) (tree-set-diff! ref mid) (tree-insert-node! ref pos merged)))))))))
   => ((quote tree-set-diff) #:type (quote ((-> tree content void))))
 => cons <> cur-props
   => cur-props => (((quote tree-set-diff) #:type (quote ((-> tree content void)))) ((quote tree-set-diff) #:synopsis (quote ("Assign @ref with @t."))))

(property-set! var prop what conds*)
  <= (tree-set-diff #:type ((-> tree content void)) ())

(property-set! var prop what conds*)
  <= (tree-set-diff #:synopsis ("Assign @ref with @t.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Assign @ref with @t.") (tm-define-overloaded (tree-set-diff!$impl ref t) (quasiquote (begin (set! (unquote ref) (tree-set-diff (unquote ref) (unquote t))) (unquote ref)))))
   => ((quote tree-set-diff!$impl) #:synopsis (quote ("Assign @ref with @t.")))
 => cons <> cur-props
   => cur-props => (((quote tree-set-diff!$impl) #:synopsis (quote ("Assign @ref with @t."))))

(property-set! var prop what conds*)
  <= (tree-set-diff!$impl #:synopsis ("Assign @ref with @t.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Access a subtree of @t according to @l.") (tm-define-overloaded (tree-ref t . l) (cond ((not (tree? t)) #f) ((null? l) t) ((integer? (car l)) (with i (car l) (and (tree-compound? t) (>= i 0) (< i (tree-arity t)) (apply tree-ref (cons (tree-child-ref t i) (cdr l)))))) ((== (car l) #:first) (apply tree-ref (cons t (cons 0 (cdr l))))) ((== (car l) #:last) (and (tree-compound? t) (apply tree-ref (cons t (cons (- (tree-arity t) 1) (cdr l)))))) ((symbol? (car l)) (and (tree-compound? t) (with i (list-find-index (tree-children t) (cut tree-is? <> (car l))) (apply tree-ref (cons t (cons i (cdr l))))))) (else (with r (select t l) (and (nnull? r) (car r)))))))
   => ((quote tree-ref) #:synopsis (quote ("Access a subtree of @t according to @l.")))
 => cons <> cur-props
   => cur-props => (((quote tree-ref) #:synopsis (quote ("Access a subtree of @t according to @l."))))

(property-set! var prop what conds*)
  <= (tree-ref #:synopsis ("Access a subtree of @t according to @l.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set a subtree of @t to a new value according to @l.") (tm-define-overloaded (tree-set t . args) (with r (reverse args) (tree-set-sub t (reverse (cdr r)) (car r)))))
   => ((quote tree-set) #:synopsis (quote ("Set a subtree of @t to a new value according to @l.")))
 => cons <> cur-props
   => cur-props => (((quote tree-set) #:synopsis (quote ("Set a subtree of @t to a new value according to @l."))))

(property-set! var prop what conds*)
  <= (tree-set #:synopsis ("Set a subtree of @t to a new value according to @l.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set a subtree of @t to a new value according to @l.") (tm-define-overloaded (tree-set!$impl t . l) (if (list-1? l) (quasiquote (if (tree-active? (unquote t)) (tree-set-diff! (unquote t) (unquote-splicing l)) (tree-assign! (unquote t) (unquote-splicing l)))) (quasiquote (tree-set (unquote t) (unquote-splicing l))))))
   => ((quote tree-set!$impl) #:synopsis (quote ("Set a subtree of @t to a new value according to @l.")))
 => cons <> cur-props
   => cur-props => (((quote tree-set!$impl) #:synopsis (quote ("Set a subtree of @t to a new value according to @l."))))

(property-set! var prop what conds*)
  <= (tree-set!$impl #:synopsis ("Set a subtree of @t to a new value according to @l.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Find ancestor of @t which matches @what") (tm-define-overloaded (tree-search-upwards t what) (cond ((list? what) (tree-search-upwards t (lambda (x) (in? (tree-label x) what)))) ((symbol? what) (tree-search-upwards t (lambda (x) (== (tree-label x) what)))) ((and (procedure? what) (what t)) t) ((or (tree-is-buffer? t) (not (tree-up t))) #f) (else (tree-search-upwards (tree-up t) what)))))
   => ((quote tree-search-upwards) #:synopsis (quote ("Find ancestor of @t which matches @what")))
 => cons <> cur-props
   => cur-props => (((quote tree-search-upwards) #:synopsis (quote ("Find ancestor of @t which matches @what"))))

(property-set! var prop what conds*)
  <= (tree-search-upwards #:synopsis ("Find ancestor of @t which matches @what") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Search upwards from the cursor position.") (tm-define-overloaded (tree-innermost x . opt-flag) (with p ((if (null? opt-flag) cDDr cDr) (cursor-path)) (tree-search-upwards (path->tree p) x))))
   => ((quote tree-innermost) #:synopsis (quote ("Search upwards from the cursor position.")))
 => cons <> cur-props
   => cur-props => (((quote tree-innermost) #:synopsis (quote ("Search upwards from the cursor position."))))

  ((define-property which)  opt decl)
    <= ((#:type)  ((-> symbol tree) (-> (list symbol) tree) (-> (-> bool) tree)) (tm-define-overloaded (tree-innermost x . opt-flag) (with p ((if (null? opt-flag) cDDr cDr) (cursor-path)) (tree-search-upwards (path->tree p) x))))
   => ((quote tree-innermost) #:type (quote ((-> symbol tree) (-> (list symbol) tree) (-> (-> bool) tree))))
 => cons <> cur-props
   => cur-props => (((quote tree-innermost) #:type (quote ((-> symbol tree) (-> (list symbol) tree) (-> (-> bool) tree)))) ((quote tree-innermost) #:synopsis (quote ("Search upwards from the cursor position."))))

(property-set! var prop what conds*)
  <= (tree-innermost #:type ((-> symbol tree) (-> (list symbol) tree) (-> (-> bool) tree)) ())

(property-set! var prop what conds*)
  <= (tree-innermost #:synopsis ("Search upwards from the cursor position.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Get innermost node type among possibilities in @l.") (tm-define-overloaded (inside-which l) (with t (tree-innermost l) (and t (tree-label t)))))
   => ((quote inside-which) #:synopsis (quote ("Get innermost node type among possibilities in @l.")))
 => cons <> cur-props
   => cur-props => (((quote inside-which) #:synopsis (quote ("Get innermost node type among possibilities in @l."))))

  ((define-property which)  opt decl)
    <= ((#:type)  ((-> (list symbol) symbol)) (tm-define-overloaded (inside-which l) (with t (tree-innermost l) (and t (tree-label t)))))
   => ((quote inside-which) #:type (quote ((-> (list symbol) symbol))))
 => cons <> cur-props
   => cur-props => (((quote inside-which) #:type (quote ((-> (list symbol) symbol)))) ((quote inside-which) #:synopsis (quote ("Get innermost node type among possibilities in @l."))))

(property-set! var prop what conds*)
  <= (inside-which #:type ((-> (list symbol) symbol)) ())

(property-set! var prop what conds*)
  <= (inside-which #:synopsis ("Get innermost node type among possibilities in @l.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Get the position of the tree @t.") (tm-define-overloaded (tree->path t . l) (if (null? l) (tree-get-path t) (with i (cAr l) (if (or (== i #:start) (== i #:end) (integer? i)) (with u (apply tree-ref (cons t (cDr l))) (cond ((not u) #f) ((== i #:start) (path-start (root-tree) (tree->path u))) ((== i #:end) (path-end (root-tree) (tree->path u))) ((integer? i) (rcons (tree->path u) i)))) (with u (apply tree-ref (cons t l)) (and u (tree->path u))))))))
   => ((quote tree->path) #:synopsis (quote ("Get the position of the tree @t.")))
 => cons <> cur-props
   => cur-props => (((quote tree->path) #:synopsis (quote ("Get the position of the tree @t."))))

(property-set! var prop what conds*)
  <= (tree->path #:synopsis ("Get the position of the tree @t.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Retrieve the current cursor position relative to the tree @t.") (tm-define-overloaded (tree-cursor-path t . l) (let* ((p (apply tree->path (cons t l))) (c (cursor-path))) (and p (list-starts? c p) (list-tail c (length p))))))
   => ((quote tree-cursor-path) #:synopsis (quote ("Retrieve the current cursor position relative to the tree @t.")))
 => cons <> cur-props
   => cur-props => (((quote tree-cursor-path) #:synopsis (quote ("Retrieve the current cursor position relative to the tree @t."))))

(property-set! var prop what conds*)
  <= (tree-cursor-path #:synopsis ("Retrieve the current cursor position relative to the tree @t.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Go to a position determined by @l inside the tree @t.") (tm-define-overloaded (tree-go-to t . l) (with p (apply tree->path (cons t l)) (if p (go-to p)))))
   => ((quote tree-go-to) #:synopsis (quote ("Go to a position determined by @l inside the tree @t.")))
 => cons <> cur-props
   => cur-props => (((quote tree-go-to) #:synopsis (quote ("Go to a position determined by @l inside the tree @t."))))

(property-set! var prop what conds*)
  <= (tree-go-to #:synopsis ("Go to a position determined by @l inside the tree @t.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Is the cursor at the position determined by @l inside @t?") (tm-define-overloaded (tree-cursor-at? t . l) (with p (apply tree->path (cons t l)) (== (cursor-path) p))))
   => ((quote tree-cursor-at?) #:synopsis (quote ("Is the cursor at the position determined by @l inside @t?")))
 => cons <> cur-props
   => cur-props => (((quote tree-cursor-at?) #:synopsis (quote ("Is the cursor at the position determined by @l inside @t?"))))

(property-set! var prop what conds*)
  <= (tree-cursor-at? #:synopsis ("Is the cursor at the position determined by @l inside @t?") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Select the tree @(tree-ref t . l)") (tm-define-overloaded (tree-select t . l) (and-with t (apply tree-ref (cons t l)) (and-with p (tree->path t) (selection-set (rcons p 0) (rcons p (tree-right-index t)))))))
   => ((quote tree-select) #:synopsis (quote ("Select the tree @(tree-ref t . l)")))
 => cons <> cur-props
   => cur-props => (((quote tree-select) #:synopsis (quote ("Select the tree @(tree-ref t . l)"))))

(property-set! var prop what conds*)
  <= (tree-select #:synopsis ("Select the tree @(tree-ref t . l)") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Focus on the tree @(tree-ref t . l)") (tm-define-overloaded (tree-focus t . l) (and-with t (apply tree-ref (cons t l)) (and-with p (tree->path t) (set-manual-focus-path p)))))
   => ((quote tree-focus) #:synopsis (quote ("Focus on the tree @(tree-ref t . l)")))
 => cons <> cur-props
   => cur-props => (((quote tree-focus) #:synopsis (quote ("Focus on the tree @(tree-ref t . l)"))))

(property-set! var prop what conds*)
  <= (tree-focus #:synopsis ("Focus on the tree @(tree-ref t . l)") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Deprecated old tree correction routine") (tm-define-overloaded (tree-correct-old t . l) (with p (apply tree->path (cons t l)) (if p (path-correct-old p)))))
   => ((quote tree-correct-old) #:synopsis (quote ("Deprecated old tree correction routine")))
 => cons <> cur-props
   => cur-props => (((quote tree-correct-old) #:synopsis (quote ("Deprecated old tree correction routine"))))

(property-set! var prop what conds*)
  <= (tree-correct-old #:synopsis ("Deprecated old tree correction routine") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make the node @(tree-ref t . l) correct") (tm-define-overloaded (tree-correct-node t . l) (cpp-tree-correct-node (apply tree-ref (cons t l)))))
   => ((quote tree-correct-node) #:synopsis (quote ("Make the node @(tree-ref t . l) correct")))
 => cons <> cur-props
   => cur-props => (((quote tree-correct-node) #:synopsis (quote ("Make the node @(tree-ref t . l) correct"))))

(property-set! var prop what conds*)
  <= (tree-correct-node #:synopsis ("Make the node @(tree-ref t . l) correct") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Correct the tree @(tree-ref t . l) and its descendants") (tm-define-overloaded (tree-correct-downwards t . l) (cpp-tree-correct-downwards (apply tree-ref (cons t l)))))
   => ((quote tree-correct-downwards) #:synopsis (quote ("Correct the tree @(tree-ref t . l) and its descendants")))
 => cons <> cur-props
   => cur-props => (((quote tree-correct-downwards) #:synopsis (quote ("Correct the tree @(tree-ref t . l) and its descendants"))))

(property-set! var prop what conds*)
  <= (tree-correct-downwards #:synopsis ("Correct the tree @(tree-ref t . l) and its descendants") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Correct the tree @(tree-ref t . l) and its ancestors") (tm-define-overloaded (tree-correct-upwards t . l) (cpp-tree-correct-upwards (apply tree-ref (cons t l)))))
   => ((quote tree-correct-upwards) #:synopsis (quote ("Correct the tree @(tree-ref t . l) and its ancestors")))
 => cons <> cur-props
   => cur-props => (((quote tree-correct-upwards) #:synopsis (quote ("Correct the tree @(tree-ref t . l) and its ancestors"))))

(property-set! var prop what conds*)
  <= (tree-correct-upwards #:synopsis ("Correct the tree @(tree-ref t . l) and its ancestors") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Find subgroup of @group which contains @which") (tm-define-overloaded (group-find which group) (with l (ahash-ref group-table group) (cond ((not l) #f) ((in? which l) group) (else (with f (map car (list-filter l (lambda (x) (pair? x)))) (list-any (lambda (x) (group-find which x)) f)))))))
   => ((quote group-find) #:synopsis (quote ("Find subgroup of @group which contains @which")))
 => cons <> cur-props
   => cur-props => (((quote group-find) #:synopsis (quote ("Find subgroup of @group which contains @which"))))

(property-set! var prop what conds*)
  <= (group-find #:synopsis ("Find subgroup of @group which contains @which") ())

  (define-option-require opt decl)
    <= (((numbered-standard-context? t)) (tm-define-overloaded (numbered-context? t) #t))
    => (define-option-match opt decl) <= ((lambda (t) (numbered-standard-context? t)) (tm-define-overloaded (numbered-context? t) #t))

  (define-option-require opt decl)
    <= (((numbered-standard-context? t)) (tm-define-overloaded (numbered-numbered? t) (not (symbol-ends? (tree-label t) (quote *)))))
    => (define-option-match opt decl) <= ((lambda (t) (numbered-standard-context? t)) (tm-define-overloaded (numbered-numbered? t) (not (symbol-ends? (tree-label t) (quote *)))))

  (define-option-require opt decl)
    <= (((numbered-standard-context? t)) (tm-define-overloaded (numbered-toggle t) (let* ((old (tree-label t)) (new (symbol-toggle-number old))) (variant-set t new))))
    => (define-option-match opt decl) <= ((lambda (t) (numbered-standard-context? t)) (tm-define-overloaded (numbered-toggle t) (let* ((old (tree-label t)) (new (symbol-toggle-number old))) (variant-set t new))))

  (define-option-require opt decl)
    <= (((alternate-standard-context? t)) (tm-define-overloaded (alternate-context? t) #t))
    => (define-option-match opt decl) <= ((lambda (t) (alternate-standard-context? t)) (tm-define-overloaded (alternate-context? t) #t))

  (define-option-require opt decl)
    <= (((alternate-standard-first? t)) (tm-define-overloaded (alternate-first? t) #t))
    => (define-option-match opt decl) <= ((lambda (t) (alternate-standard-first? t)) (tm-define-overloaded (alternate-first? t) #t))

  (define-option-require opt decl)
    <= (((alternate-standard-second? t)) (tm-define-overloaded (alternate-second? t) #t))
    => (define-option-match opt decl) <= ((lambda (t) (alternate-standard-second? t)) (tm-define-overloaded (alternate-second? t) #t))

  (define-option-require opt decl)
    <= (((alternate-standard-context? t)) (tm-define-overloaded (alternate-toggle t) (variant-set t (symbol-toggle-alternate (tree-label t)))))
    => (define-option-match opt decl) <= ((lambda (t) (alternate-standard-context? t)) (tm-define-overloaded (alternate-toggle t) (variant-set t (symbol-toggle-alternate (tree-label t)))))

  (define-option-require opt decl)
    <= (((alternate-standard-second? t)) (tm-define-overloaded (alternate-fold t) (alternate-toggle t)))
    => (define-option-match opt decl) <= ((lambda (t) (alternate-standard-second? t)) (tm-define-overloaded (alternate-fold t) (alternate-toggle t)))

  (define-option-require opt decl)
    <= (((alternate-standard-first? t)) (tm-define-overloaded (alternate-unfold t) (alternate-toggle t)))
    => (define-option-match opt decl) <= ((lambda (t) (alternate-standard-first? t)) (tm-define-overloaded (alternate-unfold t) (alternate-toggle t)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Fold at the current focus position") (tm-define-overloaded (fold) (alternate-fold (focus-tree))))
   => ((quote fold) #:synopsis (quote ("Fold at the current focus position")))
 => cons <> cur-props
   => cur-props => (((quote fold) #:synopsis (quote ("Fold at the current focus position"))))

  ((define-property which)  opt decl)
    <= ((#:type)  ((-> void)) (tm-define-overloaded (fold) (alternate-fold (focus-tree))))
   => ((quote fold) #:type (quote ((-> void))))
 => cons <> cur-props
   => cur-props => (((quote fold) #:type (quote ((-> void)))) ((quote fold) #:synopsis (quote ("Fold at the current focus position"))))

(property-set! var prop what conds*)
  <= (fold #:type ((-> void)) ())

(property-set! var prop what conds*)
  <= (fold #:synopsis ("Fold at the current focus position") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Unold at the current focus position") (tm-define-overloaded (unfold) (alternate-unfold (focus-tree))))
   => ((quote unfold) #:synopsis (quote ("Unold at the current focus position")))
 => cons <> cur-props
   => cur-props => (((quote unfold) #:synopsis (quote ("Unold at the current focus position"))))

  ((define-property which)  opt decl)
    <= ((#:type)  ((-> void)) (tm-define-overloaded (unfold) (alternate-unfold (focus-tree))))
   => ((quote unfold) #:type (quote ((-> void))))
 => cons <> cur-props
   => cur-props => (((quote unfold) #:type (quote ((-> void)))) ((quote unfold) #:synopsis (quote ("Unold at the current focus position"))))

(property-set! var prop what conds*)
  <= (unfold #:type ((-> void)) ())

(property-set! var prop what conds*)
  <= (unfold #:synopsis ("Unold at the current focus position") ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (mouse-fold t) (when (tree->path t) (tree-go-to t #:start) (when (tree-up t) (alternate-fold (tree-up t))))))
    => ((quote mouse-fold) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote mouse-fold) #:secure (list #t)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Fold using the mouse") (tm-define-overloaded (mouse-fold t) (when (tree->path t) (tree-go-to t #:start) (when (tree-up t) (alternate-fold (tree-up t))))))
   => ((quote mouse-fold) #:synopsis (quote ("Fold using the mouse")))
 => cons <> cur-props
   => cur-props => (((quote mouse-fold) #:synopsis (quote ("Fold using the mouse"))) ((quote mouse-fold) #:secure (list #t)))

  ((define-property which)  opt decl)
    <= ((#:type)  ((-> void)) (tm-define-overloaded (mouse-fold t) (when (tree->path t) (tree-go-to t #:start) (when (tree-up t) (alternate-fold (tree-up t))))))
   => ((quote mouse-fold) #:type (quote ((-> void))))
 => cons <> cur-props
   => cur-props => (((quote mouse-fold) #:type (quote ((-> void)))) ((quote mouse-fold) #:synopsis (quote ("Fold using the mouse"))) ((quote mouse-fold) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (mouse-fold #:type ((-> void)) ())

(property-set! var prop what conds*)
  <= (mouse-fold #:synopsis ("Fold using the mouse") ())

(property-set! var prop what conds*)
  <= (mouse-fold #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (mouse-unfold t) (when (tree->path t) (tree-go-to t #:start) (when (tree-up t) (alternate-unfold (tree-up t))))))
    => ((quote mouse-unfold) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote mouse-unfold) #:secure (list #t)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Unfold using the mouse") (tm-define-overloaded (mouse-unfold t) (when (tree->path t) (tree-go-to t #:start) (when (tree-up t) (alternate-unfold (tree-up t))))))
   => ((quote mouse-unfold) #:synopsis (quote ("Unfold using the mouse")))
 => cons <> cur-props
   => cur-props => (((quote mouse-unfold) #:synopsis (quote ("Unfold using the mouse"))) ((quote mouse-unfold) #:secure (list #t)))

  ((define-property which)  opt decl)
    <= ((#:type)  ((-> void)) (tm-define-overloaded (mouse-unfold t) (when (tree->path t) (tree-go-to t #:start) (when (tree-up t) (alternate-unfold (tree-up t))))))
   => ((quote mouse-unfold) #:type (quote ((-> void))))
 => cons <> cur-props
   => cur-props => (((quote mouse-unfold) #:type (quote ((-> void)))) ((quote mouse-unfold) #:synopsis (quote ("Unfold using the mouse"))) ((quote mouse-unfold) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (mouse-unfold #:type ((-> void)) ())

(property-set! var prop what conds*)
  <= (mouse-unfold #:synopsis ("Unfold using the mouse") ())

(property-set! var prop what conds*)
  <= (mouse-unfold #:secure (#t) ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Retrieve list of variants of @lab") (tm-define-overloaded (variants-of lab) (variants-of-sub lab (quote variant-tag) #f)))
   => ((quote variants-of) #:synopsis (quote ("Retrieve list of variants of @lab")))
 => cons <> cur-props
   => cur-props => (((quote variants-of) #:synopsis (quote ("Retrieve list of variants of @lab"))))

(property-set! var prop what conds*)
  <= (variants-of #:synopsis ("Retrieve list of variants of @lab") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Retrieve list of tags similar to @lab") (tm-define-overloaded (similar-to lab) (variants-of-sub lab (quote similar-tag) #t)))
   => ((quote similar-to) #:synopsis (quote ("Retrieve list of tags similar to @lab")))
 => cons <> cur-props
   => cur-props => (((quote similar-to) #:synopsis (quote ("Retrieve list of tags similar to @lab"))))

(property-set! var prop what conds*)
  <= (similar-to #:synopsis ("Retrieve list of tags similar to @lab") ())

  (define-option-require opt decl)
    <= (((variant-standard-context? t)) (tm-define-overloaded (variant-context? t) #t))
    => (define-option-match opt decl) <= ((lambda (t) (variant-standard-context? t)) (tm-define-overloaded (variant-context? t) #t))

  (define-option-require opt decl)
    <= (((variant-standard-context? t)) (tm-define-overloaded (variant-circulate t forward?) (variant-circulate-in t (variants-of (tree-label t)) forward?)))
    => (define-option-match opt decl) <= ((lambda (t forward?) (variant-standard-context? t)) (tm-define-overloaded (variant-circulate t forward?) (variant-circulate-in t (variants-of (tree-label t)) forward?)))

  (define-option-require opt decl)
    <= (((hidden-context? t)) (tm-define-overloaded (tree-show-hidden t) (tree-assign-node! t (quote shown))))
    => (define-option-match opt decl) <= ((lambda (t) (hidden-context? t)) (tm-define-overloaded (tree-show-hidden t) (tree-assign-node! t (quote shown))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Check whether a given ptree @pt contains all items in the list @l") (tm-define-overloaded (pt-has-list? pt l) (list-fold (lambda (val prior) (and (pt-has? pt val) prior)) #t l)))
   => ((quote pt-has-list?) #:synopsis (quote ("Check whether a given ptree @pt contains all items in the list @l")))
 => cons <> cur-props
   => cur-props => (((quote pt-has-list?) #:synopsis (quote ("Check whether a given ptree @pt contains all items in the list @l"))))

(property-set! var prop what conds*)
  <= (pt-has-list? #:synopsis ("Check whether a given ptree @pt contains all items in the list @l") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Return the list of words below the given p-tree node @pt") (tm-define-overloaded (pt-words-below pt) (pt-words-below-sub pt "")))
   => ((quote pt-words-below) #:synopsis (quote ("Return the list of words below the given p-tree node @pt")))
 => cons <> cur-props
   => cur-props => (((quote pt-words-below) #:synopsis (quote ("Return the list of words below the given p-tree node @pt"))))

(property-set! var prop what conds*)
  <= (pt-words-below #:synopsis ("Return the list of words below the given p-tree node @pt") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Returns the (cached) name of the bibliography file") (tm-define-overloaded (current-bib-file usecache?) (with u (current-buffer-url) (or (and usecache? (ahash-ref bib-files-cache u)) (with l (select (buffer-tree) (quote (#:* bibliography))) (if (nnull? l) (ahash-set! bib-files-cache u (url-append (url-head u) (tm->string (tree-ref (car l) 2)))) (url-none)))))))
   => ((quote current-bib-file) #:synopsis (quote ("Returns the (cached) name of the bibliography file")))
 => cons <> cur-props
   => cur-props => (((quote current-bib-file) #:synopsis (quote ("Returns the (cached) name of the bibliography file"))))

(property-set! var prop what conds*)
  <= (current-bib-file #:synopsis ("Returns the (cached) name of the bibliography file") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Returns the (cached) style of the bibliography") (tm-define-overloaded (current-bib-style usecache?) (with u (current-buffer-url) (or (and usecache? (ahash-ref bib-styles-cache u)) (with l (select (buffer-tree) (quote (#:* bibliography))) (if (nnull? l) (ahash-set! bib-styles-cache u (tm->string (tree-ref (car l) 1))) "tm-plain"))))))
   => ((quote current-bib-style) #:synopsis (quote ("Returns the (cached) style of the bibliography")))
 => cons <> cur-props
   => cur-props => (((quote current-bib-style) #:synopsis (quote ("Returns the (cached) style of the bibliography"))))

(property-set! var prop what conds*)
  <= (current-bib-style #:synopsis ("Returns the (cached) style of the bibliography") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Completions for @s in the bibtex file @u as a list") (tm-define-overloaded (citekey-list u s) (if (url-none? u) (quote ()) (pt-words-below (pt-find (get-citekeys-pt u) s)))))
   => ((quote citekey-list) #:synopsis (quote ("Completions for @s in the bibtex file @u as a list")))
 => cons <> cur-props
   => cur-props => (((quote citekey-list) #:synopsis (quote ("Completions for @s in the bibtex file @u as a list"))))

(property-set! var prop what conds*)
  <= (citekey-list #:synopsis ("Completions for @s in the bibtex file @u as a list") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Completions for @t in the bibtex file @u for custom-complete") (tm-define-overloaded (citekey-completions u t) (quasiquote (tuple (unquote t) (unquote-splicing (map string->tmstring (citekey-list u (tree->string t))))))))
   => ((quote citekey-completions) #:synopsis (quote ("Completions for @t in the bibtex file @u for custom-complete")))
 => cons <> cur-props
   => cur-props => (((quote citekey-completions) #:synopsis (quote ("Completions for @t in the bibtex file @u for custom-complete"))))

(property-set! var prop what conds*)
  <= (citekey-completions #:synopsis ("Completions for @t in the bibtex file @u for custom-complete") ())

  (define-option-require opt decl)
    <= (((tree-is-buffer? t)) (tm-define-overloaded (kbd-horizontal t forwards?) (with move (lambda () (if forwards? (go-right) (go-left))) (go-to-next-such-that move generic-context?))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (tree-is-buffer? t)) (tm-define-overloaded (kbd-horizontal t forwards?) (with move (lambda () (if forwards? (go-right) (go-left))) (go-to-next-such-that move generic-context?))))

  (define-option-require opt decl)
    <= (((tree-is-buffer? t)) (tm-define-overloaded (kbd-vertical t downwards?) (with move (lambda () (if downwards? (go-down) (go-up))) (go-to-next-such-that move generic-context?))))
    => (define-option-match opt decl) <= ((lambda (t downwards?) (tree-is-buffer? t)) (tm-define-overloaded (kbd-vertical t downwards?) (with move (lambda () (if downwards? (go-down) (go-up))) (go-to-next-such-that move generic-context?))))

  (define-option-require opt decl)
    <= (((tree-is-buffer? t)) (tm-define-overloaded (kbd-extremal t forwards?) (with move (lambda () (if forwards? (go-end-line) (go-start-line))) (go-to-next-such-that move generic-context?))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (tree-is-buffer? t)) (tm-define-overloaded (kbd-extremal t forwards?) (with move (lambda () (if forwards? (go-end-line) (go-start-line))) (go-to-next-such-that move generic-context?))))

  (define-option-require opt decl)
    <= (((tree-is-buffer? t)) (tm-define-overloaded (kbd-incremental t downwards?) (with move (lambda () (if downwards? (go-page-down) (go-page-up))) (go-to-next-such-that move generic-context?))))
    => (define-option-match opt decl) <= ((lambda (t downwards?) (tree-is-buffer? t)) (tm-define-overloaded (kbd-incremental t downwards?) (with move (lambda () (if downwards? (go-page-down) (go-page-up))) (go-to-next-such-that move generic-context?))))

  (define-option-require opt decl)
    <= (((tree-is-buffer? t)) (tm-define-overloaded (kbd-space-bar t shift?) (insert " ")))
    => (define-option-match opt decl) <= ((lambda (t shift?) (tree-is-buffer? t)) (tm-define-overloaded (kbd-space-bar t shift?) (insert " ")))

  (define-option-require opt decl)
    <= (((tree-is-buffer? t)) (tm-define-overloaded (kbd-enter t shift?) (insert-return)))
    => (define-option-match opt decl) <= ((lambda (t shift?) (tree-is-buffer? t)) (tm-define-overloaded (kbd-enter t shift?) (insert-return)))

  (define-option-require opt decl)
    <= (((tree-is-buffer? t)) (tm-define-overloaded (kbd-control-enter t shift?) (noop)))
    => (define-option-match opt decl) <= ((lambda (t shift?) (tree-is-buffer? t)) (tm-define-overloaded (kbd-control-enter t shift?) (noop)))

  (define-option-require opt decl)
    <= (((tree-is-buffer? t)) (tm-define-overloaded (kbd-alternate-enter t shift?) (noop)))
    => (define-option-match opt decl) <= ((lambda (t shift?) (tree-is-buffer? t)) (tm-define-overloaded (kbd-alternate-enter t shift?) (noop)))

  (define-option-require opt decl)
    <= (((tree-is-buffer? t)) (tm-define-overloaded (kbd-remove t forwards?) (remove-text forwards?)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (tree-is-buffer? t)) (tm-define-overloaded (kbd-remove t forwards?) (remove-text forwards?)))

  (define-option-require opt decl)
    <= (((and (tree-is-buffer? t) (with-any-selection?))) (tm-define-overloaded (kbd-remove t forwards?) (clipboard-cut "nowhere") (clipboard-clear "nowhere")))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (and (tree-is-buffer? t) (with-any-selection?))) (tm-define-overloaded (kbd-remove t forwards?) (clipboard-cut "nowhere") (clipboard-clear "nowhere")))

  (define-option-require opt decl)
    <= (((tree-is-buffer? t)) (tm-define-overloaded (kbd-variant t forwards?) (if (and (not (complete-try?)) forwards?) (with sh (kbd-system-rewrite (kbd-find-inv-binding (quote (kbd-alternate-tab)))) (set-message (quasiquote (concat "Use " (unquote sh) " in order to insert a tab")) "tab")))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (tree-is-buffer? t)) (tm-define-overloaded (kbd-variant t forwards?) (if (and (not (complete-try?)) forwards?) (with sh (kbd-system-rewrite (kbd-find-inv-binding (quote (kbd-alternate-tab)))) (set-message (quasiquote (concat "Use " (unquote sh) " in order to insert a tab")) "tab")))))

  (define-option-require opt decl)
    <= (((and (tree-in? t (quote (label reference pageref))) (cursor-inside? t))) (tm-define-overloaded (kbd-variant t forwards?) (if (complete-try?) (noop))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (and (tree-in? t (quote (label reference pageref))) (cursor-inside? t))) (tm-define-overloaded (kbd-variant t forwards?) (if (complete-try?) (noop))))

  (define-option-require opt decl)
    <= (((and (not (supports-db?)) (bib-cite-context? t))) (tm-define-overloaded (kbd-variant t forwards?) (with u (current-bib-file #t) (with ttxt (tree-ref t (cADr (cursor-path))) (if (or (url-none? u) (not ttxt)) (set-message "No completions" "You must add a bibliography file") (custom-complete (tm->tree (citekey-completions u ttxt))))))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (and (not (supports-db?)) (bib-cite-context? t))) (tm-define-overloaded (kbd-variant t forwards?) (with u (current-bib-file #t) (with ttxt (tree-ref t (cADr (cursor-path))) (if (or (url-none? u) (not ttxt)) (set-message "No completions" "You must add a bibliography file") (custom-complete (tm->tree (citekey-completions u ttxt))))))))

  (define-option-require opt decl)
    <= (((tree-is-buffer? t)) (tm-define-overloaded (kbd-alternate-variant t forwards?) (make-htab "5mm")))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (tree-is-buffer? t)) (tm-define-overloaded (kbd-alternate-variant t forwards?) (make-htab "5mm")))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (reference pageref hlink locus ornament)))) (tm-define-overloaded (focus-has-preferences? t) #t))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (reference pageref hlink locus ornament)))) (tm-define-overloaded (focus-has-preferences? t) #t))

  (define-option-require opt decl)
    <= (((document-context? t)) (tm-define-overloaded (traverse-vertical t downwards?) (with move (if downwards? go-to-next-tag go-to-previous-tag) (move (quote document)))))
    => (define-option-match opt decl) <= ((lambda (t downwards?) (document-context? t)) (tm-define-overloaded (traverse-vertical t downwards?) (with move (if downwards? go-to-next-tag go-to-previous-tag) (move (quote document)))))

  (define-option-require opt decl)
    <= (((structured-horizontal? t)) (tm-define-overloaded (structured-insert-horizontal t forwards?) (when (tree->path t #:down) (insert-argument-at (tree->path t #:down) forwards?))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (structured-horizontal? t)) (tm-define-overloaded (structured-insert-horizontal t forwards?) (when (tree->path t #:down) (insert-argument-at (tree->path t #:down) forwards?))))

  (define-option-require opt decl)
    <= (((structured-horizontal? t)) (tm-define-overloaded (structured-remove-horizontal t forwards?) (when (tree->path t #:down) (remove-argument-at (tree->path t #:down) forwards?))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (structured-horizontal? t)) (tm-define-overloaded (structured-remove-horizontal t forwards?) (when (tree->path t #:down) (remove-argument-at (tree->path t #:down) forwards?))))

  (define-option-require opt decl)
    <= (((structured-horizontal? t)) (tm-define-overloaded (structured-horizontal t forwards?) (with-focus-after t (with move (if forwards? path-next-argument path-previous-argument) (with p (move (root-tree) (tree->path (tree-down t))) (if (nnull? p) (go-to p)))))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (structured-horizontal? t)) (tm-define-overloaded (structured-horizontal t forwards?) (with-focus-after t (with move (if forwards? path-next-argument path-previous-argument) (with p (move (root-tree) (tree->path (tree-down t))) (if (nnull? p) (go-to p)))))))

  (define-option-require opt decl)
    <= (((structured-horizontal? t)) (tm-define-overloaded (structured-inner-extremal t forwards?) (with-focus-after t (tree-go-to t #:down (if forwards? #:end #:start)))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (structured-horizontal? t)) (tm-define-overloaded (structured-inner-extremal t forwards?) (with-focus-after t (tree-go-to t #:down (if forwards? #:end #:start)))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote tree))) (tm-define-overloaded (structured-insert-horizontal t forwards?) (if (== (tree-down-index t) 0) (set! t (tree-up t))) (if (== (tm-car t) (quote tree)) (with pos (tree-down-index t) (if forwards? (set! pos (1+ pos))) (tree-insert! t pos (quote (""))) (tree-go-to t pos 0)))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (tree-is? t (quote tree))) (tm-define-overloaded (structured-insert-horizontal t forwards?) (if (== (tree-down-index t) 0) (set! t (tree-up t))) (if (== (tm-car t) (quote tree)) (with pos (tree-down-index t) (if forwards? (set! pos (1+ pos))) (tree-insert! t pos (quote (""))) (tree-go-to t pos 0)))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote tree))) (tm-define-overloaded (structured-remove-horizontal t forwards?) (if (== (tree-down-index t) 0) (set! t (tree-up t))) (if (== (tm-car t) (quote tree)) (with pos (tree-down-index t) (cond (forwards? (tree-remove! t pos 1) (if (== pos (tree-arity t)) (tree-go-to t #:end) (tree-go-to t pos #:start))) ((== pos 1) (tree-go-to t 0 #:end)) (else (tree-remove! t (- pos 1) 1)))))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (tree-is? t (quote tree))) (tm-define-overloaded (structured-remove-horizontal t forwards?) (if (== (tree-down-index t) 0) (set! t (tree-up t))) (if (== (tm-car t) (quote tree)) (with pos (tree-down-index t) (cond (forwards? (tree-remove! t pos 1) (if (== pos (tree-arity t)) (tree-go-to t #:end) (tree-go-to t pos #:start))) ((== pos 1) (tree-go-to t 0 #:end)) (else (tree-remove! t (- pos 1) 1)))))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote tree))) (tm-define-overloaded (structured-insert-vertical t downwards?) (if downwards? (if (== (tree-down-index t) 0) (with pos (tree-arity t) (tree-insert! t pos (quote (""))) (tree-go-to t pos 0)) (begin (set! t (tree-down t)) (tree-set! t (quasiquote (tree (unquote t) ""))) (tree-go-to t 1 0))) (begin (if (!= (tree-down-index t) 0) (set! t (tree-down t))) (tree-set! t (quasiquote (tree "" (unquote t)))) (tree-go-to t 0 0)))))
    => (define-option-match opt decl) <= ((lambda (t downwards?) (tree-is? t (quote tree))) (tm-define-overloaded (structured-insert-vertical t downwards?) (if downwards? (if (== (tree-down-index t) 0) (with pos (tree-arity t) (tree-insert! t pos (quote (""))) (tree-go-to t pos 0)) (begin (set! t (tree-down t)) (tree-set! t (quasiquote (tree (unquote t) ""))) (tree-go-to t 1 0))) (begin (if (!= (tree-down-index t) 0) (set! t (tree-down t))) (tree-set! t (quasiquote (tree "" (unquote t)))) (tree-go-to t 0 0)))))

  (define-option-require opt decl)
    <= (((tree-is? t* (quote tree))) (tm-define-overloaded (structured-horizontal t* forwards?) (let* ((t (branch-active t*)) (i (tree-down-index t))) (cond ((and (not forwards?) (> i 1)) (branch-go-to t (- i 1) #:end)) ((and forwards? (!= i 0) (< i (- (tree-arity t) 1))) (branch-go-to t (+ i 1) #:start))))))
    => (define-option-match opt decl) <= ((lambda (t* forwards?) (tree-is? t* (quote tree))) (tm-define-overloaded (structured-horizontal t* forwards?) (let* ((t (branch-active t*)) (i (tree-down-index t))) (cond ((and (not forwards?) (> i 1)) (branch-go-to t (- i 1) #:end)) ((and forwards? (!= i 0) (< i (- (tree-arity t) 1))) (branch-go-to t (+ i 1) #:start))))))

  (define-option-require opt decl)
    <= (((tree-is? t* (quote tree))) (tm-define-overloaded (structured-vertical t* downwards?) (let* ((t (branch-active t*)) (i (tree-down-index t))) (cond ((and (not downwards?) (!= i 0)) (tree-go-to t 0 #:end)) ((and downwards? (== (tree-down-index t*) 0)) (branch-go-to t* (quotient (tree-arity t*) 2) #:start))))))
    => (define-option-match opt decl) <= ((lambda (t* downwards?) (tree-is? t* (quote tree))) (tm-define-overloaded (structured-vertical t* downwards?) (let* ((t (branch-active t*)) (i (tree-down-index t))) (cond ((and (not downwards?) (!= i 0)) (tree-go-to t 0 #:end)) ((and downwards? (== (tree-down-index t*) 0)) (branch-go-to t* (quotient (tree-arity t*) 2) #:start))))))

  (define-option-require opt decl)
    <= (((tree-is? t* (quote tree))) (tm-define-overloaded (structured-extremal t* forwards?) (let* ((t (branch-active t*)) (i (tree-down-index t))) (cond ((not forwards?) (branch-go-to t 1 #:start)) (forwards? (branch-go-to t #:last #:end))))))
    => (define-option-match opt decl) <= ((lambda (t* forwards?) (tree-is? t* (quote tree))) (tm-define-overloaded (structured-extremal t* forwards?) (let* ((t (branch-active t*)) (i (tree-down-index t))) (cond ((not forwards?) (branch-go-to t 1 #:start)) (forwards? (branch-go-to t #:last #:end))))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote tree))) (tm-define-overloaded (structured-incremental t downwards?) (go-to-repeat (if downwards? structured-down structured-up))))
    => (define-option-match opt decl) <= ((lambda (t downwards?) (tree-is? t (quote tree))) (tm-define-overloaded (structured-incremental t downwards?) (go-to-repeat (if downwards? structured-down structured-up))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Selects word @w in tree @t, more or less around column @col.") (tm-define-overloaded (select-word w t col) (let* ((st (tree->string t)) (pos (- col (string-length w))) (beg (string-contains st w (max 0 pos)))) (if beg (with p (tree->path t) (go-to (rcons p beg)) (selection-set-start) (go-to (rcons p (+ beg (string-length w)))) (selection-set-end))) beg)))
   => ((quote select-word) #:synopsis (quote ("Selects word @w in tree @t, more or less around column @col.")))
 => cons <> cur-props
   => cur-props => (((quote select-word) #:synopsis (quote ("Selects word @w in tree @t, more or less around column @col."))))

(property-set! var prop what conds*)
  <= (select-word #:synopsis ("Selects word @w in tree @t, more or less around column @col.") ())

  (define-option-require opt decl)
    <= (((== l "action")) (tm-define-overloaded (standard-parameters l) (list "locus-color")))
    => (define-option-match opt decl) <= ((lambda (l) (== l "action")) (tm-define-overloaded (standard-parameters l) (list "locus-color")))

  (define-option-require opt decl)
    <= (((== l "locus")) (tm-define-overloaded (standard-parameters l) (list "locus-color" "visited-color")))
    => (define-option-match opt decl) <= ((lambda (l) (== l "locus")) (tm-define-overloaded (standard-parameters l) (list "locus-color" "visited-color")))

  (define-option-require opt decl)
    <= (((== l "ornament")) (tm-define-overloaded (standard-parameters l) (list "ornament-shape" "ornament-title-style" "ornament-border" "ornament-hpadding" "ornament-vpadding" "ornament-color" "ornament-extra-color" "ornament-sunny-color" "ornament-shadow-color")))
    => (define-option-match opt decl) <= ((lambda (l) (== l "ornament")) (tm-define-overloaded (standard-parameters l) (list "ornament-shape" "ornament-title-style" "ornament-border" "ornament-hpadding" "ornament-vpadding" "ornament-color" "ornament-extra-color" "ornament-sunny-color" "ornament-shadow-color")))

  (define-option-require opt decl)
    <= (((in? l (quote ("reference" "pageref" "label" "tag")))) (tm-define-overloaded (standard-parameters l) (list)))
    => (define-option-match opt decl) <= ((lambda (l) (in? l (quote ("reference" "pageref" "label" "tag")))) (tm-define-overloaded (standard-parameters l) (list)))

  (define-option-require opt decl)
    <= (((in? (if (string? l) l (symbol->string l)) (quote ("reference" "pageref" "hlink")))) (tm-define-overloaded (search-parameters l) (standard-parameters "locus")))
    => (define-option-match opt decl) <= ((lambda (l) (in? (if (string? l) l (symbol->string l)) (quote ("reference" "pageref" "hlink")))) (tm-define-overloaded (search-parameters l) (standard-parameters "locus")))

  (define-option-require opt decl)
    <= (((== l "ornament-shape")) (tm-define-overloaded (parameter-choice-list l) (list "classic" "rounded" "angular" "cartoon")))
    => (define-option-match opt decl) <= ((lambda (l) (== l "ornament-shape")) (tm-define-overloaded (parameter-choice-list l) (list "classic" "rounded" "angular" "cartoon")))

  (define-option-require opt decl)
    <= (((== l "ornament-title-style")) (tm-define-overloaded (parameter-choice-list l) (list "classic" "top left" "top center" "top right" "bottom left" "bottom center" "bottom right")))
    => (define-option-match opt decl) <= ((lambda (l) (== l "ornament-title-style")) (tm-define-overloaded (parameter-choice-list l) (list "classic" "top left" "top center" "top right" "bottom left" "bottom center" "bottom right")))

  (define-option-require opt decl)
    <= (((tree-is-buffer? t)) (tm-define-overloaded (label-insert t) (make (quote label))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is-buffer? t)) (tm-define-overloaded (label-insert t) (make (quote label))))

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (make-thumbnails) (user-url "Picture directory" "directory" (lambda (dir) (let* ((find (url-append dir (thumbnail-suffixes))) (files (url->list (url-expand (url-complete find "r")))) (base (buffer-master)) (rel-files (map (lambda (x) (url-delta base x)) files))) (if (nnull? rel-files) (make-thumbnails-sub rel-files)))))))
    => ((quote make-thumbnails) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote make-thumbnails) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (make-thumbnails #:interactive (#t) ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Insert a marginal note.") (tm-define-overloaded (make-marginal-note) (wrap-selection-small (insert-go-to (quasiquote (inactive (marginal-note "normal" "c" ""))) (quote (0 2 0))))))
   => ((quote make-marginal-note) #:synopsis (quote ("Insert a marginal note.")))
 => cons <> cur-props
   => cur-props => (((quote make-marginal-note) #:synopsis (quote ("Insert a marginal note."))))

(property-set! var prop what conds*)
  <= (make-marginal-note #:synopsis ("Insert a marginal note.") ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" test-marginal-note-hpos?) (tm-define-overloaded (set-marginal-note-hpos hp) (and-with t (tree-innermost (quote marginal-note) #t) (tree-set t 0 hp))))
    => ((quote set-marginal-note-hpos) #:check-mark (list "v" test-marginal-note-hpos?))
 => cons <> cur-props
    => cur-props => (((quote set-marginal-note-hpos) #:check-mark (list "v" test-marginal-note-hpos?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set the horizontal position of the marginal note to @hp.") (tm-define-overloaded (set-marginal-note-hpos hp) (and-with t (tree-innermost (quote marginal-note) #t) (tree-set t 0 hp))))
   => ((quote set-marginal-note-hpos) #:synopsis (quote ("Set the horizontal position of the marginal note to @hp.")))
 => cons <> cur-props
   => cur-props => (((quote set-marginal-note-hpos) #:synopsis (quote ("Set the horizontal position of the marginal note to @hp."))) ((quote set-marginal-note-hpos) #:check-mark (list "v" test-marginal-note-hpos?)))

(property-set! var prop what conds*)
  <= (set-marginal-note-hpos #:synopsis ("Set the horizontal position of the marginal note to @hp.") ())

(property-set! var prop what conds*)
  <= (set-marginal-note-hpos #:check-mark ("v" #<procedure test-marginal-note-hpos? (hp)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" test-marginal-note-valign?) (tm-define-overloaded (set-marginal-note-valign va) (and-with t (tree-innermost (quote marginal-note) #t) (tree-set t 1 va))))
    => ((quote set-marginal-note-valign) #:check-mark (list "v" test-marginal-note-valign?))
 => cons <> cur-props
    => cur-props => (((quote set-marginal-note-valign) #:check-mark (list "v" test-marginal-note-valign?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set the vertical alignment of the marginal note to @va.") (tm-define-overloaded (set-marginal-note-valign va) (and-with t (tree-innermost (quote marginal-note) #t) (tree-set t 1 va))))
   => ((quote set-marginal-note-valign) #:synopsis (quote ("Set the vertical alignment of the marginal note to @va.")))
 => cons <> cur-props
   => cur-props => (((quote set-marginal-note-valign) #:synopsis (quote ("Set the vertical alignment of the marginal note to @va."))) ((quote set-marginal-note-valign) #:check-mark (list "v" test-marginal-note-valign?)))

(property-set! var prop what conds*)
  <= (set-marginal-note-valign #:synopsis ("Set the vertical alignment of the marginal note to @va.") ())

(property-set! var prop what conds*)
  <= (set-marginal-note-valign #:check-mark ("v" #<procedure test-marginal-note-valign? (va)>) ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make an insertion of type @s.") (tm-define-overloaded (make-insertion s) (with pos (if (== s "float") "tbh" "") (insert-go-to (list (quote float) s pos (list (quote document) "")) (list 2 0 0)))))
   => ((quote make-insertion) #:synopsis (quote ("Make an insertion of type @s.")))
 => cons <> cur-props
   => cur-props => (((quote make-insertion) #:synopsis (quote ("Make an insertion of type @s."))))

(property-set! var prop what conds*)
  <= (make-insertion #:synopsis ("Make an insertion of type @s.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Allow/disallow the position @what for innermost float.") (tm-define-overloaded (insertion-positioning what flag) (and-with t (tree-innermost any-float? #t) (let ((op (if flag string-union string-minus)) (st (tree-ref t 1))) (tree-set! st (op (tree->string st) what))))))
   => ((quote insertion-positioning) #:synopsis (quote ("Allow/disallow the position @what for innermost float.")))
 => cons <> cur-props
   => cur-props => (((quote insertion-positioning) #:synopsis (quote ("Allow/disallow the position @what for innermost float."))))

(property-set! var prop what conds*)
  <= (insertion-positioning #:synopsis ("Allow/disallow the position @what for innermost float.") ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" test-insertion-positioning?) (tm-define-overloaded (toggle-insertion-positioning what) (insertion-positioning what (not-test-insertion-positioning? what))))
    => ((quote toggle-insertion-positioning) #:check-mark (list "v" test-insertion-positioning?))
 => cons <> cur-props
    => cur-props => (((quote toggle-insertion-positioning) #:check-mark (list "v" test-insertion-positioning?)))

(property-set! var prop what conds*)
  <= (toggle-insertion-positioning #:check-mark ("v" #<procedure test-insertion-positioning? (what)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" not-test-insertion-positioning?) (tm-define-overloaded (toggle-insertion-positioning-not s) (toggle-insertion-positioning s)))
    => ((quote toggle-insertion-positioning-not) #:check-mark (list "v" not-test-insertion-positioning?))
 => cons <> cur-props
    => cur-props => (((quote toggle-insertion-positioning-not) #:check-mark (list "v" not-test-insertion-positioning?)))

(property-set! var prop what conds*)
  <= (toggle-insertion-positioning-not #:check-mark ("v" #<procedure not-test-insertion-positioning? (s)>) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (display-balloon body balloon halign valign extents) (with (x1 y1 x2 y2) (tree-bounding-rectangle body) (let* ((zf (get-window-zoom-factor)) (sf (/ 5.0 zf)) (balloon* (quasiquote (with "magnification" (unquote (number->string zf)) (unquote balloon)))) (w (widget-texmacs-output balloon* (quote (style "generic")))) (ww (integer-floor (/ (tree->number (tree-ref extents 0)) sf))) (wh (integer-floor (/ (tree->number (tree-ref extents 1)) sf))) (ha (tree->stree halign)) (va (tree->stree valign)) (x (cond ((== ha "Left") (- (- x1 ww) (* 3 256))) ((== ha "left") x1) ((== ha "center") (quotient (+ x1 x2 (- ww)) 2)) ((== ha "right") (- (- x2 ww) (* 3 256))) ((== ha "Right") x2) (else x1))) (y (cond ((== va "Bottom") (- y1 (* 5 256))) ((== va "bottom") (+ y1 wh)) ((== va "center") (quotient (+ y1 y2 wh) 2)) ((== va "top") y2) ((== va "Top") (+ y2 wh (* 5 256))) (else (- y1 (* 5 256)))))) (show-balloon w x y)))))
    => ((quote display-balloon) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote display-balloon) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (display-balloon #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (display-balloon* body balloon halign valign extents) (with (mx my) (get-mouse-position) (let* ((zf (get-window-zoom-factor)) (sf (/ 5.0 zf)) (balloon* (quasiquote (with "magnification" (unquote (number->string zf)) (unquote balloon)))) (w (widget-texmacs-output balloon* (quote (style "generic")))) (ww (integer-floor (/ (tree->number (tree-ref extents 0)) sf))) (wh (integer-floor (/ (tree->number (tree-ref extents 1)) sf))) (ha (tree->stree halign)) (va (tree->stree valign)) (x (cond ((in? ha (list "Left" "left")) (- (- mx ww) (* 3 256))) ((== ha "center") (+ (- mx (quotient ww 2)) (* 5 256))) ((in? ha (list "right" "Right")) (+ mx (* 10 256))) (else (+ mx (* 3 256))))) (y (cond ((in? va (list "Bottom" "bottom")) (- my (* 16 256))) ((== va "center") (- (+ my (quotient wh 2)) (* 8 256))) ((in? va (list "top" "Top")) (+ my wh (* 5 256))) (else (- my (* 5 256)))))) (show-balloon w x y)))))
    => ((quote display-balloon*) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote display-balloon*) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (display-balloon* #:secure (#t) ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Insert a balloon.") (tm-define-overloaded (make-balloon) (wrap-selection-small (insert-go-to (quasiquote (inactive (mouse-over-balloon "" "" "left" "Bottom"))) (quote (0 0 0))))))
   => ((quote make-balloon) #:synopsis (quote ("Insert a balloon.")))
 => cons <> cur-props
   => cur-props => (((quote make-balloon) #:synopsis (quote ("Insert a balloon."))))

(property-set! var prop what conds*)
  <= (make-balloon #:synopsis ("Insert a balloon.") ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" test-balloon-halign?) (tm-define-overloaded (set-balloon-halign ha) (and-with t (tree-innermost balloon-context? #t) (tree-set t 2 ha))))
    => ((quote set-balloon-halign) #:check-mark (list "v" test-balloon-halign?))
 => cons <> cur-props
    => cur-props => (((quote set-balloon-halign) #:check-mark (list "v" test-balloon-halign?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set the horizontal alignment of the marginal note to @ha.") (tm-define-overloaded (set-balloon-halign ha) (and-with t (tree-innermost balloon-context? #t) (tree-set t 2 ha))))
   => ((quote set-balloon-halign) #:synopsis (quote ("Set the horizontal alignment of the marginal note to @ha.")))
 => cons <> cur-props
   => cur-props => (((quote set-balloon-halign) #:synopsis (quote ("Set the horizontal alignment of the marginal note to @ha."))) ((quote set-balloon-halign) #:check-mark (list "v" test-balloon-halign?)))

(property-set! var prop what conds*)
  <= (set-balloon-halign #:synopsis ("Set the horizontal alignment of the marginal note to @ha.") ())

(property-set! var prop what conds*)
  <= (set-balloon-halign #:check-mark ("v" #<procedure test-balloon-halign? (ha)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" test-balloon-valign?) (tm-define-overloaded (set-balloon-valign va) (and-with t (tree-innermost balloon-context? #t) (tree-set t 3 va))))
    => ((quote set-balloon-valign) #:check-mark (list "v" test-balloon-valign?))
 => cons <> cur-props
    => cur-props => (((quote set-balloon-valign) #:check-mark (list "v" test-balloon-valign?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set the vertical alignment of the marginal note to @va.") (tm-define-overloaded (set-balloon-valign va) (and-with t (tree-innermost balloon-context? #t) (tree-set t 3 va))))
   => ((quote set-balloon-valign) #:synopsis (quote ("Set the vertical alignment of the marginal note to @va.")))
 => cons <> cur-props
   => cur-props => (((quote set-balloon-valign) #:synopsis (quote ("Set the vertical alignment of the marginal note to @va."))) ((quote set-balloon-valign) #:check-mark (list "v" test-balloon-valign?)))

(property-set! var prop what conds*)
  <= (set-balloon-valign #:synopsis ("Set the vertical alignment of the marginal note to @va.") ())

(property-set! var prop what conds*)
  <= (set-balloon-valign #:check-mark ("v" #<procedure test-balloon-valign? (va)>) ())

  (define-option-mode opt decl)
    <= ((search-mode?) (tm-define-overloaded (keyboard-press key time) (with cmd (key-press-command (string-append "search " key)) (cond (cmd (cmd)) ((key-press-search key) (noop)) (else (key-press key))))))
    (ctx-add-condition! 0 (car opt)) => cur-conds => (search-mode?)

  (define-option-mode opt decl)
    <= ((replace-mode?) (tm-define-overloaded (keyboard-press key time) (with cmd (key-press-command (string-append "replace " key)) (cond (cmd (cmd)) ((key-press-replace key) (noop)) (else (key-press key))))))
    (ctx-add-condition! 0 (car opt)) => cur-conds => (replace-mode?)

  (define-option-mode opt decl)
    <= ((spell-mode?) (tm-define-overloaded (keyboard-press key time) (with cmd (key-press-command (string-append "spell " key)) (cond (cmd (cmd)) ((key-press-spell key) (noop)) (else (key-press key))))))
    (ctx-add-condition! 0 (car opt)) => cur-conds => (spell-mode?)

  (define-option-mode opt decl)
    <= ((complete-mode?) (tm-define-overloaded (keyboard-press key time) (with cmd (key-press-command (string-append "complete " key)) (cond (cmd (cmd)) ((key-press-complete key) (noop)) (else (key-press key))))))
    (ctx-add-condition! 0 (car opt)) => cur-conds => (complete-mode?)

  (define-option-mode opt decl)
    <= ((remote-control-mode?) (tm-define-overloaded (keyboard-press key time) (if (ahash-ref remote-control-remap key) (begin (key-press (ahash-ref remote-control-remap key))) (key-press key))))
    (ctx-add-condition! 0 (car opt)) => cur-conds => (remote-control-mode?)

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (focus-open-search-tool t) (noop)))
    => ((quote focus-open-search-tool) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote focus-open-search-tool) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (focus-open-search-tool #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" has-no-style?) (tm-define-overloaded (set-no-style) (set-style-list (quote ()))))
    => ((quote set-no-style) #:check-mark (list "v" has-no-style?))
 => cons <> cur-props
    => cur-props => (((quote set-no-style) #:check-mark (list "v" has-no-style?)))

(property-set! var prop what conds*)
  <= (set-no-style #:check-mark ("v" #<procedure has-no-style? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:balloon)  (style-get-documentation) (tm-define-overloaded (set-main-style style) (let* ((old (get-style-list)) (new (if (null? old) (list style) (cons style (cdr old))))) (set-style-list new))))
    => ((quote set-main-style) #:balloon (list style-get-documentation))
 => cons <> cur-props
    => cur-props => (((quote set-main-style) #:balloon (list style-get-documentation)))

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" has-main-style?) (tm-define-overloaded (set-main-style style) (let* ((old (get-style-list)) (new (if (null? old) (list style) (cons style (cdr old))))) (set-style-list new))))
    => ((quote set-main-style) #:check-mark (list "v" has-main-style?))
 => cons <> cur-props
    => cur-props => (((quote set-main-style) #:check-mark (list "v" has-main-style?)) ((quote set-main-style) #:balloon (list style-get-documentation)))

  (define-option-default opt decl)
    <= ((style "generic") (tm-define-overloaded (set-main-style style) (let* ((old (get-style-list)) (new (if (null? old) (list style) (cons style (cdr old))))) (set-style-list new))))
    => cons <> cur-props <= ((quote set-main-style) (quote (#:default style)) (lambda () "generic"))
    => cur-props => (((quote set-main-style) (quote (#:default style)) (lambda () "generic")) ((quote set-main-style) #:check-mark (list "v" has-main-style?)) ((quote set-main-style) #:balloon (list style-get-documentation)))

  (define-option-argument opt decl)
    <= ((style "Main document style") (tm-define-overloaded (set-main-style style) (let* ((old (get-style-list)) (new (if (null? old) (list style) (cons style (cdr old))))) (set-style-list new))))
    => cons <> cur-props <= ((quote set-main-style) #:arguments (quote (style)))
    => cons <> cur-props <= ((quote set-main-style) (quote (#:argument style)) (quote ("Main document style")))
    => cur-props => (((quote set-main-style) (quote (#:argument style)) (quote ("Main document style"))) ((quote set-main-style) #:arguments (quote (style))) ((quote set-main-style) (quote (#:default style)) (lambda () "generic")) ((quote set-main-style) #:check-mark (list "v" has-main-style?)) ((quote set-main-style) #:balloon (list style-get-documentation)))

(property-set! var prop what conds*)
  <= (set-main-style (#:argument style) ("Main document style") ())

(property-set! var prop what conds*)
  <= (set-main-style #:arguments (style) ())

(property-set! var prop what conds*)
  <= (set-main-style (#:default style) #<procedure #f ()> ())

(property-set! var prop what conds*)
  <= (set-main-style #:check-mark ("v" #<procedure has-main-style? (style)>) ())

(property-set! var prop what conds*)
  <= (set-main-style #:balloon (#<procedure style-get-documentation (style)>) ())

  ((define-property* which)  opt decl)
    <= ((#:balloon)  (style-get-documentation) (tm-define-overloaded (add-style-package pack) (set-style-list (append (get-style-list) (list pack)))))
    => ((quote add-style-package) #:balloon (list style-get-documentation))
 => cons <> cur-props
    => cur-props => (((quote add-style-package) #:balloon (list style-get-documentation)))

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" has-style-package?) (tm-define-overloaded (add-style-package pack) (set-style-list (append (get-style-list) (list pack)))))
    => ((quote add-style-package) #:check-mark (list "v" has-style-package?))
 => cons <> cur-props
    => cur-props => (((quote add-style-package) #:check-mark (list "v" has-style-package?)) ((quote add-style-package) #:balloon (list style-get-documentation)))

  (define-option-argument opt decl)
    <= ((pack "Add package") (tm-define-overloaded (add-style-package pack) (set-style-list (append (get-style-list) (list pack)))))
    => cons <> cur-props <= ((quote add-style-package) #:arguments (quote (pack)))
    => cons <> cur-props <= ((quote add-style-package) (quote (#:argument pack)) (quote ("Add package")))
    => cur-props => (((quote add-style-package) (quote (#:argument pack)) (quote ("Add package"))) ((quote add-style-package) #:arguments (quote (pack))) ((quote add-style-package) #:check-mark (list "v" has-style-package?)) ((quote add-style-package) #:balloon (list style-get-documentation)))

(property-set! var prop what conds*)
  <= (add-style-package (#:argument pack) ("Add package") ())

(property-set! var prop what conds*)
  <= (add-style-package #:arguments (pack) ())

(property-set! var prop what conds*)
  <= (add-style-package #:check-mark ("v" #<procedure has-style-package? (pack)>) ())

(property-set! var prop what conds*)
  <= (add-style-package #:balloon (#<procedure style-get-documentation (style)>) ())

  ((define-property* which)  opt decl)
    <= ((#:balloon)  (style-get-documentation) (tm-define-overloaded (remove-style-package pack) (set-style-list (list-difference (get-style-list) (list pack)))))
    => ((quote remove-style-package) #:balloon (list style-get-documentation))
 => cons <> cur-props
    => cur-props => (((quote remove-style-package) #:balloon (list style-get-documentation)))

  (define-option-proposals opt decl)
    <= ((pack (with l (get-style-list) (if (null? l) l (cdr l)))) (tm-define-overloaded (remove-style-package pack) (set-style-list (list-difference (get-style-list) (list pack)))))
    => cons <> cur-props <= ((quote remove-style-package) (quote (#:proposals pack)) (lambda () (with l (get-style-list) (if (null? l) l (cdr l)))))
    => cur-props => (((quote remove-style-package) (quote (#:proposals pack)) (lambda () (with l (get-style-list) (if (null? l) l (cdr l))))) ((quote remove-style-package) #:balloon (list style-get-documentation)))

  (define-option-argument opt decl)
    <= ((pack "Remove package") (tm-define-overloaded (remove-style-package pack) (set-style-list (list-difference (get-style-list) (list pack)))))
    => cons <> cur-props <= ((quote remove-style-package) #:arguments (quote (pack)))
    => cons <> cur-props <= ((quote remove-style-package) (quote (#:argument pack)) (quote ("Remove package")))
    => cur-props => (((quote remove-style-package) (quote (#:argument pack)) (quote ("Remove package"))) ((quote remove-style-package) #:arguments (quote (pack))) ((quote remove-style-package) (quote (#:proposals pack)) (lambda () (with l (get-style-list) (if (null? l) l (cdr l))))) ((quote remove-style-package) #:balloon (list style-get-documentation)))

(property-set! var prop what conds*)
  <= (remove-style-package (#:argument pack) ("Remove package") ())

(property-set! var prop what conds*)
  <= (remove-style-package #:arguments (pack) ())

(property-set! var prop what conds*)
  <= (remove-style-package (#:proposals pack) #<procedure #f ()> ())

(property-set! var prop what conds*)
  <= (remove-style-package #:balloon (#<procedure style-get-documentation (style)>) ())

  ((define-property* which)  opt decl)
    <= ((#:balloon)  (style-get-documentation) (tm-define-overloaded (toggle-style-package pack) (if (has-style-package? pack) (remove-style-package pack) (add-style-package pack))))
    => ((quote toggle-style-package) #:balloon (list style-get-documentation))
 => cons <> cur-props
    => cur-props => (((quote toggle-style-package) #:balloon (list style-get-documentation)))

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" has-style-package?) (tm-define-overloaded (toggle-style-package pack) (if (has-style-package? pack) (remove-style-package pack) (add-style-package pack))))
    => ((quote toggle-style-package) #:check-mark (list "v" has-style-package?))
 => cons <> cur-props
    => cur-props => (((quote toggle-style-package) #:check-mark (list "v" has-style-package?)) ((quote toggle-style-package) #:balloon (list style-get-documentation)))

  (define-option-argument opt decl)
    <= ((pack "Toggle package") (tm-define-overloaded (toggle-style-package pack) (if (has-style-package? pack) (remove-style-package pack) (add-style-package pack))))
    => cons <> cur-props <= ((quote toggle-style-package) #:arguments (quote (pack)))
    => cons <> cur-props <= ((quote toggle-style-package) (quote (#:argument pack)) (quote ("Toggle package")))
    => cur-props => (((quote toggle-style-package) (quote (#:argument pack)) (quote ("Toggle package"))) ((quote toggle-style-package) #:arguments (quote (pack))) ((quote toggle-style-package) #:check-mark (list "v" has-style-package?)) ((quote toggle-style-package) #:balloon (list style-get-documentation)))

(property-set! var prop what conds*)
  <= (toggle-style-package (#:argument pack) ("Toggle package") ())

(property-set! var prop what conds*)
  <= (toggle-style-package #:arguments (pack) ())

(property-set! var prop what conds*)
  <= (toggle-style-package #:check-mark ("v" #<procedure has-style-package? (pack)>) ())

(property-set! var prop what conds*)
  <= (toggle-style-package #:balloon (#<procedure style-get-documentation (style)>) ())

  (define-option-argument opt decl)
    <= ((master "file" "Master file") (tm-property-overloaded (project-attach master)))
    => cons <> cur-props <= ((quote project-attach) #:arguments (quote (master)))
    => cons <> cur-props <= ((quote project-attach) (quote (#:argument master)) (quote ("file" "Master file")))
    => cur-props => (((quote project-attach) (quote (#:argument master)) (quote ("file" "Master file"))) ((quote project-attach) #:arguments (quote (master))))

(property-set! var prop what conds*)
  <= (project-attach (#:argument master) ("file" "Master file") ())

(property-set! var prop what conds*)
  <= (project-attach #:arguments (master) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" in-preamble?) (tm-define-overloaded (toggle-preamble) (let ((new (if (string=? (get-env "preamble") "true") "false" "true"))) (init-env "preamble" new))))
    => ((quote toggle-preamble) #:check-mark (list "v" in-preamble?))
 => cons <> cur-props
    => cur-props => (((quote toggle-preamble) #:check-mark (list "v" in-preamble?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle preamble mode.") (tm-define-overloaded (toggle-preamble) (let ((new (if (string=? (get-env "preamble") "true") "false" "true"))) (init-env "preamble" new))))
   => ((quote toggle-preamble) #:synopsis (quote ("Toggle preamble mode.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-preamble) #:synopsis (quote ("Toggle preamble mode."))) ((quote toggle-preamble) #:check-mark (list "v" in-preamble?)))

(property-set! var prop what conds*)
  <= (toggle-preamble #:synopsis ("Toggle preamble mode.") ())

(property-set! var prop what conds*)
  <= (toggle-preamble #:check-mark ("v" #<procedure in-preamble? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" test-default?) (tm-define-overloaded (init-default . args) (for-each init-default-one args)))
    => ((quote init-default) #:check-mark (list "*" test-default?))
 => cons <> cur-props
    => cur-props => (((quote init-default) #:check-mark (list "*" test-default?)))

(property-set! var prop what conds*)
  <= (init-default #:check-mark ("*" #<procedure test-default? vals>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" test-init?) (tm-property-overloaded (init-env var val)))
    => ((quote init-env) #:check-mark (list "*" test-init?))
 => cons <> cur-props
    => cur-props => (((quote init-env) #:check-mark (list "*" test-init?)))

(property-set! var prop what conds*)
  <= (init-env #:check-mark ("*" #<procedure test-init? (var val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (init-interactive-env var) (interactive (lambda (s) (set-init-env var s)) (list (or (logic-ref env-var-description% var) var) "string" (get-init-env var)))))
    => ((quote init-interactive-env) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote init-interactive-env) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (init-interactive-env #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" test-init-true?) (tm-define-overloaded (toggle-init-env var) (with new (if (== (get-init-env var) "true") "false" "true") (init-default var) (delayed (when (!= new (get-init-env var)) (set-init-env var new))))))
    => ((quote toggle-init-env) #:check-mark (list "*" test-init-true?))
 => cons <> cur-props
    => cur-props => (((quote toggle-init-env) #:check-mark (list "*" test-init-true?)))

(property-set! var prop what conds*)
  <= (toggle-init-env #:check-mark ("*" #<procedure test-init-true? (var)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" test-default-document-language?) (tm-define-overloaded (set-default-document-language) (let* ((old (get-style-list)) (new (list-difference old supported-languages))) (when (!= new old) (set-style-list new)))))
    => ((quote set-default-document-language) #:check-mark (list "*" test-default-document-language?))
 => cons <> cur-props
    => cur-props => (((quote set-default-document-language) #:check-mark (list "*" test-default-document-language?)))

(property-set! var prop what conds*)
  <= (set-default-document-language #:check-mark ("*" #<procedure test-default-document-language? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" test-document-language?) (tm-define-overloaded (set-document-language lan) (let* ((old (get-style-list)) (rem (list-difference old supported-languages)) (new (append rem (if (== lan "english") (list) (list lan))))) (when (!= new old) (set-style-list new)))))
    => ((quote set-document-language) #:check-mark (list "*" test-document-language?))
 => cons <> cur-props
    => cur-props => (((quote set-document-language) #:check-mark (list "*" test-document-language?)))

(property-set! var prop what conds*)
  <= (set-document-language #:check-mark ("*" #<procedure test-document-language? (s)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" test-default-page-medium?) (tm-define-overloaded (init-default-page-medium) (init-default "page-medium") (notify-page-change)))
    => ((quote init-default-page-medium) #:check-mark (list "*" test-default-page-medium?))
 => cons <> cur-props
    => cur-props => (((quote init-default-page-medium) #:check-mark (list "*" test-default-page-medium?)))

(property-set! var prop what conds*)
  <= (init-default-page-medium #:check-mark ("*" #<procedure test-default-page-medium? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" test-page-medium?) (tm-define-overloaded (init-page-medium s) (init-env "page-medium" s) (notify-page-change)))
    => ((quote init-page-medium) #:check-mark (list "*" test-page-medium?))
 => cons <> cur-props
    => cur-props => (((quote init-page-medium) #:check-mark (list "*" test-page-medium?)))

(property-set! var prop what conds*)
  <= (init-page-medium #:check-mark ("*" #<procedure test-page-medium? (s)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" test-page-type?) (tm-define-overloaded (init-page-type s) (init-env "page-type" s) (init-default "page-width" "page-height") (notify-page-change)))
    => ((quote init-page-type) #:check-mark (list "*" test-page-type?))
 => cons <> cur-props
    => cur-props => (((quote init-page-type) #:check-mark (list "*" test-page-type?)))

(property-set! var prop what conds*)
  <= (init-page-type #:check-mark ("*" #<procedure test-page-type? (s)>) ())

  (define-option-argument opt decl)
    <= ((h "Page height") (tm-define-overloaded (init-page-size w h) (init-env "page-type" "user") (init-env "page-width" w) (init-env "page-height" h)))
    => cons <> cur-props <= ((quote init-page-size) #:arguments (quote (w h)))
    => cons <> cur-props <= ((quote init-page-size) (quote (#:argument h)) (quote ("Page height")))
    => cur-props => (((quote init-page-size) (quote (#:argument h)) (quote ("Page height"))) ((quote init-page-size) #:arguments (quote (w h))))

  (define-option-argument opt decl)
    <= ((w "Page width") (tm-define-overloaded (init-page-size w h) (init-env "page-type" "user") (init-env "page-width" w) (init-env "page-height" h)))
    => cons <> cur-props <= ((quote init-page-size) #:arguments (quote (w h)))
    => cons <> cur-props <= ((quote init-page-size) (quote (#:argument w)) (quote ("Page width")))
    => cur-props => (((quote init-page-size) (quote (#:argument w)) (quote ("Page width"))) ((quote init-page-size) #:arguments (quote (w h))) ((quote init-page-size) (quote (#:argument h)) (quote ("Page height"))) ((quote init-page-size) #:arguments (quote (w h))))

(property-set! var prop what conds*)
  <= (init-page-size (#:argument w) ("Page width") ())

(property-set! var prop what conds*)
  <= (init-page-size #:arguments (w h) ())

(property-set! var prop what conds*)
  <= (init-page-size (#:argument h) ("Page height") ())

(property-set! var prop what conds*)
  <= (init-page-size #:arguments (w h) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" test-default-page-orientation?) (tm-define-overloaded (init-default-page-orientation) (init-default "page-orientation") (notify-page-change)))
    => ((quote init-default-page-orientation) #:check-mark (list "*" test-default-page-orientation?))
 => cons <> cur-props
    => cur-props => (((quote init-default-page-orientation) #:check-mark (list "*" test-default-page-orientation?)))

(property-set! var prop what conds*)
  <= (init-default-page-orientation #:check-mark ("*" #<procedure test-default-page-orientation? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" test-page-orientation?) (tm-define-overloaded (init-page-orientation s) (init-env "page-orientation" s) (notify-page-change)))
    => ((quote init-page-orientation) #:check-mark (list "*" test-page-orientation?))
 => cons <> cur-props
    => cur-props => (((quote init-page-orientation) #:check-mark (list "*" test-page-orientation?)))

(property-set! var prop what conds*)
  <= (init-page-orientation #:check-mark ("*" #<procedure test-page-orientation? (s)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" test-default-page-rendering?) (tm-define-overloaded (init-default-page-rendering) (init-default "page-medium") (init-default "page-border") (init-default "page-packet") (init-default "page-offset") (notify-page-change)))
    => ((quote init-default-page-rendering) #:check-mark (list "*" test-default-page-rendering?))
 => cons <> cur-props
    => cur-props => (((quote init-default-page-rendering) #:check-mark (list "*" test-default-page-rendering?)))

(property-set! var prop what conds*)
  <= (init-default-page-rendering #:check-mark ("*" #<procedure test-default-page-rendering? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" test-page-rendering?) (tm-define-overloaded (init-page-rendering s) (save-zoom (get-init-page-rendering)) (cond ((== s "book") (init-env "page-medium" "paper") (init-env "page-border" "attached") (init-env "page-packet" "2") (init-env "page-offset" "1") (notify-page-change) (delayed (#:idle 25) (restore-zoom s))) ((== s "panorama") (init-env "page-medium" "paper") (init-env "page-packet" (number->string (panorama-packets))) (init-default "page-border") (init-default "page-offset") (notify-page-change) (delayed (#:idle 25) (fit-all-to-screen))) (else (init-env "page-medium" s) (init-default "page-border") (init-default "page-packet") (init-default "page-offset") (notify-page-change) (delayed (#:idle 25) (restore-zoom s))))))
    => ((quote init-page-rendering) #:check-mark (list "*" test-page-rendering?))
 => cons <> cur-props
    => cur-props => (((quote init-page-rendering) #:check-mark (list "*" test-page-rendering?)))

(property-set! var prop what conds*)
  <= (init-page-rendering #:check-mark ("*" #<procedure test-page-rendering? (s)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" visible-header-and-footer?) (tm-define-overloaded (toggle-visible-header-and-footer) (init-env "page-show-hf" (if (== (get-env "page-show-hf") "true") "false" "true"))))
    => ((quote toggle-visible-header-and-footer) #:check-mark (list "v" visible-header-and-footer?))
 => cons <> cur-props
    => cur-props => (((quote toggle-visible-header-and-footer) #:check-mark (list "v" visible-header-and-footer?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle visibility of headers and footers in 'page' paper mode.") (tm-define-overloaded (toggle-visible-header-and-footer) (init-env "page-show-hf" (if (== (get-env "page-show-hf") "true") "false" "true"))))
   => ((quote toggle-visible-header-and-footer) #:synopsis (quote ("Toggle visibility of headers and footers in 'page' paper mode.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-visible-header-and-footer) #:synopsis (quote ("Toggle visibility of headers and footers in 'page' paper mode."))) ((quote toggle-visible-header-and-footer) #:check-mark (list "v" visible-header-and-footer?)))

(property-set! var prop what conds*)
  <= (toggle-visible-header-and-footer #:synopsis ("Toggle visibility of headers and footers in 'page' paper mode.") ())

(property-set! var prop what conds*)
  <= (toggle-visible-header-and-footer #:check-mark ("v" #<procedure visible-header-and-footer? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" page-width-margin?) (tm-define-overloaded (toggle-page-width-margin) (init-env "page-width-margin" (if (page-width-margin?) "false" "true"))))
    => ((quote toggle-page-width-margin) #:check-mark (list "v" page-width-margin?))
 => cons <> cur-props
    => cur-props => (((quote toggle-page-width-margin) #:check-mark (list "v" page-width-margin?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle mode for determining margins from paragraph width.") (tm-define-overloaded (toggle-page-width-margin) (init-env "page-width-margin" (if (page-width-margin?) "false" "true"))))
   => ((quote toggle-page-width-margin) #:synopsis (quote ("Toggle mode for determining margins from paragraph width.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-page-width-margin) #:synopsis (quote ("Toggle mode for determining margins from paragraph width."))) ((quote toggle-page-width-margin) #:check-mark (list "v" page-width-margin?)))

(property-set! var prop what conds*)
  <= (toggle-page-width-margin #:synopsis ("Toggle mode for determining margins from paragraph width.") ())

(property-set! var prop what conds*)
  <= (toggle-page-width-margin #:check-mark ("v" #<procedure page-width-margin? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" not-page-screen-margin?) (tm-define-overloaded (toggle-page-screen-margin) (init-env "page-screen-margin" (if (not-page-screen-margin?) "true" "false"))))
    => ((quote toggle-page-screen-margin) #:check-mark (list "v" not-page-screen-margin?))
 => cons <> cur-props
    => cur-props => (((quote toggle-page-screen-margin) #:check-mark (list "v" not-page-screen-margin?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle mode for using special margins for screen editing.") (tm-define-overloaded (toggle-page-screen-margin) (init-env "page-screen-margin" (if (not-page-screen-margin?) "true" "false"))))
   => ((quote toggle-page-screen-margin) #:synopsis (quote ("Toggle mode for using special margins for screen editing.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-page-screen-margin) #:synopsis (quote ("Toggle mode for using special margins for screen editing."))) ((quote toggle-page-screen-margin) #:check-mark (list "v" not-page-screen-margin?)))

(property-set! var prop what conds*)
  <= (toggle-page-screen-margin #:synopsis ("Toggle mode for using special margins for screen editing.") ())

(property-set! var prop what conds*)
  <= (toggle-page-screen-margin #:check-mark ("v" #<procedure not-page-screen-margin? ()>) ())

  (define-option-argument opt decl)
    <= ((cmd "System command") (tm-property-overloaded (system cmd)))
    => cons <> cur-props <= ((quote system) #:arguments (quote (cmd)))
    => cons <> cur-props <= ((quote system) (quote (#:argument cmd)) (quote ("System command")))
    => cur-props => (((quote system) (quote (#:argument cmd)) (quote ("System command"))) ((quote system) #:arguments (quote (cmd))))

(property-set! var prop what conds*)
  <= (system (#:argument cmd) ("System command") ())

(property-set! var prop what conds*)
  <= (system #:arguments (cmd) ())

  (define-option-argument opt decl)
    <= ((cmd "Scheme command") (tm-property-overloaded (footer-eval cmd)))
    => cons <> cur-props <= ((quote footer-eval) #:arguments (quote (cmd)))
    => cons <> cur-props <= ((quote footer-eval) (quote (#:argument cmd)) (quote ("Scheme command")))
    => cur-props => (((quote footer-eval) (quote (#:argument cmd)) (quote ("Scheme command"))) ((quote footer-eval) #:arguments (quote (cmd))))

(property-set! var prop what conds*)
  <= (footer-eval (#:argument cmd) ("Scheme command") ())

(property-set! var prop what conds*)
  <= (footer-eval #:arguments (cmd) ())

  (define-option-proposals opt decl)
    <= ((cmd (cons "" (map symbol->string (get-interactive-function-list)))) (tm-define-overloaded (exec-interactive-command cmd) (interactive (eval (string->symbol cmd)))))
    => cons <> cur-props <= ((quote exec-interactive-command) (quote (#:proposals cmd)) (lambda () (cons "" (map symbol->string (get-interactive-function-list)))))
    => cur-props => (((quote exec-interactive-command) (quote (#:proposals cmd)) (lambda () (cons "" (map symbol->string (get-interactive-function-list))))))

  (define-option-argument opt decl)
    <= ((cmd "Interactive command") (tm-define-overloaded (exec-interactive-command cmd) (interactive (eval (string->symbol cmd)))))
    => cons <> cur-props <= ((quote exec-interactive-command) #:arguments (quote (cmd)))
    => cons <> cur-props <= ((quote exec-interactive-command) (quote (#:argument cmd)) (quote ("Interactive command")))
    => cur-props => (((quote exec-interactive-command) (quote (#:argument cmd)) (quote ("Interactive command"))) ((quote exec-interactive-command) #:arguments (quote (cmd))) ((quote exec-interactive-command) (quote (#:proposals cmd)) (lambda () (cons "" (map symbol->string (get-interactive-function-list))))))

(property-set! var prop what conds*)
  <= (exec-interactive-command (#:argument cmd) ("Interactive command") ())

(property-set! var prop what conds*)
  <= (exec-interactive-command #:arguments (cmd) ())

(property-set! var prop what conds*)
  <= (exec-interactive-command (#:proposals cmd) #<procedure #f ()> ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" visible-header?) (tm-define-overloaded (toggle-visible-header) (with val (not (visible-header?)) (if (== (windows-number) 1) (set-boolean-preference "header" val) (show-header val)))))
    => ((quote toggle-visible-header) #:check-mark (list "v" visible-header?))
 => cons <> cur-props
    => cur-props => (((quote toggle-visible-header) #:check-mark (list "v" visible-header?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle the visibility of the window's header.") (tm-define-overloaded (toggle-visible-header) (with val (not (visible-header?)) (if (== (windows-number) 1) (set-boolean-preference "header" val) (show-header val)))))
   => ((quote toggle-visible-header) #:synopsis (quote ("Toggle the visibility of the window's header.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-visible-header) #:synopsis (quote ("Toggle the visibility of the window's header."))) ((quote toggle-visible-header) #:check-mark (list "v" visible-header?)))

(property-set! var prop what conds*)
  <= (toggle-visible-header #:synopsis ("Toggle the visibility of the window's header.") ())

(property-set! var prop what conds*)
  <= (toggle-visible-header #:check-mark ("v" #<primitive-procedure visible-header?>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" visible-footer?) (tm-define-overloaded (toggle-visible-footer) (with val (not (visible-footer?)) (if (== (windows-number) 1) (set-boolean-preference "status bar" val) (show-footer val)))))
    => ((quote toggle-visible-footer) #:check-mark (list "v" visible-footer?))
 => cons <> cur-props
    => cur-props => (((quote toggle-visible-footer) #:check-mark (list "v" visible-footer?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle the visibility of the window's footer.") (tm-define-overloaded (toggle-visible-footer) (with val (not (visible-footer?)) (if (== (windows-number) 1) (set-boolean-preference "status bar" val) (show-footer val)))))
   => ((quote toggle-visible-footer) #:synopsis (quote ("Toggle the visibility of the window's footer.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-visible-footer) #:synopsis (quote ("Toggle the visibility of the window's footer."))) ((quote toggle-visible-footer) #:check-mark (list "v" visible-footer?)))

(property-set! var prop what conds*)
  <= (toggle-visible-footer #:synopsis ("Toggle the visibility of the window's footer.") ())

(property-set! var prop what conds*)
  <= (toggle-visible-footer #:check-mark ("v" #<primitive-procedure visible-footer?>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" visible-side-tools?) (tm-define-overloaded (toggle-visible-side-tools n) (with val (not (visible-side-tools? n)) (if (and (== (windows-number) 1) (== n 0)) (set-boolean-preference "side tools" val) (show-side-tools n val)))))
    => ((quote toggle-visible-side-tools) #:check-mark (list "v" visible-side-tools?))
 => cons <> cur-props
    => cur-props => (((quote toggle-visible-side-tools) #:check-mark (list "v" visible-side-tools?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle the visibility of the @n-th side tools.") (tm-define-overloaded (toggle-visible-side-tools n) (with val (not (visible-side-tools? n)) (if (and (== (windows-number) 1) (== n 0)) (set-boolean-preference "side tools" val) (show-side-tools n val)))))
   => ((quote toggle-visible-side-tools) #:synopsis (quote ("Toggle the visibility of the @n-th side tools.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-visible-side-tools) #:synopsis (quote ("Toggle the visibility of the @n-th side tools."))) ((quote toggle-visible-side-tools) #:check-mark (list "v" visible-side-tools?)))

(property-set! var prop what conds*)
  <= (toggle-visible-side-tools #:synopsis ("Toggle the visibility of the @n-th side tools.") ())

(property-set! var prop what conds*)
  <= (toggle-visible-side-tools #:check-mark ("v" #<primitive-procedure visible-side-tools?>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" visible-bottom-tools?) (tm-define-overloaded (toggle-visible-bottom-tools n) (with val (not (visible-bottom-tools? n)) (if (and (== (windows-number) 1) (== n 0)) (set-boolean-preference "bottom tools" val) (show-bottom-tools n val)))))
    => ((quote toggle-visible-bottom-tools) #:check-mark (list "v" visible-bottom-tools?))
 => cons <> cur-props
    => cur-props => (((quote toggle-visible-bottom-tools) #:check-mark (list "v" visible-bottom-tools?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle the visibility of the bottom tools.") (tm-define-overloaded (toggle-visible-bottom-tools n) (with val (not (visible-bottom-tools? n)) (if (and (== (windows-number) 1) (== n 0)) (set-boolean-preference "bottom tools" val) (show-bottom-tools n val)))))
   => ((quote toggle-visible-bottom-tools) #:synopsis (quote ("Toggle the visibility of the bottom tools.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-visible-bottom-tools) #:synopsis (quote ("Toggle the visibility of the bottom tools."))) ((quote toggle-visible-bottom-tools) #:check-mark (list "v" visible-bottom-tools?)))

(property-set! var prop what conds*)
  <= (toggle-visible-bottom-tools #:synopsis ("Toggle the visibility of the bottom tools.") ())

(property-set! var prop what conds*)
  <= (toggle-visible-bottom-tools #:check-mark ("v" #<primitive-procedure visible-bottom-tools?>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" visible-icon-bar?) (tm-define-overloaded (toggle-visible-icon-bar n) (let* ((val (not (visible-icon-bar? n))) (var (cond ((== n 0) "main icon bar") ((== n 1) "mode dependent icons") ((== n 2) "focus dependent icons") ((== n 3) "user provided icons")))) (if (== (windows-number) 1) (set-boolean-preference var val) (show-icon-bar n val)))))
    => ((quote toggle-visible-icon-bar) #:check-mark (list "v" visible-icon-bar?))
 => cons <> cur-props
    => cur-props => (((quote toggle-visible-icon-bar) #:check-mark (list "v" visible-icon-bar?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle the visibility of the @n-th icon bar.") (tm-define-overloaded (toggle-visible-icon-bar n) (let* ((val (not (visible-icon-bar? n))) (var (cond ((== n 0) "main icon bar") ((== n 1) "mode dependent icons") ((== n 2) "focus dependent icons") ((== n 3) "user provided icons")))) (if (== (windows-number) 1) (set-boolean-preference var val) (show-icon-bar n val)))))
   => ((quote toggle-visible-icon-bar) #:synopsis (quote ("Toggle the visibility of the @n-th icon bar.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-visible-icon-bar) #:synopsis (quote ("Toggle the visibility of the @n-th icon bar."))) ((quote toggle-visible-icon-bar) #:check-mark (list "v" visible-icon-bar?)))

(property-set! var prop what conds*)
  <= (toggle-visible-icon-bar #:synopsis ("Toggle the visibility of the @n-th icon bar.") ())

(property-set! var prop what conds*)
  <= (toggle-visible-icon-bar #:check-mark ("v" #<primitive-procedure visible-icon-bar?>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" full-screen?) (tm-define-overloaded (toggle-full-screen-mode) (if (full-screen?) (begin (init-env "info-flag" saved-informative-flags) (full-screen-mode #f #f) (restore-zoom (get-init-page-rendering))) (begin (save-zoom (get-init-page-rendering)) (set! saved-informative-flags (get-init-env "info-flag")) (init-env "info-flag" "none") (full-screen-mode #t #f) (fit-to-screen-width)))))
    => ((quote toggle-full-screen-mode) #:check-mark (list "v" full-screen?))
 => cons <> cur-props
    => cur-props => (((quote toggle-full-screen-mode) #:check-mark (list "v" full-screen?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle full screen mode.") (tm-define-overloaded (toggle-full-screen-mode) (if (full-screen?) (begin (init-env "info-flag" saved-informative-flags) (full-screen-mode #f #f) (restore-zoom (get-init-page-rendering))) (begin (save-zoom (get-init-page-rendering)) (set! saved-informative-flags (get-init-env "info-flag")) (init-env "info-flag" "none") (full-screen-mode #t #f) (fit-to-screen-width)))))
   => ((quote toggle-full-screen-mode) #:synopsis (quote ("Toggle full screen mode.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-full-screen-mode) #:synopsis (quote ("Toggle full screen mode."))) ((quote toggle-full-screen-mode) #:check-mark (list "v" full-screen?)))

(property-set! var prop what conds*)
  <= (toggle-full-screen-mode #:synopsis ("Toggle full screen mode.") ())

(property-set! var prop what conds*)
  <= (toggle-full-screen-mode #:check-mark ("v" #<primitive-procedure full-screen?>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" full-screen-edit?) (tm-define-overloaded (toggle-full-screen-edit-mode) (let* ((old (full-screen?)) (new (not (full-screen-edit?)))) (when (and (not old) new) (save-zoom (get-init-page-rendering))) (full-screen-mode new new) (when (and old (not new)) (restore-zoom (get-init-page-rendering))))))
    => ((quote toggle-full-screen-edit-mode) #:check-mark (list "v" full-screen-edit?))
 => cons <> cur-props
    => cur-props => (((quote toggle-full-screen-edit-mode) #:check-mark (list "v" full-screen-edit?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle full screen edit mode.") (tm-define-overloaded (toggle-full-screen-edit-mode) (let* ((old (full-screen?)) (new (not (full-screen-edit?)))) (when (and (not old) new) (save-zoom (get-init-page-rendering))) (full-screen-mode new new) (when (and old (not new)) (restore-zoom (get-init-page-rendering))))))
   => ((quote toggle-full-screen-edit-mode) #:synopsis (quote ("Toggle full screen edit mode.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-full-screen-edit-mode) #:synopsis (quote ("Toggle full screen edit mode."))) ((quote toggle-full-screen-edit-mode) #:check-mark (list "v" full-screen-edit?)))

(property-set! var prop what conds*)
  <= (toggle-full-screen-edit-mode #:synopsis ("Toggle full screen edit mode.") ())

(property-set! var prop what conds*)
  <= (toggle-full-screen-edit-mode #:check-mark ("v" #<primitive-procedure full-screen-edit?>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" panorama-mode?) (tm-define-overloaded (toggle-panorama-mode) (if (panorama-mode?) (with old (or (ahash-ref panorama-revert (current-buffer)) "paper") (init-page-rendering old)) (with old (get-init-page-rendering) (ahash-set! panorama-revert (current-buffer) old) (init-page-rendering "panorama")))))
    => ((quote toggle-panorama-mode) #:check-mark (list "v" panorama-mode?))
 => cons <> cur-props
    => cur-props => (((quote toggle-panorama-mode) #:check-mark (list "v" panorama-mode?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle panorama screen rendering.") (tm-define-overloaded (toggle-panorama-mode) (if (panorama-mode?) (with old (or (ahash-ref panorama-revert (current-buffer)) "paper") (init-page-rendering old)) (with old (get-init-page-rendering) (ahash-set! panorama-revert (current-buffer) old) (init-page-rendering "panorama")))))
   => ((quote toggle-panorama-mode) #:synopsis (quote ("Toggle panorama screen rendering.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-panorama-mode) #:synopsis (quote ("Toggle panorama screen rendering."))) ((quote toggle-panorama-mode) #:check-mark (list "v" panorama-mode?)))

(property-set! var prop what conds*)
  <= (toggle-panorama-mode #:synopsis ("Toggle panorama screen rendering.") ())

(property-set! var prop what conds*)
  <= (toggle-panorama-mode #:check-mark ("v" #<procedure panorama-mode? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" remote-control-mode?) (tm-define-overloaded (toggle-remote-control-mode) (set! remote-control-flag? (not remote-control-flag?))))
    => ((quote toggle-remote-control-mode) #:check-mark (list "v" remote-control-mode?))
 => cons <> cur-props
    => cur-props => (((quote toggle-remote-control-mode) #:check-mark (list "v" remote-control-mode?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle remote keyboard control mode.") (tm-define-overloaded (toggle-remote-control-mode) (set! remote-control-flag? (not remote-control-flag?))))
   => ((quote toggle-remote-control-mode) #:synopsis (quote ("Toggle remote keyboard control mode.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-remote-control-mode) #:synopsis (quote ("Toggle remote keyboard control mode."))) ((quote toggle-remote-control-mode) #:check-mark (list "v" remote-control-mode?)))

(property-set! var prop what conds*)
  <= (toggle-remote-control-mode #:synopsis ("Toggle remote keyboard control mode.") ())

(property-set! var prop what conds*)
  <= (toggle-remote-control-mode #:check-mark ("v" #<procedure remote-control-mode? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" test-zoom-factor?) (tm-define-overloaded (change-zoom-factor z) (set! z (max (min z 25.0) 0.04)) (when (and (== (windows-number) 1) (in? (get-init "page-packet") (list "1" "2"))) (set-preference "zoom factor" (number->string z))) (set-window-zoom-factor z) (notify-page-change) (notify-change 1)))
    => ((quote change-zoom-factor) #:check-mark (list "*" test-zoom-factor?))
 => cons <> cur-props
    => cur-props => (((quote change-zoom-factor) #:check-mark (list "*" test-zoom-factor?)))

(property-set! var prop what conds*)
  <= (change-zoom-factor #:check-mark ("*" #<procedure test-zoom-factor? (z)>) ())

  (define-option-argument opt decl)
    <= ((s "Zoom factor") (tm-define-overloaded (other-zoom-factor s) (if (string-ends? s "%") (with p (string->number (string-drop-right s 1)) (change-zoom-factor (* 0.01 p))) (change-zoom-factor (string->number s)))))
    => cons <> cur-props <= ((quote other-zoom-factor) #:arguments (quote (s)))
    => cons <> cur-props <= ((quote other-zoom-factor) (quote (#:argument s)) (quote ("Zoom factor")))
    => cur-props => (((quote other-zoom-factor) (quote (#:argument s)) (quote ("Zoom factor"))) ((quote other-zoom-factor) #:arguments (quote (s))))

(property-set! var prop what conds*)
  <= (other-zoom-factor (#:argument s) ("Zoom factor") ())

(property-set! var prop what conds*)
  <= (other-zoom-factor #:arguments (s) ())

  (define-option-default opt decl)
    <= ((name (propose-postscript-name)) (tm-property-overloaded (print-to-file name)))
    => cons <> cur-props <= ((quote print-to-file) (quote (#:default name)) (lambda () (propose-postscript-name)))
    => cur-props => (((quote print-to-file) (quote (#:default name)) (lambda () (propose-postscript-name))))

  (define-option-argument opt decl)
    <= ((name print-file "File name") (tm-property-overloaded (print-to-file name)))
    => cons <> cur-props <= ((quote print-to-file) #:arguments (quote (name)))
    => cons <> cur-props <= ((quote print-to-file) (quote (#:argument name)) (quote (print-file "File name")))
    => cur-props => (((quote print-to-file) (quote (#:argument name)) (quote (print-file "File name"))) ((quote print-to-file) #:arguments (quote (name))) ((quote print-to-file) (quote (#:default name)) (lambda () (propose-postscript-name))))

(property-set! var prop what conds*)
  <= (print-to-file (#:argument name) (print-file "File name") ())

(property-set! var prop what conds*)
  <= (print-to-file #:arguments (name) ())

(property-set! var prop what conds*)
  <= (print-to-file (#:default name) #<procedure #f ()> ())

  (define-option-argument opt decl)
    <= ((last "Last page") (tm-property-overloaded (print-pages first last)))
    => cons <> cur-props <= ((quote print-pages) #:arguments (quote (first last)))
    => cons <> cur-props <= ((quote print-pages) (quote (#:argument last)) (quote ("Last page")))
    => cur-props => (((quote print-pages) (quote (#:argument last)) (quote ("Last page"))) ((quote print-pages) #:arguments (quote (first last))))

  (define-option-argument opt decl)
    <= ((first "First page") (tm-property-overloaded (print-pages first last)))
    => cons <> cur-props <= ((quote print-pages) #:arguments (quote (first last)))
    => cons <> cur-props <= ((quote print-pages) (quote (#:argument first)) (quote ("First page")))
    => cur-props => (((quote print-pages) (quote (#:argument first)) (quote ("First page"))) ((quote print-pages) #:arguments (quote (first last))) ((quote print-pages) (quote (#:argument last)) (quote ("Last page"))) ((quote print-pages) #:arguments (quote (first last))))

(property-set! var prop what conds*)
  <= (print-pages (#:argument first) ("First page") ())

(property-set! var prop what conds*)
  <= (print-pages #:arguments (first last) ())

(property-set! var prop what conds*)
  <= (print-pages (#:argument last) ("Last page") ())

(property-set! var prop what conds*)
  <= (print-pages #:arguments (first last) ())

  (define-option-argument opt decl)
    <= ((last "Last page") (tm-property-overloaded (print-pages-to-file name first last)))
    => cons <> cur-props <= ((quote print-pages-to-file) #:arguments (quote (name first last)))
    => cons <> cur-props <= ((quote print-pages-to-file) (quote (#:argument last)) (quote ("Last page")))
    => cur-props => (((quote print-pages-to-file) (quote (#:argument last)) (quote ("Last page"))) ((quote print-pages-to-file) #:arguments (quote (name first last))))

  (define-option-argument opt decl)
    <= ((first "First page") (tm-property-overloaded (print-pages-to-file name first last)))
    => cons <> cur-props <= ((quote print-pages-to-file) #:arguments (quote (name first last)))
    => cons <> cur-props <= ((quote print-pages-to-file) (quote (#:argument first)) (quote ("First page")))
    => cur-props => (((quote print-pages-to-file) (quote (#:argument first)) (quote ("First page"))) ((quote print-pages-to-file) #:arguments (quote (name first last))) ((quote print-pages-to-file) (quote (#:argument last)) (quote ("Last page"))) ((quote print-pages-to-file) #:arguments (quote (name first last))))

  (define-option-default opt decl)
    <= ((name (propose-postscript-name)) (tm-property-overloaded (print-pages-to-file name first last)))
    => cons <> cur-props <= ((quote print-pages-to-file) (quote (#:default name)) (lambda () (propose-postscript-name)))
    => cur-props => (((quote print-pages-to-file) (quote (#:default name)) (lambda () (propose-postscript-name))) ((quote print-pages-to-file) (quote (#:argument first)) (quote ("First page"))) ((quote print-pages-to-file) #:arguments (quote (name first last))) ((quote print-pages-to-file) (quote (#:argument last)) (quote ("Last page"))) ((quote print-pages-to-file) #:arguments (quote (name first last))))

  (define-option-argument opt decl)
    <= ((name print-file "File name") (tm-property-overloaded (print-pages-to-file name first last)))
    => cons <> cur-props <= ((quote print-pages-to-file) #:arguments (quote (name first last)))
    => cons <> cur-props <= ((quote print-pages-to-file) (quote (#:argument name)) (quote (print-file "File name")))
    => cur-props => (((quote print-pages-to-file) (quote (#:argument name)) (quote (print-file "File name"))) ((quote print-pages-to-file) #:arguments (quote (name first last))) ((quote print-pages-to-file) (quote (#:default name)) (lambda () (propose-postscript-name))) ((quote print-pages-to-file) (quote (#:argument first)) (quote ("First page"))) ((quote print-pages-to-file) #:arguments (quote (name first last))) ((quote print-pages-to-file) (quote (#:argument last)) (quote ("Last page"))) ((quote print-pages-to-file) #:arguments (quote (name first last))))

(property-set! var prop what conds*)
  <= (print-pages-to-file (#:argument name) (print-file "File name") ())

(property-set! var prop what conds*)
  <= (print-pages-to-file #:arguments (name first last) ())

(property-set! var prop what conds*)
  <= (print-pages-to-file (#:default name) #<procedure #f ()> ())

(property-set! var prop what conds*)
  <= (print-pages-to-file (#:argument first) ("First page") ())

(property-set! var prop what conds*)
  <= (print-pages-to-file #:arguments (name first last) ())

(property-set! var prop what conds*)
  <= (print-pages-to-file (#:argument last) ("Last page") ())

(property-set! var prop what conds*)
  <= (print-pages-to-file #:arguments (name first last) ())

  (define-option-argument opt decl)
    <= ((end "Last page") (tm-define-overloaded (choose-file-and-print-page-selection start end) (choose-file (lambda (name) (print-pages-to-file name start end)) "Print page selection to file" "postscript")))
    => cons <> cur-props <= ((quote choose-file-and-print-page-selection) #:arguments (quote (start end)))
    => cons <> cur-props <= ((quote choose-file-and-print-page-selection) (quote (#:argument end)) (quote ("Last page")))
    => cur-props => (((quote choose-file-and-print-page-selection) (quote (#:argument end)) (quote ("Last page"))) ((quote choose-file-and-print-page-selection) #:arguments (quote (start end))))

  (define-option-argument opt decl)
    <= ((start "First page") (tm-define-overloaded (choose-file-and-print-page-selection start end) (choose-file (lambda (name) (print-pages-to-file name start end)) "Print page selection to file" "postscript")))
    => cons <> cur-props <= ((quote choose-file-and-print-page-selection) #:arguments (quote (start end)))
    => cons <> cur-props <= ((quote choose-file-and-print-page-selection) (quote (#:argument start)) (quote ("First page")))
    => cur-props => (((quote choose-file-and-print-page-selection) (quote (#:argument start)) (quote ("First page"))) ((quote choose-file-and-print-page-selection) #:arguments (quote (start end))) ((quote choose-file-and-print-page-selection) (quote (#:argument end)) (quote ("Last page"))) ((quote choose-file-and-print-page-selection) #:arguments (quote (start end))))

(property-set! var prop what conds*)
  <= (choose-file-and-print-page-selection (#:argument start) ("First page") ())

(property-set! var prop what conds*)
  <= (choose-file-and-print-page-selection #:arguments (start end) ())

(property-set! var prop what conds*)
  <= (choose-file-and-print-page-selection (#:argument end) ("Last page") ())

(property-set! var prop what conds*)
  <= (choose-file-and-print-page-selection #:arguments (start end) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-property-overloaded (choose-file fun text type)))
    => ((quote choose-file) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote choose-file) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (choose-file #:interactive (#t) ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Creates a copy of @buf in @u and return @u.") (tm-define-overloaded (buffer-copy buf u) (with-buffer buf (let* ((styles (get-style-list)) (init (get-all-inits)) (body (tree-copy (buffer-get-body buf)))) (view-new u) (buffer-set-body u body) (with-buffer u (set-style-list styles) (init-env "global-title" (buffer-get-metadata buf "title")) (init-env "global-author" (buffer-get-metadata buf "author")) (init-env "global-subject" (buffer-get-metadata buf "subject")) (for-each (lambda (t) (if (tree-func? t (quote associate)) (with (var val) (list (tree-ref t 0) (tree-ref t 1)) (init-env-tree (tree->string var) val)))) (tree-children init))) u))))
   => ((quote buffer-copy) #:synopsis (quote ("Creates a copy of @buf in @u and return @u.")))
 => cons <> cur-props
   => cur-props => (((quote buffer-copy) #:synopsis (quote ("Creates a copy of @buf in @u and return @u."))))

(property-set! var prop what conds*)
  <= (buffer-copy #:synopsis ("Creates a copy of @buf in @u and return @u.") ())

  (define-option-default opt decl)
    <= ((new-name (propose-name-buffer)) (tm-define-overloaded (save-buffer-as new-name . args) (with opts (if (x-gui?) args (cons #:overwrite args)) (apply save-buffer-as-main (cons new-name opts)))))
    => cons <> cur-props <= ((quote save-buffer-as) (quote (#:default new-name)) (lambda () (propose-name-buffer)))
    => cur-props => (((quote save-buffer-as) (quote (#:default new-name)) (lambda () (propose-name-buffer))))

  (define-option-argument opt decl)
    <= ((new-name texmacs-file "Save as") (tm-define-overloaded (save-buffer-as new-name . args) (with opts (if (x-gui?) args (cons #:overwrite args)) (apply save-buffer-as-main (cons new-name opts)))))
    => cons <> cur-props <= ((quote save-buffer-as) #:arguments (quote (new-name . args)))
    => cons <> cur-props <= ((quote save-buffer-as) (quote (#:argument new-name)) (quote (texmacs-file "Save as")))
    => cur-props => (((quote save-buffer-as) (quote (#:argument new-name)) (quote (texmacs-file "Save as"))) ((quote save-buffer-as) #:arguments (quote (new-name . args))) ((quote save-buffer-as) (quote (#:default new-name)) (lambda () (propose-name-buffer))))

(property-set! var prop what conds*)
  <= (save-buffer-as (#:argument new-name) (texmacs-file "Save as") ())

(property-set! var prop what conds*)
  <= (save-buffer-as #:arguments (new-name . args) ())

(property-set! var prop what conds*)
  <= (save-buffer-as (#:default new-name) #<procedure #f ()> ())

  (define-option-default opt decl)
    <= ((name (propose-name-buffer)) (tm-define-overloaded (load-buffer name . opts) (apply load-buffer-main (cons name opts))))
    => cons <> cur-props <= ((quote load-buffer) (quote (#:default name)) (lambda () (propose-name-buffer)))
    => cur-props => (((quote load-buffer) (quote (#:default name)) (lambda () (propose-name-buffer))))

  (define-option-argument opt decl)
    <= ((name smart-file "File name") (tm-define-overloaded (load-buffer name . opts) (apply load-buffer-main (cons name opts))))
    => cons <> cur-props <= ((quote load-buffer) #:arguments (quote (name . opts)))
    => cons <> cur-props <= ((quote load-buffer) (quote (#:argument name)) (quote (smart-file "File name")))
    => cur-props => (((quote load-buffer) (quote (#:argument name)) (quote (smart-file "File name"))) ((quote load-buffer) #:arguments (quote (name . opts))) ((quote load-buffer) (quote (#:default name)) (lambda () (propose-name-buffer))))

(property-set! var prop what conds*)
  <= (load-buffer (#:argument name) (smart-file "File name") ())

(property-set! var prop what conds*)
  <= (load-buffer #:arguments (name . opts) ())

(property-set! var prop what conds*)
  <= (load-buffer (#:default name) #<procedure #f ()> ())

  (define-option-default opt decl)
    <= ((name (propose-name-buffer)) (tm-define-overloaded (load-buffer-in-new-window name . opts) (apply load-buffer-main (cons name (cons #:new-window opts)))))
    => cons <> cur-props <= ((quote load-buffer-in-new-window) (quote (#:default name)) (lambda () (propose-name-buffer)))
    => cur-props => (((quote load-buffer-in-new-window) (quote (#:default name)) (lambda () (propose-name-buffer))))

  (define-option-argument opt decl)
    <= ((name smart-file "File name") (tm-define-overloaded (load-buffer-in-new-window name . opts) (apply load-buffer-main (cons name (cons #:new-window opts)))))
    => cons <> cur-props <= ((quote load-buffer-in-new-window) #:arguments (quote (name . opts)))
    => cons <> cur-props <= ((quote load-buffer-in-new-window) (quote (#:argument name)) (quote (smart-file "File name")))
    => cur-props => (((quote load-buffer-in-new-window) (quote (#:argument name)) (quote (smart-file "File name"))) ((quote load-buffer-in-new-window) #:arguments (quote (name . opts))) ((quote load-buffer-in-new-window) (quote (#:default name)) (lambda () (propose-name-buffer))))

(property-set! var prop what conds*)
  <= (load-buffer-in-new-window (#:argument name) (smart-file "File name") ())

(property-set! var prop what conds*)
  <= (load-buffer-in-new-window #:arguments (name . opts) ())

(property-set! var prop what conds*)
  <= (load-buffer-in-new-window (#:default name) #<procedure #f ()> ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Load a buffer or switch to it if already open") (tm-define-overloaded (load-browse-buffer name) (if (buffer-exists? name) (switch-to-buffer name) (load-buffer name))))
   => ((quote load-browse-buffer) #:synopsis (quote ("Load a buffer or switch to it if already open")))
 => cons <> cur-props
   => cur-props => (((quote load-browse-buffer) #:synopsis (quote ("Load a buffer or switch to it if already open"))))

(property-set! var prop what conds*)
  <= (load-browse-buffer #:synopsis ("Load a buffer or switch to it if already open") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Open a new file") (tm-define-overloaded (open-buffer) (choose-file load-buffer "Load file" "")))
   => ((quote open-buffer) #:synopsis (quote ("Open a new file")))
 => cons <> cur-props
   => cur-props => (((quote open-buffer) #:synopsis (quote ("Open a new file"))))

(property-set! var prop what conds*)
  <= (open-buffer #:synopsis ("Open a new file") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Print the current buffer") (tm-define-overloaded (print-buffer) (print)))
   => ((quote print-buffer) #:synopsis (quote ("Print the current buffer")))
 => cons <> cur-props
   => cur-props => (((quote print-buffer) #:synopsis (quote ("Print the current buffer"))))

(property-set! var prop what conds*)
  <= (print-buffer #:synopsis ("Print the current buffer") ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (interactive-page-setup) (set-message "Not yet implemented" "Printer setup")))
    => ((quote interactive-page-setup) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote interactive-page-setup) #:interactive (list #t)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Specify the page setup") (tm-define-overloaded (interactive-page-setup) (set-message "Not yet implemented" "Printer setup")))
   => ((quote interactive-page-setup) #:synopsis (quote ("Specify the page setup")))
 => cons <> cur-props
   => cur-props => (((quote interactive-page-setup) #:synopsis (quote ("Specify the page setup"))) ((quote interactive-page-setup) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (interactive-page-setup #:synopsis ("Specify the page setup") ())

(property-set! var prop what conds*)
  <= (interactive-page-setup #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (interactive-print-buffer) (print-to-file "$TEXMACS_HOME_PATH/system/tmp/tmpprint.ps") (interactive-print (quote ()) "$TEXMACS_HOME_PATH/system/tmp/tmpprint.ps")))
    => ((quote interactive-print-buffer) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote interactive-print-buffer) #:interactive (list #t)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Print the current buffer") (tm-define-overloaded (interactive-print-buffer) (print-to-file "$TEXMACS_HOME_PATH/system/tmp/tmpprint.ps") (interactive-print (quote ()) "$TEXMACS_HOME_PATH/system/tmp/tmpprint.ps")))
   => ((quote interactive-print-buffer) #:synopsis (quote ("Print the current buffer")))
 => cons <> cur-props
   => cur-props => (((quote interactive-print-buffer) #:synopsis (quote ("Print the current buffer"))) ((quote interactive-print-buffer) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (interactive-print-buffer #:synopsis ("Print the current buffer") ())

(property-set! var prop what conds*)
  <= (interactive-print-buffer #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-property-overloaded (open-search)))
    => ((quote open-search) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-search) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-search #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-property-overloaded (open-replace)))
    => ((quote open-replace) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-replace) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-replace #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-property-overloaded (open-paragraph-format)))
    => ((quote open-paragraph-format) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-paragraph-format) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-paragraph-format #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-property-overloaded (open-page-format)))
    => ((quote open-page-format) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-page-format) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-page-format #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-property-overloaded (open-source-tree-preferences)))
    => ((quote open-source-tree-preferences) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-source-tree-preferences) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-source-tree-preferences #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-property-overloaded (open-document-paragraph-format)))
    => ((quote open-document-paragraph-format) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-document-paragraph-format) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-document-paragraph-format #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-property-overloaded (open-document-page-format)))
    => ((quote open-document-page-format) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-document-page-format) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-document-page-format #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-property-overloaded (open-document-metadata)))
    => ((quote open-document-metadata) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-document-metadata) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-document-metadata #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-property-overloaded (open-document-colors)))
    => ((quote open-document-colors) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-document-colors) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-document-colors #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-property-overloaded (open-pattern-selector cmd w)))
    => ((quote open-pattern-selector) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-pattern-selector) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-pattern-selector #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-property-overloaded (open-macro-editor l)))
    => ((quote open-macro-editor) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-macro-editor) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-macro-editor #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-property-overloaded (create-table-macro l)))
    => ((quote create-table-macro) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote create-table-macro) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (create-table-macro #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-property-overloaded (open-macros-editor)))
    => ((quote open-macros-editor) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-macros-editor) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-macros-editor #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-property-overloaded (open-cell-properties)))
    => ((quote open-cell-properties) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-cell-properties) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-cell-properties #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-property-overloaded (open-table-properties)))
    => ((quote open-table-properties) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-table-properties) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-table-properties #:interactive (#t) ())

(property-set! var prop what conds*)
  <= (arrow-with-text #:secure #t ())

(property-set! var prop what conds*)
  <= (arrow-with-text* #:secure #t ())

(property-set! var prop what conds*)
  <= (tmdoc-include #:secure #t ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-property-overloaded (open-biblio)))
    => ((quote open-biblio) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-biblio) #:interactive (list #t)))

(property-set! var prop what conds*)
  <Running my-init-texmacs
TeXmacs] With linked TrueType support
= (open-biblio #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-property-overloaded (open-font-selector)))
    => ((quote open-font-selector) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-font-selector) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-font-selector #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-property-overloaded (open-document-font-selector)))
    => ((quote open-document-font-selector) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-document-font-selector) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-document-font-selector #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (doc-data t) (with opts (map tree->stree (select t (quote (doc-title-options #:%1)))) (cond ((in? "cluster-all" opts) (set! t (single-author-list t))) ((in? "cluster-by-affiliation" opts) (set! t (factor-affiliation t)))) (set! t (add-notes t)) (set! t (doc-data-sub t)) t)))
    => ((quote doc-data) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote doc-data) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (doc-data #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (author-data t) (quasiquote (document (unquote-splicing (select t (quote (author-name)))) (unquote-splicing (select t (quote (author-affiliation)))) (unquote-splicing (select t (quote (author-affiliation-note)))) (unquote-splicing (select t (quote (author-email)))) (unquote-splicing (select t (quote (author-email-note)))) (unquote-splicing (select t (quote (author-homepage)))) (unquote-splicing (select t (quote (author-homepage-note)))) (unquote-splicing (select t (quote (author-misc)))) (unquote-splicing (select t (quote (author-misc-note))))))))
    => ((quote author-data) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote author-data) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (author-data #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (abstract-data t) (let ((opts (quasiquote (document (unquote-splicing (select t (quote (abstract-keywords)))) (unquote-splicing (select t (quote (abstract-acm)))) (unquote-splicing (select t (quote (abstract-arxiv)))) (unquote-splicing (select t (quote (abstract-pacs)))) (unquote-splicing (select t (quote (abstract-msc))))))) (abst (select t (quote (#:* abstract 0))))) (if (list>1? opts) (quasiquote (render-abstract* (document (unquote-splicing abst)) (unquote opts))) (quasiquote (render-abstract (document (unquote-splicing abst))))))))
    => ((quote abstract-data) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote abstract-data) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (abstract-data #:secure (#t) ())

  (define-option-default opt decl)
    <= ((to "primary") (tm-property-overloaded (clipboard-copy to)))
    => cons <> cur-props <= ((quote clipboard-copy) (quote (#:default to)) (lambda () "primary"))
    => cur-props => (((quote clipboard-copy) (quote (#:default to)) (lambda () "primary")))

  (define-option-argument opt decl)
    <= ((to "Copy to") (tm-property-overloaded (clipboard-copy to)))
    => cons <> cur-props <= ((quote clipboard-copy) #:arguments (quote (to)))
    => cons <> cur-props <= ((quote clipboard-copy) (quote (#:argument to)) (quote ("Copy to")))
    => cur-props => (((quote clipboard-copy) (quote (#:argument to)) (quote ("Copy to"))) ((quote clipboard-copy) #:arguments (quote (to))) ((quote clipboard-copy) (quote (#:default to)) (lambda () "primary")))

(property-set! var prop what conds*)
  <= (clipboard-copy (#:argument to) ("Copy to") ())

(property-set! var prop what conds*)
  <= (clipboard-copy #:arguments (to) ())

(property-set! var prop what conds*)
  <= (clipboard-copy (#:default to) #<procedure #f ()> ())

  (define-option-default opt decl)
    <= ((to "primary") (tm-property-overloaded (clipboard-cut to)))
    => cons <> cur-props <= ((quote clipboard-cut) (quote (#:default to)) (lambda () "primary"))
    => cur-props => (((quote clipboard-cut) (quote (#:default to)) (lambda () "primary")))

  (define-option-argument opt decl)
    <= ((to "Cut to") (tm-property-overloaded (clipboard-cut to)))
    => cons <> cur-props <= ((quote clipboard-cut) #:arguments (quote (to)))
    => cons <> cur-props <= ((quote clipboard-cut) (quote (#:argument to)) (quote ("Cut to")))
    => cur-props => (((quote clipboard-cut) (quote (#:argument to)) (quote ("Cut to"))) ((quote clipboard-cut) #:arguments (quote (to))) ((quote clipboard-cut) (quote (#:default to)) (lambda () "primary")))

(property-set! var prop what conds*)
  <= (clipboard-cut (#:argument to) ("Cut to") ())

(property-set! var prop what conds*)
  <= (clipboard-cut #:arguments (to) ())

(property-set! var prop what conds*)
  <= (clipboard-cut (#:default to) #<procedure #f ()> ())

  (define-option-default opt decl)
    <= ((to "primary") (tm-property-overloaded (clipboard-paste from)))
    => cons <> cur-props <= ((quote clipboard-paste) (quote (#:default to)) (lambda () "primary"))
    => cur-props => (((quote clipboard-paste) (quote (#:default to)) (lambda () "primary")))

  (define-option-argument opt decl)
    <= ((from "Paste from") (tm-property-overloaded (clipboard-paste from)))
    => cons <> cur-props <= ((quote clipboard-paste) #:arguments (quote (from)))
    => cons <> cur-props <= ((quote clipboard-paste) (quote (#:argument from)) (quote ("Paste from")))
    => cur-props => (((quote clipboard-paste) (quote (#:argument from)) (quote ("Paste from"))) ((quote clipboard-paste) #:arguments (quote (from))) ((quote clipboard-paste) (quote (#:default to)) (lambda () "primary")))

(property-set! var prop what conds*)
  <= (clipboard-paste (#:argument from) ("Paste from") ())

(property-set! var prop what conds*)
  <= (clipboard-paste #:arguments (from) ())

(property-set! var prop what conds*)
  <= (clipboard-paste (#:default to) #<procedure #f ()> ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" clipboard-test-import?) (tm-property-overloaded (clipboard-set-import s)))
    => ((quote clipboard-set-import) #:check-mark (list "*" clipboard-test-import?))
 => cons <> cur-props
    => cur-props => (((quote clipboard-set-import) #:check-mark (list "*" clipboard-test-import?)))

(property-set! var prop what conds*)
  <= (clipboard-set-import #:check-mark ("*" #<procedure clipboard-test-import? (s)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" clipboard-test-export?) (tm-property-overloaded (clipboard-set-export s)))
    => ((quote clipboard-set-export) #:check-mark (list "*" clipboard-test-export?))
 => cons <> cur-props
    => cur-props => (((quote clipboard-set-export) #:check-mark (list "*" clipboard-test-export?)))

(property-set! var prop what conds*)
  <= (clipboard-set-export #:check-mark ("*" #<procedure clipboard-test-export? (s)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" test-env?) (tm-property-overloaded (make-with var val)))
    => ((quote make-with) #:check-mark (list "o" test-env?))
 => cons <> cur-props
    => cur-props => (((quote make-with) #:check-mark (list "o" test-env?)))

(property-set! var prop what conds*)
  <= (make-with #:check-mark ("o" #<procedure test-env? (var val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (make-interactive-with var) (interactive (lambda (s) (make-with var s)) (list (logic-ref env-var-description% var) "string" (get-env var)))))
    => ((quote make-interactive-with) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote make-interactive-with) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (make-interactive-with #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (make-interactive-with-opacity) (interactive (lambda (s) (make-with-like (quasiquote (with-opacity (unquote s) "")))) (list "opacity" "string" (quote ())))))
    => ((quote make-interactive-with-opacity) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote make-interactive-with-opacity) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (make-interactive-with-opacity #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" test-env?) (tm-define-overloaded (make-line-with var val) (if (and (selection-active-table?) #f) (make-with var val) (begin (if (not (selection-active-normal?)) (select-line)) (make-with var val) (insert-return) (remove-text #f)))))
    => ((quote make-line-with) #:check-mark (list "o" test-env?))
 => cons <> cur-props
    => cur-props => (((quote make-line-with) #:check-mark (list "o" test-env?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make 'with' with one or more paragraphs as its scope") (tm-define-overloaded (make-line-with var val) (if (and (selection-active-table?) #f) (make-with var val) (begin (if (not (selection-active-normal?)) (select-line)) (make-with var val) (insert-return) (remove-text #f)))))
   => ((quote make-line-with) #:synopsis (quote ("Make 'with' with one or more paragraphs as its scope")))
 => cons <> cur-props
   => cur-props => (((quote make-line-with) #:synopsis (quote ("Make 'with' with one or more paragraphs as its scope"))) ((quote make-line-with) #:check-mark (list "o" test-env?)))

(property-set! var prop what conds*)
  <= (make-line-with #:synopsis ("Make 'with' with one or more paragraphs as its scope") ())

(property-set! var prop what conds*)
  <= (make-line-with #:check-mark ("o" #<procedure test-env? (var val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (make-interactive-line-with var) (interactive (lambda (s) (make-line-with var s)) (list (logic-ref env-var-description% var) "string" (get-env var)))))
    => ((quote make-interactive-line-with) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote make-interactive-line-with) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (make-interactive-line-with #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (make-alternate prompt default-val tag) (interactive (lambda (x) (make-with-like (quasiquote ((unquote tag) (unquote x) "")))) (list prompt "string" default-val))))
    => ((quote make-alternate) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote make-alternate) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (make-alternate #:interactive (#t) ())

  (define-option-argument opt decl)
    <= ((spc "Horizontal space") (tm-property-overloaded (make-hspace spc)))
    => cons <> cur-props <= ((quote make-hspace) #:arguments (quote (spc)))
    => cons <> cur-props <= ((quote make-hspace) (quote (#:argument spc)) (quote ("Horizontal space")))
    => cur-props => (((quote make-hspace) (quote (#:argument spc)) (quote ("Horizontal space"))) ((quote make-hspace) #:arguments (quote (spc))))

(property-set! var prop what conds*)
  <= (make-hspace (#:argument spc) ("Horizontal space") ())

(property-set! var prop what conds*)
  <= (make-hspace #:arguments (spc) ())

  (define-option-argument opt decl)
    <= ((spc "Horizontal space") (tm-property-overloaded (make-space spc)))
    => cons <> cur-props <= ((quote make-space) #:arguments (quote (spc)))
    => cons <> cur-props <= ((quote make-space) (quote (#:argument spc)) (quote ("Horizontal space")))
    => cur-props => (((quote make-space) (quote (#:argument spc)) (quote ("Horizontal space"))) ((quote make-space) #:arguments (quote (spc))))

(property-set! var prop what conds*)
  <= (make-space (#:argument spc) ("Horizontal space") ())

(property-set! var prop what conds*)
  <= (make-space #:arguments (spc) ())

  (define-option-argument opt decl)
    <= ((top "Top level") (tm-property-overloaded (make-var-space spc base top)))
    => cons <> cur-props <= ((quote make-var-space) #:arguments (quote (spc base top)))
    => cons <> cur-props <= ((quote make-var-space) (quote (#:argument top)) (quote ("Top level")))
    => cur-props => (((quote make-var-space) (quote (#:argument top)) (quote ("Top level"))) ((quote make-var-space) #:arguments (quote (spc base top))))

  (define-option-argument opt decl)
    <= ((base "Base level") (tm-property-overloaded (make-var-space spc base top)))
    => cons <> cur-props <= ((quote make-var-space) #:arguments (quote (spc base top)))
    => cons <> cur-props <= ((quote make-var-space) (quote (#:argument base)) (quote ("Base level")))
    => cur-props => (((quote make-var-space) (quote (#:argument base)) (quote ("Base level"))) ((quote make-var-space) #:arguments (quote (spc base top))) ((quote make-var-space) (quote (#:argument top)) (quote ("Top level"))) ((quote make-var-space) #:arguments (quote (spc base top))))

  (define-option-argument opt decl)
    <= ((spc "Horizontal space") (tm-property-overloaded (make-var-space spc base top)))
    => cons <> cur-props <= ((quote make-var-space) #:arguments (quote (spc base top)))
    => cons <> cur-props <= ((quote make-var-space) (quote (#:argument spc)) (quote ("Horizontal space")))
    => cur-props => (((quote make-var-space) (quote (#:argument spc)) (quote ("Horizontal space"))) ((quote make-var-space) #:arguments (quote (spc base top))) ((quote make-var-space) (quote (#:argument base)) (quote ("Base level"))) ((quote make-var-space) #:arguments (quote (spc base top))) ((quote make-var-space) (quote (#:argument top)) (quote ("Top level"))) ((quote make-var-space) #:arguments (quote (spc base top))))

(property-set! var prop what conds*)
  <= (make-var-space (#:argument spc) ("Horizontal space") ())

(property-set! var prop what conds*)
  <= (make-var-space #:arguments (spc base top) ())

(property-set! var prop what conds*)
  <= (make-var-space (#:argument base) ("Base level") ())

(property-set! var prop what conds*)
  <= (make-var-space #:arguments (spc base top) ())

(property-set! var prop what conds*)
  <= (make-var-space (#:argument top) ("Top level") ())

(property-set! var prop what conds*)
  <= (make-var-space #:arguments (spc base top) ())

  (define-option-argument opt decl)
    <= ((spc "Minimal space") (tm-property-overloaded (make-htab spc)))
    => cons <> cur-props <= ((quote make-htab) #:arguments (quote (spc)))
    => cons <> cur-props <= ((quote make-htab) (quote (#:argument spc)) (quote ("Minimal space")))
    => cur-props => (((quote make-htab) (quote (#:argument spc)) (quote ("Minimal space"))) ((quote make-htab) #:arguments (quote (spc))))

(property-set! var prop what conds*)
  <= (make-htab (#:argument spc) ("Minimal space") ())

(property-set! var prop what conds*)
  <= (make-htab #:arguments (spc) ())

  (define-option-argument opt decl)
    <= ((spc "Vertical space") (tm-property-overloaded (make-vspace-before spc)))
    => cons <> cur-props <= ((quote make-vspace-before) #:arguments (quote (spc)))
    => cons <> cur-props <= ((quote make-vspace-before) (quote (#:argument spc)) (quote ("Vertical space")))
    => cur-props => (((quote make-vspace-before) (quote (#:argument spc)) (quote ("Vertical space"))) ((quote make-vspace-before) #:arguments (quote (spc))))

(property-set! var prop what conds*)
  <= (make-vspace-before (#:argument spc) ("Vertical space") ())

(property-set! var prop what conds*)
  <= (make-vspace-before #:arguments (spc) ())

  (define-option-argument opt decl)
    <= ((spc "Vertical space") (tm-property-overloaded (make-vspace-after spc)))
    => cons <> cur-props <= ((quote make-vspace-after) #:arguments (quote (spc)))
    => cons <> cur-props <= ((quote make-vspace-after) (quote (#:argument spc)) (quote ("Vertical space")))
    => cur-props => (((quote make-vspace-after) (quote (#:argument spc)) (quote ("Vertical space"))) ((quote make-vspace-after) #:arguments (quote (spc))))

(property-set! var prop what conds*)
  <= (make-vspace-after (#:argument spc) ("Vertical space") ())

(property-set! var prop what conds*)
  <= (make-vspace-after #:arguments (spc) ())

  (define-option-require opt decl)
    <= (((tree-in? t (quote (float)))) (tm-define-overloaded (focus-has-preferences? t) #t))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (float)))) (tm-define-overloaded (focus-has-preferences? t) #t))

  (define-option-require opt decl)
    <= (((== l "float")) (tm-define-overloaded (standard-parameters l) (list "page-float-sep")))
    => (define-option-match opt decl) <= ((lambda (l) (== l "float")) (tm-define-overloaded (standard-parameters l) (list "page-float-sep")))

  (define-option-require opt decl)
    <= (((tree-is? t (quote embold))) (tm-define-overloaded (customizable-parameters t) (list (list "embold-strength" "Strength"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote embold))) (tm-define-overloaded (customizable-parameters t) (list (list "embold-strength" "Strength"))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote embbb))) (tm-define-overloaded (customizable-parameters t) (list (list "embbb-strength" "Strength"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote embbb))) (tm-define-overloaded (customizable-parameters t) (list (list "embbb-strength" "Strength"))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote slanted))) (tm-define-overloaded (customizable-parameters t) (list (list "slanted-slope" "Slope"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote slanted))) (tm-define-overloaded (customizable-parameters t) (list (list "slanted-slope" "Slope"))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote hmagnified))) (tm-define-overloaded (customizable-parameters t) (list (list "hmagnified-factor" "Factor"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote hmagnified))) (tm-define-overloaded (customizable-parameters t) (list (list "hmagnified-factor" "Factor"))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote vmagnified))) (tm-define-overloaded (customizable-parameters t) (list (list "vmagnified-factor" "Factor"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote vmagnified))) (tm-define-overloaded (customizable-parameters t) (list (list "vmagnified-factor" "Factor"))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote condensed))) (tm-define-overloaded (customizable-parameters t) (list (list "condensed-factor" "Factor"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote condensed))) (tm-define-overloaded (customizable-parameters t) (list (list "condensed-factor" "Factor"))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote extended))) (tm-define-overloaded (customizable-parameters t) (list (list "extended-factor" "Factor"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote extended))) (tm-define-overloaded (customizable-parameters t) (list (list "extended-factor" "Factor"))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote degraded))) (tm-define-overloaded (customizable-parameters t) (list (list "degraded-threshold" "Threshold") (list "degraded-frequency" "Frequency"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote degraded))) (tm-define-overloaded (customizable-parameters t) (list (list "degraded-threshold" "Threshold") (list "degraded-frequency" "Frequency"))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote distorted))) (tm-define-overloaded (customizable-parameters t) (list (list "distorted-strength" "Strength") (list "distorted-frequency" "Frequency"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote distorted))) (tm-define-overloaded (customizable-parameters t) (list (list "distorted-strength" "Strength") (list "distorted-frequency" "Frequency"))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote gnawed))) (tm-define-overloaded (customizable-parameters t) (list (list "gnawed-strength" "Strength") (list "gnawed-frequency" "Frequency"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote gnawed))) (tm-define-overloaded (customizable-parameters t) (list (list "gnawed-strength" "Strength") (list "gnawed-frequency" "Frequency"))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (blur gaussian-blur oval-blur rectangular-blur)))) (tm-define-overloaded (customizable-parameters t) (list (list "blur-pen-width" "Pen width") (list "blur-pen-height" "Pen height") (list "blur-pen-angle" "Pen angle"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (blur gaussian-blur oval-blur rectangular-blur)))) (tm-define-overloaded (customizable-parameters t) (list (list "blur-pen-width" "Pen width") (list "blur-pen-height" "Pen height") (list "blur-pen-angle" "Pen angle"))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (motion-blur)))) (tm-define-overloaded (customizable-parameters t) (list (list "blur-pen-dx" "Pen dx") (list "blur-pen-dy" "Pen dy"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (motion-blur)))) (tm-define-overloaded (customizable-parameters t) (list (list "blur-pen-dx" "Pen dx") (list "blur-pen-dy" "Pen dy"))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (outline gaussian-outline oval-outline rectangular-outline)))) (tm-define-overloaded (customizable-parameters t) (list (list "outline-pen-width" "Pen width") (list "outline-pen-height" "Pen height") (list "outline-pen-angle" "Pen angle"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (outline gaussian-outline oval-outline rectangular-outline)))) (tm-define-overloaded (customizable-parameters t) (list (list "outline-pen-width" "Pen width") (list "outline-pen-height" "Pen height") (list "outline-pen-angle" "Pen angle"))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (motion-outline)))) (tm-define-overloaded (customizable-parameters t) (list (list "outline-pen-dx" "Pen dx") (list "outline-pen-dy" "Pen dy"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (motion-outline)))) (tm-define-overloaded (customizable-parameters t) (list (list "outline-pen-dx" "Pen dx") (list "outline-pen-dy" "Pen dy"))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (thicken gaussian-thicken oval-thicken rectangular-thicken)))) (tm-define-overloaded (customizable-parameters t) (list (list "thicken-pen-width" "Pen width") (list "thicken-pen-height" "Pen height") (list "thicken-pen-angle" "Pen angle"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (thicken gaussian-thicken oval-thicken rectangular-thicken)))) (tm-define-overloaded (customizable-parameters t) (list (list "thicken-pen-width" "Pen width") (list "thicken-pen-height" "Pen height") (list "thicken-pen-angle" "Pen angle"))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (motion-thicken)))) (tm-define-overloaded (customizable-parameters t) (list (list "thicken-pen-dx" "Pen dx") (list "thicken-pen-dy" "Pen dy"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (motion-thicken)))) (tm-define-overloaded (customizable-parameters t) (list (list "thicken-pen-dx" "Pen dx") (list "thicken-pen-dy" "Pen dy"))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (erode gaussian-erode oval-erode rectangular-erode)))) (tm-define-overloaded (customizable-parameters t) (list (list "erode-pen-width" "Pen width") (list "erode-pen-height" "Pen height") (list "erode-pen-angle" "Pen angle"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (erode gaussian-erode oval-erode rectangular-erode)))) (tm-define-overloaded (customizable-parameters t) (list (list "erode-pen-width" "Pen width") (list "erode-pen-height" "Pen height") (list "erode-pen-angle" "Pen angle"))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (motion-erode)))) (tm-define-overloaded (customizable-parameters t) (list (list "erode-pen-dx" "Pen dx") (list "erode-pen-dy" "Pen dy"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (motion-erode)))) (tm-define-overloaded (customizable-parameters t) (list (list "erode-pen-dx" "Pen dx") (list "erode-pen-dy" "Pen dy"))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (shadow shadowed-raise)))) (tm-define-overloaded (customizable-parameters t) (list (list "shadow-dx" "Dx") (list "shadow-dy" "Dy") (list "shadow-color" "Color") (list "shadow-blur-radius" "Blur radius"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (shadow shadowed-raise)))) (tm-define-overloaded (customizable-parameters t) (list (list "shadow-dx" "Dx") (list "shadow-dy" "Dy") (list "shadow-color" "Color") (list "shadow-blur-radius" "Blur radius"))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (engrave)))) (tm-define-overloaded (customizable-parameters t) (list (list "engrave-dx" "Dx") (list "engrave-dy" "Dy") (list "engrave-color" "Color"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (engrave)))) (tm-define-overloaded (customizable-parameters t) (list (list "engrave-dx" "Dx") (list "engrave-dy" "Dy") (list "engrave-color" "Color"))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (emboss)))) (tm-define-overloaded (customizable-parameters t) (list (list "emboss-dx" "Dx") (list "emboss-dy" "Dy") (list "emboss-color" "Color"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (emboss)))) (tm-define-overloaded (customizable-parameters t) (list (list "emboss-dx" "Dx") (list "emboss-dy" "Dy") (list "emboss-color" "Color"))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (outlined-engrave)))) (tm-define-overloaded (customizable-parameters t) (list (list "engrave-dx" "Dx") (list "engrave-dy" "Dy") (list "outline-pen-width" "Pen width") (list "outline-pen-height" "Pen height") (list "outline-pen-angle" "Pen angle"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (outlined-engrave)))) (tm-define-overloaded (customizable-parameters t) (list (list "engrave-dx" "Dx") (list "engrave-dy" "Dy") (list "outline-pen-width" "Pen width") (list "outline-pen-height" "Pen height") (list "outline-pen-angle" "Pen angle"))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (outlined-emboss)))) (tm-define-overloaded (customizable-parameters t) (list (list "emboss-dx" "Dx") (list "emboss-dy" "Dy") (list "outline-pen-width" "Pen width") (list "outline-pen-height" "Pen height") (list "outline-pen-angle" "Pen angle"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (outlined-emboss)))) (tm-define-overloaded (customizable-parameters t) (list (list "emboss-dx" "Dx") (list "emboss-dy" "Dy") (list "outline-pen-width" "Pen width") (list "outline-pen-height" "Pen height") (list "outline-pen-angle" "Pen angle"))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (degrade)))) (tm-define-overloaded (customizable-parameters t) (list (list "degrade-wavelen-x" "Wave length x") (list "degrade-wavelen-y" "Wave length y") (list "degrade-threshold" "Threshold") (list "degrade-sharpness" "Sharpness"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (degrade)))) (tm-define-overloaded (customizable-parameters t) (list (list "degrade-wavelen-x" "Wave length x") (list "degrade-wavelen-y" "Wave length y") (list "degrade-threshold" "Threshold") (list "degrade-sharpness" "Sharpness"))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (distort)))) (tm-define-overloaded (customizable-parameters t) (list (list "distort-wavelen-x" "Wave length x") (list "distort-wavelen-y" "Wave length y") (list "distort-radius-x" "Radius x") (list "distort-radius-y" "Radius y"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (distort)))) (tm-define-overloaded (customizable-parameters t) (list (list "distort-wavelen-x" "Wave length x") (list "distort-wavelen-y" "Wave length y") (list "distort-radius-x" "Radius x") (list "distort-radius-y" "Radius y"))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (gnaw)))) (tm-define-overloaded (customizable-parameters t) (list (list "gnaw-wavelen-x" "Wave length x") (list "gnaw-wavelen-y" "Wave length y") (list "gnaw-radius-x" "Radius x") (list "gnaw-radius-y" "Radius y"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (gnaw)))) (tm-define-overloaded (customizable-parameters t) (list (list "gnaw-wavelen-x" "Wave length x") (list "gnaw-wavelen-y" "Wave length y") (list "gnaw-radius-x" "Radius x") (list "gnaw-radius-y" "Radius y"))))

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" test-effect-pen?) (tm-define-overloaded (set-effect-pen t pen) (when (not (tree? t)) (set! t (tree-innermost pen-effect-context?))) (cond ((not (tree? t)) (noop)) ((tree-in? t (quote (blur gaussian-blur oval-blur rectangular-blur motion-blur))) (cond ((== pen "gaussian") (variant-set t (quote gaussian-blur))) ((== pen "oval") (variant-set t (quote oval-blur))) ((== pen "rectangular") (variant-set t (quote rectangular-blur))) ((== pen "motion") (variant-set t (quote motion-blur))))) ((tree-in? t (quote (outline gaussian-outline oval-outline rectangular-outline motion-outline))) (cond ((== pen "gaussian") (variant-set t (quote gaussian-outline))) ((== pen "oval") (variant-set t (quote oval-outline))) ((== pen "rectangular") (variant-set t (quote rectangular-outline))) ((== pen "motion") (variant-set t (quote motion-outline))))) ((tree-in? t (quote (thicken gaussian-thicken oval-thicken rectangular-thicken motion-thicken))) (cond ((== pen "gaussian") (variant-set t (quote gaussian-thicken))) ((== pen "oval") (variant-set t (quote oval-thicken))) ((== pen "rectangular") (variant-set t (quote rectangular-thicken))) ((== pen "motion") (variant-set t (quote motion-thicken))))) ((tree-in? t (quote (erode gaussian-erode oval-erode rectangular-erode motion-erode))) (cond ((== pen "gaussian") (variant-set t (quote gaussian-erode))) ((== pen "oval") (variant-set t (quote oval-erode))) ((== pen "rectangular") (variant-set t (quote rectangular-erode))) ((== pen "motion") (variant-set t (quote motion-erode))))))))
    => ((quote set-effect-pen) #:check-mark (list "*" test-effect-pen?))
 => cons <> cur-props
    => cur-props => (((quote set-effect-pen) #:check-mark (list "*" test-effect-pen?)))

(property-set! var prop what conds*)
  <= (set-effect-pen #:check-mark ("*" #<procedure test-effect-pen? (t pen)>) ())

  (define-option-require opt decl)
    <= (((in? p (list "centered-program" "framed-program"))) (tm-define-overloaded (style-category p) #:program-theme))
    => (define-option-match opt decl) <= ((lambda (p) (in? p (list "centered-program" "framed-program"))) (tm-define-overloaded (style-category p) #:program-theme))

  (define-option-require opt decl)
    <= (((and (tree-is-buffer? t) (in-text?) (!= (get-env "language") "verbatim"))) (tm-define-overloaded (kbd-space-bar t shift?) (let* ((b (before-cursor)) (p (get-preference "text spacebar"))) (cond ((== p "allow multiple spaces") (insert " ")) ((and (== b " ") (== p "no multiple spaces")) (noop)) ((== b " ") (remove-text #f) (make-space "1em")) ((and (tree? b) (tree-func? b (quote space) 1)) (if (and (tree-atomic? (tree-ref b 0)) (string-ends? (tree->string (tree-ref b 0)) "em")) (make-space "1em") (geometry-horizontal b #t))) (else (insert " "))))))
    => (define-option-match opt decl) <= ((lambda (t shift?) (and (tree-is-buffer? t) (in-text?) (!= (get-env "language") "verbatim"))) (tm-define-overloaded (kbd-space-bar t shift?) (let* ((b (before-cursor)) (p (get-preference "text spacebar"))) (cond ((== p "allow multiple spaces") (insert " ")) ((and (== b " ") (== p "no multiple spaces")) (noop)) ((== b " ") (remove-text #f) (make-space "1em")) ((and (tree? b) (tree-func? b (quote space) 1)) (if (and (tree-atomic? (tree-ref b 0)) (string-ends? (tree->string (tree-ref b 0)) "em")) (make-space "1em") (geometry-horizontal b #t))) (else (insert " "))))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote title))) (tm-define-overloaded (kbd-enter t shift?) (go-end-line) (insert-return)))
    => (define-option-match opt decl) <= ((lambda (t shift?) (tree-is? t (quote title))) (tm-define-overloaded (kbd-enter t shift?) (go-end-line) (insert-return)))

  (define-option-require opt decl)
    <= (((tree-is? t (quote doc-title))) (tm-define-overloaded (kbd-enter t shift?) (make-doc-data-element (quote doc-author))))
    => (define-option-match opt decl) <= ((lambda (t shift?) (tree-is? t (quote doc-title))) (tm-define-overloaded (kbd-enter t shift?) (make-doc-data-element (quote doc-author))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote author-name))) (tm-define-overloaded (kbd-enter t shift?) (make-author-data-element (quote author-affiliation))))
    => (define-option-match opt decl) <= ((lambda (t shift?) (tree-is? t (quote author-name))) (tm-define-overloaded (kbd-enter t shift?) (make-author-data-element (quote author-affiliation))))

  (define-option-require opt decl)
    <= (((or (tree-is? t (quote abstract-arxiv)) (tree-is? t (quote abstract-pacs)) (tree-is? t (quote abstract-acm)) (tree-is? t (quote abstract-msc)) (tree-is? t (quote abstract-keywords)))) (tm-define-overloaded (kbd-enter t shift?) (with t (tree-search-upwards t (quote (abstract-msc abstract-acm abstract-pacs abstract-arxiv abstract-keywords))) (with pos (1+ (tree-down-index t)) (tree-insert! t pos (quasiquote ((concat "")))) (tree-go-to t pos 0 0)))))
    => (define-option-match opt decl) <= ((lambda (t shift?) (or (tree-is? t (quote abstract-arxiv)) (tree-is? t (quote abstract-pacs)) (tree-is? t (quote abstract-acm)) (tree-is? t (quote abstract-msc)) (tree-is? t (quote abstract-keywords)))) (tm-define-overloaded (kbd-enter t shift?) (with t (tree-search-upwards t (quote (abstract-msc abstract-acm abstract-pacs abstract-arxiv abstract-keywords))) (with pos (1+ (tree-down-index t)) (tree-insert! t pos (quasiquote ((concat "")))) (tree-go-to t pos 0 0)))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote doc-inactive))) (tm-define-overloaded (kbd-enter t shift?) (doc-data-activate-here)))
    => (define-option-match opt decl) <= ((lambda (t shift?) (tree-is? t (quote doc-inactive))) (tm-define-overloaded (kbd-enter t shift?) (doc-data-activate-here)))

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" test-doc-title-clustering?) (tm-define-overloaded (set-doc-title-clustering mode) (with cl (list "cluster-all" "cluster-by-affiliation") (with old (list-difference (get-doc-title-options) cl) (set-doc-title-options (if mode (cons mode old) old))))))
    => ((quote set-doc-title-clustering) #:check-mark (list "*" test-doc-title-clustering?))
 => cons <> cur-props
    => cur-props => (((quote set-doc-title-clustering) #:check-mark (list "*" test-doc-title-clustering?)))

(property-set! var prop what conds*)
  <= (set-doc-title-clustering #:check-mark ("*" #<procedure test-doc-title-clustering? (mode)>) ())

  (define-option-require opt decl)
    <= (((section-context? t)) (tm-define-overloaded (kbd-enter t shift?) (tree-go-to t #:end) (insert-return)))
    => (define-option-match opt decl) <= ((lambda (t shift?) (section-context? t)) (tm-define-overloaded (kbd-enter t shift?) (tree-go-to t #:end) (insert-return)))

  (define-option-require opt decl)
    <= (((section-context? t)) (tm-define-overloaded (label-insert t) (tree-go-to t #:end) (make (quote label))))
    => (define-option-match opt decl) <= ((lambda (t) (section-context? t)) (tm-define-overloaded (label-insert t) (tree-go-to t #:end) (make (quote label))))

  (define-option-require opt decl)
    <= (((list-context? t)) (tm-define-overloaded (kbd-enter t shift?) (if shift? (make-return-after) (make-item))))
    => (define-option-match opt decl) <= ((lambda (t shift?) (list-context? t)) (tm-define-overloaded (kbd-enter t shift?) (if shift? (make-return-after) (make-item))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote item*))) (tm-define-overloaded (kbd-enter t shift?) (go-end-of (quote item*))))
    => (define-option-match opt decl) <= ((lambda (t shift?) (tree-is? t (quote item*))) (tm-define-overloaded (kbd-enter t shift?) (go-end-of (quote item*))))

  (define-option-require opt decl)
    <= (((or (itemize-context? t) (enumerate-context? t))) (tm-define-overloaded (numbered-context? t) #t))
    => (define-option-match opt decl) <= ((lambda (t) (or (itemize-context? t) (enumerate-context? t))) (tm-define-overloaded (numbered-context? t) #t))

  (define-option-require opt decl)
    <= (((enumerate-context? t)) (tm-define-overloaded (numbered-numbered? t) #t))
    => (define-option-match opt decl) <= ((lambda (t) (enumerate-context? t)) (tm-define-overloaded (numbered-numbered? t) #t))

  (define-option-require opt decl)
    <= (((itemize-context? t)) (tm-define-overloaded (numbered-toggle t) (variant-set t (quote enumerate))))
    => (define-option-match opt decl) <= ((lambda (t) (itemize-context? t)) (tm-define-overloaded (numbered-toggle t) (variant-set t (quote enumerate))))

  (define-option-require opt decl)
    <= (((enumerate-context? t)) (tm-define-overloaded (numbered-toggle t) (variant-set t (quote itemize))))
    => (define-option-match opt decl) <= ((lambda (t) (enumerate-context? t)) (tm-define-overloaded (numbered-toggle t) (variant-set t (quote itemize))))

  (define-option-require opt decl)
    <= (((== l "itemize")) (tm-define-overloaded (standard-parameters l) (cons "itemize-levels" (search-parameters "itemize-1"))))
    => (define-option-match opt decl) <= ((lambda (l) (== l "itemize")) (tm-define-overloaded (standard-parameters l) (cons "itemize-levels" (search-parameters "itemize-1"))))

  (define-option-require opt decl)
    <= (((== l "enumerate")) (tm-define-overloaded (standard-parameters l) (cons "enumerate-levels" (search-parameters "enumerate-1"))))
    => (define-option-match opt decl) <= ((lambda (l) (== l "enumerate")) (tm-define-overloaded (standard-parameters l) (cons "enumerate-levels" (search-parameters "enumerate-1"))))

  (define-option-require opt decl)
    <= (((in? l (list "itemize-levels" "enumerate-levels"))) (tm-define-overloaded (parameter-choice-list l) (list "1" "2" "3" "4")))
    => (define-option-match opt decl) <= ((lambda (l) (in? l (list "itemize-levels" "enumerate-levels"))) (tm-define-overloaded (parameter-choice-list l) (list "1" "2" "3" "4")))

  (define-option-proposals opt decl)
    <= ((hyph (list (tm->string (selection-tree)))) (tm-define-overloaded (hyphenate-selection-as hyph) (with ins (quasiquote (hyphenate-as (unquote hyph) (unquote (selection-tree)))) (clipboard-cut "null") (insert ins))))
    => cons <> cur-props <= ((quote hyphenate-selection-as) (quote (#:proposals hyph)) (lambda () (list (tm->string (selection-tree)))))
    => cur-props => (((quote hyphenate-selection-as) (quote (#:proposals hyph)) (lambda () (list (tm->string (selection-tree))))))

  (define-option-argument opt decl)
    <= ((hyph "Hyphenate as") (tm-define-overloaded (hyphenate-selection-as hyph) (with ins (quasiquote (hyphenate-as (unquote hyph) (unquote (selection-tree)))) (clipboard-cut "null") (insert ins))))
    => cons <> cur-props <= ((quote hyphenate-selection-as) #:arguments (quote (hyph)))
    => cons <> cur-props <= ((quote hyphenate-selection-as) (quote (#:argument hyph)) (quote ("Hyphenate as")))
    => cur-props => (((quote hyphenate-selection-as) (quote (#:argument hyph)) (quote ("Hyphenate as"))) ((quote hyphenate-selection-as) #:arguments (quote (hyph))) ((quote hyphenate-selection-as) (quote (#:proposals hyph)) (lambda () (list (tm->string (selection-tree))))))

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (hyphenate-selection-as hyph) (with ins (quasiquote (hyphenate-as (unquote hyph) (unquote (selection-tree)))) (clipboard-cut "null") (insert ins))))
    => ((quote hyphenate-selection-as) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote hyphenate-selection-as) #:interactive (list #t)) ((quote hyphenate-selection-as) (quote (#:argument hyph)) (quote ("Hyphenate as"))) ((quote hyphenate-selection-as) #:arguments (quote (hyph))) ((quote hyphenate-selection-as) (quote (#:proposals hyph)) (lambda () (list (tm->string (selection-tree))))))

(property-set! var prop what conds*)
  <= (hyphenate-selection-as #:interactive (#t) ())

(property-set! var prop what conds*)
  <= (hyphenate-selection-as (#:argument hyph) ("Hyphenate as") ())

(property-set! var prop what conds*)
  <= (hyphenate-selection-as #:arguments (hyph) ())

(property-set! var prop what conds*)
  <= (hyphenate-selection-as (#:proposals hyph) #<procedure #f ()> ())

  (define-option-argument opt decl)
    <= ((file-name "Bibliography file") (tm-define-overloaded (make-bib file-name) (let* ((name (normalized-bib-name file-name)) (aux (if (context-has? "bib-prefix") (get-env "bib-prefix") "bib"))) (if (not (make-return-after)) (insert-go-to (quasiquote (bibliography (unquote aux) "tm-plain" (unquote name) (document ""))) (quote (3 0 0)))))))
    => cons <> cur-props <= ((quote make-bib) #:arguments (quote (file-name)))
    => cons <> cur-props <= ((quote make-bib) (quote (#:argument file-name)) (quote ("Bibliography file")))
    => cur-props => (((quote make-bib) (quote (#:argument file-name)) (quote ("Bibliography file"))) ((quote make-bib) #:arguments (quote (file-name))))

(property-set! var prop what conds*)
  <= (make-bib (#:argument file-name) ("Bibliography file") ())

(property-set! var prop what conds*)
  <= (make-bib #:arguments (file-name) ())

  (define-option-proposals opt decl)
    <= ((new-name (list (automatic-section-name))) (tm-define-overloaded (automatic-section-rename new-name) (with-innermost t automatic-section-context? (when t (let* ((l (tree-label t)) (l* (symbol-append l (quote *)))) (tree-set t (quasiquote ((unquote l*) (unquote-splicing (cDr (tm-children t))) (unquote new-name) (unquote (tm-ref t #:last))))))))))
    => cons <> cur-props <= ((quote automatic-section-rename) (quote (#:proposals new-name)) (lambda () (list (automatic-section-name))))
    => cur-props => (((quote automatic-section-rename) (quote (#:proposals new-name)) (lambda () (list (automatic-section-name)))))

  (define-option-argument opt decl)
    <= ((new-name "New name") (tm-define-overloaded (automatic-section-rename new-name) (with-innermost t automatic-section-context? (when t (let* ((l (tree-label t)) (l* (symbol-append l (quote *)))) (tree-set t (quasiquote ((unquote l*) (unquote-splicing (cDr (tm-children t))) (unquote new-name) (unquote (tm-ref t #:last))))))))))
    => cons <> cur-props <= ((quote automatic-section-rename) #:arguments (quote (new-name)))
    => cons <> cur-props <= ((quote automatic-section-rename) (quote (#:argument new-name)) (quote ("New name")))
    => cur-props => (((quote automatic-section-rename) (quote (#:argument new-name)) (quote ("New name"))) ((quote automatic-section-rename) #:arguments (quote (new-name))) ((quote automatic-section-rename) (quote (#:proposals new-name)) (lambda () (list (automatic-section-name)))))

(property-set! var prop what conds*)
  <= (automatic-section-rename (#:argument new-name) ("New name") ())

(property-set! var prop what conds*)
  <= (automatic-section-rename #:arguments (new-name) ())

(property-set! var prop what conds*)
  <= (automatic-section-rename (#:proposals new-name) #<procedure #f ()> ())

  (define-option-require opt decl)
    <= (((in? p (list "framed-theorems" "hanging-theorems"))) (tm-define-overloaded (style-category p) #:theorem-decorations))
    => (define-option-match opt decl) <= ((lambda (p) (in? p (list "framed-theorems" "hanging-theorems"))) (tm-define-overloaded (style-category p) #:theorem-decorations))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (padded padded-titled)))) (tm-define-overloaded (customizable-parameters t) (list (list "padding-above" "Above") (list "padding-below" "Below"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (padded padded-titled)))) (tm-define-overloaded (customizable-parameters t) (list (list "padding-above" "Above") (list "padding-below" "Below"))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (overlined overlined-titled)))) (tm-define-overloaded (customizable-parameters t) (list (list "padding-above" "Above") (list "padding-below" "Below") (list "overlined-sep" "Inner"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (overlined overlined-titled)))) (tm-define-overloaded (customizable-parameters t) (list (list "padding-above" "Above") (list "padding-below" "Below") (list "overlined-sep" "Inner"))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (underlined underlined-titled)))) (tm-define-overloaded (customizable-parameters t) (list (list "padding-above" "Above") (list "padding-below" "Below") (list "underlined-sep" "Inner"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (underlined underlined-titled)))) (tm-define-overloaded (customizable-parameters t) (list (list "padding-above" "Above") (list "padding-below" "Below") (list "underlined-sep" "Inner"))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (bothlined bothlined-titled)))) (tm-define-overloaded (customizable-parameters t) (list (list "padding-above" "Above") (list "padding-below" "Below") (list "overlined-sep" "Top") (list "underlined-sep" "Bottom"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (bothlined bothlined-titled)))) (tm-define-overloaded (customizable-parameters t) (list (list "padding-above" "Above") (list "padding-below" "Below") (list "overlined-sep" "Top") (list "underlined-sep" "Bottom"))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (framed framed-titled)))) (tm-define-overloaded (customizable-parameters t) (list (list "padding-above" "Above") (list "padding-below" "Below") (list "framed-vsep" "Inner") (list "framed-hsep" "Indentation") (list "framed-color" "Color"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (framed framed-titled)))) (tm-define-overloaded (customizable-parameters t) (list (list "padding-above" "Above") (list "padding-below" "Below") (list "framed-vsep" "Inner") (list "framed-hsep" "Indentation") (list "framed-color" "Color"))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote ornamented))) (tm-define-overloaded (customizable-parameters t) (list (list "padding-above" "Above") (list "padding-below" "Below") (list "ornament-vpadding" "Inner") (list "ornament-hpadding" "Indentation") (list "ornament-color" "Color") (list "ornament-shape" "Shape"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote ornamented))) (tm-define-overloaded (customizable-parameters t) (list (list "padding-above" "Above") (list "padding-below" "Below") (list "ornament-vpadding" "Inner") (list "ornament-hpadding" "Indentation") (list "ornament-color" "Color") (list "ornament-shape" "Shape"))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote ornamented-titled))) (tm-define-overloaded (customizable-parameters t) (list (list "padding-above" "Above") (list "padding-below" "Below") (list "ornament-vpadding" "Inner") (list "ornament-hpadding" "Indentation") (list "ornament-color" "Color") (list "ornament-shape" "Shape") (list "ornament-extra-color" "Title color") (list "ornament-title-style" "Title style"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote ornamented-titled))) (tm-define-overloaded (customizable-parameters t) (list (list "padding-above" "Above") (list "padding-below" "Below") (list "ornament-vpadding" "Inner") (list "ornament-hpadding" "Indentation") (list "ornament-color" "Color") (list "ornament-shape" "Shape") (list "ornament-extra-color" "Title color") (list "ornament-title-style" "Title style"))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote ornament))) (tm-define-overloaded (customizable-parameters t) (append (list (list "ornament-shape" "Shape") (list "ornament-color" "Color")) (if (== (tree-arity t) 1) (list) (list (list "ornament-title-style" "Title style") (list "ornament-extra-color" "Title color"))) (list (list "ornament-border" "Border width") (list "ornament-hpadding" "Horizontal padding") (list "ornament-vpadding" "Vertical padding")))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote ornament))) (tm-define-overloaded (customizable-parameters t) (append (list (list "ornament-shape" "Shape") (list "ornament-color" "Color")) (if (== (tree-arity t) 1) (list) (list (list "ornament-title-style" "Title style") (list "ornament-extra-color" "Title color"))) (list (list "ornament-border" "Border width") (list "ornament-hpadding" "Horizontal padding") (list "ornament-vpadding" "Vertical padding")))))

  (define-option-require opt decl)
    <= (((tree-in? t (ornament-tag-list))) (tm-define-overloaded (customizable-parameters t) (list (list "ornament-shape" "Shape") (list "ornament-border" "Border width") (list "ornament-hpadding" "Horizontal padding") (list "ornament-vpadding" "Vertical padding"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (ornament-tag-list))) (tm-define-overloaded (customizable-parameters t) (list (list "ornament-shape" "Shape") (list "ornament-border" "Border width") (list "ornament-hpadding" "Horizontal padding") (list "ornament-vpadding" "Vertical padding"))))

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" cursor-at-anchor?) (tm-define-overloaded (cursor-toggle-anchor) (if (cursor-at-anchor?) (go-to-float) (go-to-anchor))))
    => ((quote cursor-toggle-anchor) #:check-mark (list "v" cursor-at-anchor?))
 => cons <> cur-props
    => cur-props => (((quote cursor-toggle-anchor) #:check-mark (list "v" cursor-at-anchor?)))

(property-set! var prop what conds*)
  <= (cursor-toggle-anchor #:check-mark ("v" #<procedure cursor-at-anchor? ()>) ())

  (define-option-require opt decl)
    <= (((in? p (beamer-themes))) (tm-define-overloaded (style-category p) #:beamer-theme))
    => (define-option-match opt decl) <= ((lambda (p) (in? p (beamer-themes))) (tm-define-overloaded (style-category p) #:beamer-theme))

  (define-option-require opt decl)
    <= (((in? p (list "title-bar" "framed-title"))) (tm-define-overloaded (style-category p) #:beamer-title-theme))
    => (define-option-match opt decl) <= ((lambda (p) (in? p (list "title-bar" "framed-title"))) (tm-define-overloaded (style-category p) #:beamer-title-theme))

  (define-option-require opt decl)
    <= (((and (== x #:beamer-theme) (in? y (list #:beamer-title-theme #:theorem-decorations)))) (tm-define-overloaded (style-category-precedes? x y) #t))
    => (define-option-match opt decl) <= ((lambda (x y) (and (== x #:beamer-theme) (in? y (list #:beamer-title-theme #:theorem-decorations)))) (tm-define-overloaded (style-category-precedes? x y) #t))

  (define-option-require opt decl)
    <= (((and (== x "beamer") (in? y (list "title-bar" "bluish" "framed-session")))) (tm-define-overloaded (style-includes? x y) #t))
    => (define-option-match opt decl) <= ((lambda (x y) (and (== x "beamer") (in? y (list "title-bar" "bluish" "framed-session")))) (tm-define-overloaded (style-includes? x y) #t))

  (define-option-require opt decl)
    <= (((and (== x "old-beamer") (in? y (list "framed-title" "ridged-paper" "framed-session")))) (tm-define-overloaded (style-includes? x y) #t))
    => (define-option-match opt decl) <= ((lambda (x y) (and (== x "old-beamer") (in? y (list "framed-title" "ridged-paper" "framed-session")))) (tm-define-overloaded (style-includes? x y) #t))

  (define-option-require opt decl)
    <= (((dynamic-context? t)) (tm-define-overloaded (structured-horizontal t forwards?) (dynamic-incremental t forwards?)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (dynamic-context? t)) (tm-define-overloaded (structured-horizontal t forwards?) (dynamic-incremental t forwards?)))

  (define-option-require opt decl)
    <= (((dynamic-context? t)) (tm-define-overloaded (structured-vertical t downwards?) (dynamic-incremental t downwards?)))
    => (define-option-match opt decl) <= ((lambda (t downwards?) (dynamic-context? t)) (tm-define-overloaded (structured-vertical t downwards?) (dynamic-incremental t downwards?)))

  (define-option-require opt decl)
    <= (((dynamic-context? t)) (tm-define-overloaded (structured-extremal t forwards?) (dynamic-extremal t forwards?)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (dynamic-context? t)) (tm-define-overloaded (structured-extremal t forwards?) (dynamic-extremal t forwards?)))

  (define-option-require opt decl)
    <= (((dynamic-context? t)) (tm-define-overloaded (structured-incremental t downwards?) (dynamic-extremal t downwards?)))
    => (define-option-match opt decl) <= ((lambda (t downwards?) (dynamic-context? t)) (tm-define-overloaded (structured-incremental t downwards?) (dynamic-extremal t downwards?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Insert a 'fold' environment") (tm-define-overloaded (make-toggle tag) (insert-go-to (quasiquote ((unquote tag) (document "") (document ""))) (list 0 0))))
   => ((quote make-toggle) #:synopsis (quote ("Insert a 'fold' environment")))
 => cons <> cur-props
   => cur-props => (((quote make-toggle) #:synopsis (quote ("Insert a 'fold' environment"))))

  ((define-property which)  opt decl)
    <= ((#:type)  ((-> void)) (tm-define-overloaded (make-toggle tag) (insert-go-to (quasiquote ((unquote tag) (document "") (document ""))) (list 0 0))))
   => ((quote make-toggle) #:type (quote ((-> void))))
 => cons <> cur-props
   => cur-props => (((quote make-toggle) #:type (quote ((-> void)))) ((quote make-toggle) #:synopsis (quote ("Insert a 'fold' environment"))))

(property-set! var prop what conds*)
  <= (make-toggle #:type ((-> void)) ())

(property-set! var prop what conds*)
  <= (make-toggle #:synopsis ("Insert a 'fold' environment") ())

  (define-option-require opt decl)
    <= (((toggle-context? t)) (tm-define-overloaded (alternate-toggle t) (with i (if (toggle-first-context? t) 1 0) (variant-set t (ahash-ref alternate-table (tree-label t))) (tree-go-to t i #:start) (when (> i 0) (players-set-elapsed (tree-ref t i) 0.0)))))
    => (define-option-match opt decl) <= ((lambda (t) (toggle-context? t)) (tm-define-overloaded (alternate-toggle t) (with i (if (toggle-first-context? t) 1 0) (variant-set t (ahash-ref alternate-table (tree-label t))) (tree-go-to t i #:start) (when (> i 0) (players-set-elapsed (tree-ref t i) 0.0)))))

  (define-option-require opt decl)
    <= (((toggle-context? t)) (tm-define-overloaded (dynamic-extremal t forwards?) (with action (if forwards? alternate-unfold alternate-fold) (action t))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (toggle-context? t)) (tm-define-overloaded (dynamic-extremal t forwards?) (with action (if forwards? alternate-unfold alternate-fold) (action t))))

  (define-option-require opt decl)
    <= (((toggle-context? t)) (tm-define-overloaded (dynamic-incremental t forwards?) (with action (if forwards? alternate-unfold alternate-fold) (action t))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (toggle-context? t)) (tm-define-overloaded (dynamic-incremental t forwards?) (with action (if forwards? alternate-unfold alternate-fold) (action t))))

  (define-option-require opt decl)
    <= (((toggle-context? t)) (tm-define-overloaded (tree-show-hidden t) (alternate-toggle t)))
    => (define-option-match opt decl) <= ((lambda (t) (toggle-context? t)) (tm-define-overloaded (tree-show-hidden t) (alternate-toggle t)))

  (define-option-require opt decl)
    <= (((unroll-context? t)) (tm-define-overloaded (get-hidden-tag t) (quote hidden*)))
    => (define-option-match opt decl) <= ((lambda (t) (unroll-context? t)) (tm-define-overloaded (get-hidden-tag t) (quote hidden*)))

  (define-option-require opt decl)
    <= (((alternative-context? t)) (tm-define-overloaded (switch-select t i) (switch-set-range t 0 #:last #f) (switch-set t i #t)))
    => (define-option-match opt decl) <= ((lambda (t i) (alternative-context? t)) (tm-define-overloaded (switch-select t i) (switch-set-range t 0 #:last #f) (switch-set t i #t)))

  (define-option-require opt decl)
    <= (((unroll-context? t)) (tm-define-overloaded (switch-select t i) (switch-set-range t 0 (+ i 1) #t) (switch-set-range t (+ i 1) #:last #f)))
    => (define-option-match opt decl) <= ((lambda (t i) (unroll-context? t)) (tm-define-overloaded (switch-select t i) (switch-set-range t 0 (+ i 1) #t) (switch-set-range t (+ i 1) #:last #f)))

  (define-option-require opt decl)
    <= (((expanded-context? t)) (tm-define-overloaded (switch-select t i) (switch-set-range t 0 #:last #t)))
    => (define-option-match opt decl) <= ((lambda (t i) (expanded-context? t)) (tm-define-overloaded (switch-select t i) (switch-set-range t 0 #:last #t)))

  (define-option-require opt decl)
    <= (((switch-context? t)) (tm-define-overloaded (dynamic-extremal t forwards?) (if forwards? (switch-to t #:last #:end) (switch-to t #:first #:start))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (switch-context? t)) (tm-define-overloaded (dynamic-extremal t forwards?) (if forwards? (switch-to t #:last #:end) (switch-to t #:first #:start))))

  (define-option-require opt decl)
    <= (((switch-context? t)) (tm-define-overloaded (dynamic-incremental t forwards?) (if forwards? (switch-to t #:next #:start) (switch-to t #:previous #:end))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (switch-context? t)) (tm-define-overloaded (dynamic-incremental t forwards?) (if forwards? (switch-to t #:next #:start) (switch-to t #:previous #:end))))

  (define-option-require opt decl)
    <= (((switch-context? t)) (tm-define-overloaded (structured-insert-horizontal t forwards?) (switch-insert-at t (if forwards? #:var-next #:current) #f)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (switch-context? t)) (tm-define-overloaded (structured-insert-horizontal t forwards?) (switch-insert-at t (if forwards? #:var-next #:current) #f)))

  (define-option-require opt decl)
    <= (((switch-context? t)) (tm-define-overloaded (structured-insert-vertical t downwards?) (structured-insert-horizontal t downwards?)))
    => (define-option-match opt decl) <= ((lambda (t downwards?) (switch-context? t)) (tm-define-overloaded (structured-insert-vertical t downwards?) (structured-insert-horizontal t downwards?)))

  (define-option-require opt decl)
    <= (((switch-context? t)) (tm-define-overloaded (structured-remove-horizontal t forwards?) (with i (if forwards? #:current #:var-previous) (set! i (switch-index t i)) (cond ((< i 0) (tree-go-to t #:start)) ((>= i (tree-arity t)) (tree-go-to t #:end)) (else (switch-remove-at t i))))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (switch-context? t)) (tm-define-overloaded (structured-remove-horizontal t forwards?) (with i (if forwards? #:current #:var-previous) (set! i (switch-index t i)) (cond ((< i 0) (tree-go-to t #:start)) ((>= i (tree-arity t)) (tree-go-to t #:end)) (else (switch-remove-at t i))))))

  (define-option-require opt decl)
    <= (((switch-context? t)) (tm-define-overloaded (structured-remove-vertical t downwards?) (structured-remove-horizontal t downwards?)))
    => (define-option-match opt decl) <= ((lambda (t downwards?) (switch-context? t)) (tm-define-overloaded (structured-remove-vertical t downwards?) (structured-remove-horizontal t downwards?)))

  (define-option-require opt decl)
    <= (((switch-context? t)) (tm-define-overloaded (alternate-toggle t) (switch-to t #:rotate-forward)))
    => (define-option-match opt decl) <= ((lambda (t) (switch-context? t)) (tm-define-overloaded (alternate-toggle t) (switch-to t #:rotate-forward)))

  (define-option-require opt decl)
    <= (((switch-context? t)) (tm-define-overloaded (variant-circulate t forward?) (with i (switch-index t) (variant-circulate-in t (big-switch-tag-list) forward?) (switch-normalize-hidden t) (switch-select t i))))
    => (define-option-match opt decl) <= ((lambda (t forward?) (switch-context? t)) (tm-define-overloaded (variant-circulate t forward?) (with i (switch-index t) (variant-circulate-in t (big-switch-tag-list) forward?) (switch-normalize-hidden t) (switch-select t i))))

  (define-option-require opt decl)
    <= (((switch-context? t)) (tm-define-overloaded (tree-show-hidden t) (with i (tree-down-index t) (if (hidden-context? (tree-ref t i)) (switch-select t i)))))
    => (define-option-match opt decl) <= ((lambda (t) (switch-context? t)) (tm-define-overloaded (tree-show-hidden t) (with i (tree-down-index t) (if (hidden-context? (tree-ref t i)) (switch-select t i)))))

  (define-option-require opt decl)
    <= (((overlays-context? t)) (tm-define-overloaded (dynamic-extremal t forwards?) (let* ((tot (tree->number (tree-ref t 1))) (nxt (if forwards? tot 1))) (overlays-set t nxt) (when (not (tree-innermost overlay-context?)) (tree-go-to t 2 #:start)))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (overlays-context? t)) (tm-define-overloaded (dynamic-extremal t forwards?) (let* ((tot (tree->number (tree-ref t 1))) (nxt (if forwards? tot 1))) (overlays-set t nxt) (when (not (tree-innermost overlay-context?)) (tree-go-to t 2 #:start)))))

  (define-option-require opt decl)
    <= (((overlays-context? t)) (tm-define-overloaded (dynamic-incremental t forwards?) (let* ((cur (tree->number (tree-ref t 0))) (tot (tree->number (tree-ref t 1))) (inc (if forwards? 1 -1)) (nxt (min (max (+ cur inc) 1) tot))) (overlays-set t nxt) (when (not (tree-innermost overlay-context?)) (tree-go-to t 2 #:start)))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (overlays-context? t)) (tm-define-overloaded (dynamic-incremental t forwards?) (let* ((cur (tree->number (tree-ref t 0))) (tot (tree->number (tree-ref t 1))) (inc (if forwards? 1 -1)) (nxt (min (max (+ cur inc) 1) tot))) (overlays-set t nxt) (when (not (tree-innermost overlay-context?)) (tree-go-to t 2 #:start)))))

  (define-option-require opt decl)
    <= (((overlays-context? t)) (tm-define-overloaded (structured-horizontal? t) #t))
    => (define-option-match opt decl) <= ((lambda (t) (overlays-context? t)) (tm-define-overloaded (structured-horizontal? t) #t))

  (define-option-require opt decl)
    <= (((overlays-context? t)) (tm-define-overloaded (structured-insert-horizontal t forwards?) (let* ((cur (tree->number (tree-ref t 0))) (tot (tree->number (tree-ref t 1))) (ins (if forwards? (+ cur 1) cur))) (overlay-renumber (tree-ref t 2) ins tot 1) (when forwards? (tree-set t 0 (number->string ins)) (graphics-update-proviso (tree-ref t 2) (number->string ins))) (tree-set t 1 (number->string (+ tot 1))))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (overlays-context? t)) (tm-define-overloaded (structured-insert-horizontal t forwards?) (let* ((cur (tree->number (tree-ref t 0))) (tot (tree->number (tree-ref t 1))) (ins (if forwards? (+ cur 1) cur))) (overlay-renumber (tree-ref t 2) ins tot 1) (when forwards? (tree-set t 0 (number->string ins)) (graphics-update-proviso (tree-ref t 2) (number->string ins))) (tree-set t 1 (number->string (+ tot 1))))))

  (define-option-require opt decl)
    <= (((overlays-context? t)) (tm-define-overloaded (structured-remove-horizontal t forwards?) (let* ((cur (tree->number (tree-ref t 0))) (tot (tree->number (tree-ref t 1))) (del (if forwards? cur (- cur 1)))) (when (and (> del 0) (> tot 1)) (overlay-renumber (tree-ref t 2) del tot -1) (when (not forwards?) (tree-set t 0 (number->string del)) (graphics-update-proviso (tree-ref t 2) (number->string del))) (tree-set t 1 (number->string (- tot 1)))))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (overlays-context? t)) (tm-define-overloaded (structured-remove-horizontal t forwards?) (let* ((cur (tree->number (tree-ref t 0))) (tot (tree->number (tree-ref t 1))) (del (if forwards? cur (- cur 1)))) (when (and (> del 0) (> tot 1)) (overlay-renumber (tree-ref t 2) del tot -1) (when (not forwards?) (tree-set t 0 (number->string del)) (graphics-update-proviso (tree-ref t 2) (number->string del))) (tree-set t 1 (number->string (- tot 1)))))))

  (define-option-require opt decl)
    <= (((switch-list-context? t)) (tm-define-overloaded (kbd-enter t shift?) (if shift? (make-return-after) (begin (switch-insert-at t #:var-next #f) (make-item)))))
    => (define-option-match opt decl) <= ((lambda (t shift?) (switch-list-context? t)) (tm-define-overloaded (kbd-enter t shift?) (if shift? (make-return-after) (begin (switch-insert-at t #:var-next #f) (make-item)))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote tit))) (tm-define-overloaded (kbd-enter t shift?) (tree-go-to t #:end) (insert-return)))
    => (define-option-match opt decl) <= ((lambda (t shift?) (tree-is? t (quote tit))) (tm-define-overloaded (kbd-enter t shift?) (tree-go-to t #:end) (insert-return)))

  (define-option-require opt decl)
    <= (((tree-innermost screens-context?)) (tm-define-overloaded (nr-pages) (with t* (tree-innermost screens-context?) (with t (if (slideshow-context? t*) (tree-ref t* 0) t*) (tree-arity t)))))
    => (define-option-match opt decl) <= ((lambda () (tree-innermost screens-context?)) (tm-define-overloaded (nr-pages) (with t* (tree-innermost screens-context?) (with t (if (slideshow-context? t*) (tree-ref t* 0) t*) (tree-arity t)))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (screens-switch-to which) (and-with t (tree-innermost (quote screens)) (switch-to t which #:start))))
    => ((quote screens-switch-to) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote screens-switch-to) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (screens-switch-to #:secure (#t) ())

  (define-option-require opt decl)
    <= (((or (inside? (quote screens)) (inside? (quote slideshow)))) (tm-define-overloaded (init-page-rendering s) (with o (get-init-page-rendering) (when (and (expand-slides? s) (not (expand-slides? o))) (screens-show-all)) (when (and (not (expand-slides? s)) (expand-slides? o)) (screens-show-this)) (former s))))
    => (define-option-match opt decl) <= ((lambda (s) (or (inside? (quote screens)) (inside? (quote slideshow)))) (tm-define-overloaded (init-page-rendering s) (with o (get-init-page-rendering) (when (and (expand-slides? s) (not (expand-slides? o))) (screens-show-all)) (when (and (not (expand-slides? s)) (expand-slides? o)) (screens-show-this)) (former s))))

  (define-option-require opt decl)
    <= (((inside? (quote slideshow))) (tm-define-overloaded (screens-switch-to which) (and-with t (tree-innermost (quote slideshow)) (when (and (== (tree-arity t) 1) (tree-is? (tree-ref t 0) (quote document))) (set! t (tree-ref t 0)) (when (== which #:first) (set! which 0)) (when (== which #:last) (set! which (- (tree-arity t) 1))) (tree-go-to t which #:start)))))
    => (define-option-match opt decl) <= ((lambda (which) (inside? (quote slideshow))) (tm-define-overloaded (screens-switch-to which) (and-with t (tree-innermost (quote slideshow)) (when (and (== (tree-arity t) 1) (tree-is? (tree-ref t 0) (quote document))) (set! t (tree-ref t 0)) (when (== which #:first) (set! which 0)) (when (== which #:last) (set! which (- (tree-arity t) 1))) (tree-go-to t which #:start)))))

  (define-option-require opt decl)
    <= (((slideshow-context? t)) (tm-define-overloaded (structured-horizontal? t) #t))
    => (define-option-match opt decl) <= ((lambda (t) (slideshow-context? t)) (tm-define-overloaded (structured-horizontal? t) #t))

  (define-option-require opt decl)
    <= (((slideshow-context? t)) (tm-define-overloaded (focus-can-insert? t) #t))
    => (define-option-match opt decl) <= ((lambda (t) (slideshow-context? t)) (tm-define-overloaded (focus-can-insert? t) #t))

  (define-option-require opt decl)
    <= (((slideshow-context? t)) (tm-define-overloaded (focus-can-remove? t) #t))
    => (define-option-match opt decl) <= ((lambda (t) (slideshow-context? t)) (tm-define-overloaded (focus-can-remove? t) #t))

  (define-option-require opt decl)
    <= (((slideshow-context? t)) (tm-define-overloaded (structured-insert-horizontal t forwards?) (set! t (tree-ref t 0)) (with i (+ (tree-index (tree-down t)) (if forwards? 1 0)) (tree-insert! t i (quote ((slide (document ""))))) (tree-go-to t i 0 0 0))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (slideshow-context? t)) (tm-define-overloaded (structured-insert-horizontal t forwards?) (set! t (tree-ref t 0)) (with i (+ (tree-index (tree-down t)) (if forwards? 1 0)) (tree-insert! t i (quote ((slide (document ""))))) (tree-go-to t i 0 0 0))))

  (define-option-require opt decl)
    <= (((slideshow-context? t)) (tm-define-overloaded (structured-remove-horizontal t forwards?) (set! t (tree-ref t 0)) (let* ((i (- (tree-index (tree-down t)) (if forwards? 0 1))) (n (tree-arity t))) (when (and (>= i 0) (> n 1)) (tree-remove! t i 1) (tree-go-to t (min i (- n 1)) (if forwards? #:start #:end))))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (slideshow-context? t)) (tm-define-overloaded (structured-remove-horizontal t forwards?) (set! t (tree-ref t 0)) (let* ((i (- (tree-index (tree-down t)) (if forwards? 0 1))) (n (tree-arity t))) (when (and (>= i 0) (> n 1)) (tree-remove! t i 1) (tree-go-to t (min i (- n 1)) (if forwards? #:start #:end))))))

  (define-option-require opt decl)
    <= (((and (inside? (quote slideshow)) (slide-range))) (tm-define-overloaded (clipboard-cut which) (with (i1 i2) (slide-range) (with t (tree-innermost slideshow-context?) (clipboard-set which (selection-tree)) (tree-remove (tree-ref t 0) i1 (+ (- i2 i1) 1)) (if (>= i1 (tree-arity (tree-ref t 0))) (tree-go-to t 0 (- i1 1) #:end) (tree-go-to t 0 i1 #:start))))))
    => (define-option-match opt decl) <= ((lambda (which) (and (inside? (quote slideshow)) (slide-range))) (tm-define-overloaded (clipboard-cut which) (with (i1 i2) (slide-range) (with t (tree-innermost slideshow-context?) (clipboard-set which (selection-tree)) (tree-remove (tree-ref t 0) i1 (+ (- i2 i1) 1)) (if (>= i1 (tree-arity (tree-ref t 0))) (tree-go-to t 0 (- i1 1) #:end) (tree-go-to t 0 i1 #:start))))))

  (define-option-require opt decl)
    <= (((and (inside? (quote slideshow)) (slides? (clipboard-get which)))) (tm-define-overloaded (clipboard-paste which) (let* ((t (tree-innermost slideshow-context?)) (i (tree-index (tree-down (tree-ref t 0)))) (ins (tree-ref (clipboard-get which) 1))) (tree-insert (tree-ref t 0) i (tree-children ins)))))
    => (define-option-match opt decl) <= ((lambda (which) (and (inside? (quote slideshow)) (slides? (clipboard-get which)))) (tm-define-overloaded (clipboard-paste which) (let* ((t (tree-innermost slideshow-context?)) (i (tree-index (tree-down (tree-ref t 0)))) (ins (tree-ref (clipboard-get which) 1))) (tree-insert (tree-ref t 0) i (tree-children ins)))))

  (define-option-require opt decl)
    <= (((and (screens-context? t) (not (slideshow-context? t)))) (tm-define-overloaded (structured-insert-horizontal t forwards?) (with tmpl (extract-slide-template (tree-down t)) (when (not (tree-multi-paragraph? (tm->tree tmpl))) (set! tmpl (quasiquote (document (unquote tmpl))))) (switch-insert-at t (if forwards? #:var-next #:current) tmpl) (and-with s (tree-down (tree-innermost (quote screens))) (when (or (tree-func? s (quote shown) 1) (tree-func? s (quote hidden) 1)) (set! s (tree-ref s 0))) (cond ((and (tree-is? s (quote document)) (>= (tree-arity s) 2) (tree-func? (tree-ref s 0) (quote tit) 1)) (tree-go-to s 0 0 #:start)) ((and (tree-is? s (quote document)) (>= (tree-arity s) 1) (tree-func? (tree-ref s 0) (quote gr-screen) 1)) (go-to-graphics)))))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (and (screens-context? t) (not (slideshow-context? t)))) (tm-define-overloaded (structured-insert-horizontal t forwards?) (with tmpl (extract-slide-template (tree-down t)) (when (not (tree-multi-paragraph? (tm->tree tmpl))) (set! tmpl (quasiquote (document (unquote tmpl))))) (switch-insert-at t (if forwards? #:var-next #:current) tmpl) (and-with s (tree-down (tree-innermost (quote screens))) (when (or (tree-func? s (quote shown) 1) (tree-func? s (quote hidden) 1)) (set! s (tree-ref s 0))) (cond ((and (tree-is? s (quote document)) (>= (tree-arity s) 2) (tree-func? (tree-ref s 0) (quote tit) 1)) (tree-go-to s 0 0 #:start)) ((and (tree-is? s (quote document)) (>= (tree-arity s) 1) (tree-func? (tree-ref s 0) (quote gr-screen) 1)) (go-to-graphics)))))))

  (define-option-require opt decl)
    <= (((var-space-context? t)) (tm-define-overloaded (geometry-speed t inc?) (with inc (if inc? 1 -1) (with-focus-after t (length-increase-step (tree-ref t 0) inc)))))
    => (define-option-match opt decl) <= ((lambda (t inc?) (var-space-context? t)) (tm-define-overloaded (geometry-speed t inc?) (with inc (if inc? 1 -1) (with-focus-after t (length-increase-step (tree-ref t 0) inc)))))

  (define-option-require opt decl)
    <= (((var-space-context? t)) (tm-define-overloaded (geometry-horizontal t forward?) (with inc (if forward? 1 -1) (with-focus-after t (length-increase (tree-ref t 0) inc)))))
    => (define-option-match opt decl) <= ((lambda (t forward?) (var-space-context? t)) (tm-define-overloaded (geometry-horizontal t forward?) (with inc (if forward? 1 -1) (with-focus-after t (length-increase (tree-ref t 0) inc)))))

  (define-option-require opt decl)
    <= (((space-context? t)) (tm-define-overloaded (geometry-vertical t down?) (with inc (if down? -1 1) (with-focus-after t (space-make-ternary t) (length-increase (tree-ref t 2) inc)))))
    => (define-option-match opt decl) <= ((lambda (t down?) (space-context? t)) (tm-define-overloaded (geometry-vertical t down?) (with inc (if down? -1 1) (with-focus-after t (space-make-ternary t) (length-increase (tree-ref t 2) inc)))))

  (define-option-require opt decl)
    <= (((space-context? t)) (tm-define-overloaded (geometry-incremental t down?) (with inc (if down? -1 1) (with-focus-after t (space-make-ternary t) (when (space-consistent? t) (length-increase (tree-ref t 1) inc) (length-increase (tree-ref t 2) inc))))))
    => (define-option-match opt decl) <= ((lambda (t down?) (space-context? t)) (tm-define-overloaded (geometry-incremental t down?) (with inc (if down? -1 1) (with-focus-after t (space-make-ternary t) (when (space-consistent? t) (length-increase (tree-ref t 1) inc) (length-increase (tree-ref t 2) inc))))))

  (define-option-require opt decl)
    <= (((hspace-context? t)) (tm-define-overloaded (geometry-speed t inc?) (with inc (if inc? 1 -1) (with-focus-after t (length-increase-step (tree-ref t 0) inc)))))
    => (define-option-match opt decl) <= ((lambda (t inc?) (hspace-context? t)) (tm-define-overloaded (geometry-speed t inc?) (with inc (if inc? 1 -1) (with-focus-after t (length-increase-step (tree-ref t 0) inc)))))

  (define-option-require opt decl)
    <= (((hspace-context? t)) (tm-define-overloaded (geometry-horizontal t forward?) (with inc (if forward? 1 -1) (with-focus-after t (rubber-space-increase t inc)))))
    => (define-option-match opt decl) <= ((lambda (t forward?) (hspace-context? t)) (tm-define-overloaded (geometry-horizontal t forward?) (with inc (if forward? 1 -1) (with-focus-after t (rubber-space-increase t inc)))))

  (define-option-require opt decl)
    <= (((vspace-context? t)) (tm-define-overloaded (geometry-speed t inc?) (with inc (if inc? 1 -1) (with-focus-after t (length-increase-step (tree-ref t 0) inc)))))
    => (define-option-match opt decl) <= ((lambda (t inc?) (vspace-context? t)) (tm-define-overloaded (geometry-speed t inc?) (with inc (if inc? 1 -1) (with-focus-after t (length-increase-step (tree-ref t 0) inc)))))

  (define-option-require opt decl)
    <= (((vspace-context? t)) (tm-define-overloaded (geometry-vertical t down?) (with inc (if down? 1 -1) (with-focus-after t (rubber-space-increase t inc)))))
    => (define-option-match opt decl) <= ((lambda (t down?) (vspace-context? t)) (tm-define-overloaded (geometry-vertical t down?) (with inc (if down? 1 -1) (with-focus-after t (rubber-space-increase t inc)))))

  (define-option-require opt decl)
    <= (((vadjust-context? t)) (tm-define-overloaded (geometry-speed t inc?) (with inc (if inc? 1 -1) (length-increase-step (tree-ref t 1) inc))))
    => (define-option-match opt decl) <= ((lambda (t inc?) (vadjust-context? t)) (tm-define-overloaded (geometry-speed t inc?) (with inc (if inc? 1 -1) (length-increase-step (tree-ref t 1) inc))))

  (define-option-require opt decl)
    <= (((vadjust-context? t)) (tm-define-overloaded (geometry-vertical t down?) (with inc (if down? 1 -1) (length-increase (tree-ref t 1) inc))))
    => (define-option-match opt decl) <= ((lambda (t down?) (vadjust-context? t)) (tm-define-overloaded (geometry-vertical t down?) (with inc (if down? 1 -1) (length-increase (tree-ref t 1) inc))))

  (define-option-argument opt decl)
    <= ((ver "Vertical") (tm-define-overloaded (make-move hor ver) (wrap-selection-small (insert-go-to (quasiquote (move "" (unquote hor) (unquote ver))) (quote (0 0))) (set-adjust-message "Adjust position" "move"))))
    => cons <> cur-props <= ((quote make-move) #:arguments (quote (hor ver)))
    => cons <> cur-props <= ((quote make-move) (quote (#:argument ver)) (quote ("Vertical")))
    => cur-props => (((quote make-move) (quote (#:argument ver)) (quote ("Vertical"))) ((quote make-move) #:arguments (quote (hor ver))))

  (define-option-argument opt decl)
    <= ((hor "Horizontal") (tm-define-overloaded (make-move hor ver) (wrap-selection-small (insert-go-to (quasiquote (move "" (unquote hor) (unquote ver))) (quote (0 0))) (set-adjust-message "Adjust position" "move"))))
    => cons <> cur-props <= ((quote make-move) #:arguments (quote (hor ver)))
    => cons <> cur-props <= ((quote make-move) (quote (#:argument hor)) (quote ("Horizontal")))
    => cur-props => (((quote make-move) (quote (#:argument hor)) (quote ("Horizontal"))) ((quote make-move) #:arguments (quote (hor ver))) ((quote make-move) (quote (#:argument ver)) (quote ("Vertical"))) ((quote make-move) #:arguments (quote (hor ver))))

(property-set! var prop what conds*)
  <= (make-move (#:argument hor) ("Horizontal") ())

(property-set! var prop what conds*)
  <= (make-move #:arguments (hor ver) ())

(property-set! var prop what conds*)
  <= (make-move (#:argument ver) ("Vertical") ())

(property-set! var prop what conds*)
  <= (make-move #:arguments (hor ver) ())

  (define-option-argument opt decl)
    <= ((ver "Vertical") (tm-define-overloaded (make-shift hor ver) (wrap-selection-small (insert-go-to (quasiquote (shift "" (unquote hor) (unquote ver))) (quote (0 0))) (set-adjust-message "Adjust position" "shift"))))
    => cons <> cur-props <= ((quote make-shift) #:arguments (quote (hor ver)))
    => cons <> cur-props <= ((quote make-shift) (quote (#:argument ver)) (quote ("Vertical")))
    => cur-props => (((quote make-shift) (quote (#:argument ver)) (quote ("Vertical"))) ((quote make-shift) #:arguments (quote (hor ver))))

  (define-option-argument opt decl)
    <= ((hor "Horizontal") (tm-define-overloaded (make-shift hor ver) (wrap-selection-small (insert-go-to (quasiquote (shift "" (unquote hor) (unquote ver))) (quote (0 0))) (set-adjust-message "Adjust position" "shift"))))
    => cons <> cur-props <= ((quote make-shift) #:arguments (quote (hor ver)))
    => cons <> cur-props <= ((quote make-shift) (quote (#:argument hor)) (quote ("Horizontal")))
    => cur-props => (((quote make-shift) (quote (#:argument hor)) (quote ("Horizontal"))) ((quote make-shift) #:arguments (quote (hor ver))) ((quote make-shift) (quote (#:argument ver)) (quote ("Vertical"))) ((quote make-shift) #:arguments (quote (hor ver))))

(property-set! var prop what conds*)
  <= (make-shift (#:argument hor) ("Horizontal") ())

(property-set! var prop what conds*)
  <= (make-shift #:arguments (hor ver) ())

(property-set! var prop what conds*)
  <= (make-shift (#:argument ver) ("Vertical") ())

(property-set! var prop what conds*)
  <= (make-shift #:arguments (hor ver) ())

  (define-option-require opt decl)
    <= (((move-context? t)) (tm-define-overloaded (geometry-speed t inc?) (with inc (if inc? 1 -1) (with-focus-after t (length-increase-step (tree-ref t 1) inc) (when (not (lengths-consistent? (tree-ref t 1) (tree-ref t 2))) (length-increase-step (tree-ref t 2) inc))))))
    => (define-option-match opt decl) <= ((lambda (t inc?) (move-context? t)) (tm-define-overloaded (geometry-speed t inc?) (with inc (if inc? 1 -1) (with-focus-after t (length-increase-step (tree-ref t 1) inc) (when (not (lengths-consistent? (tree-ref t 1) (tree-ref t 2))) (length-increase-step (tree-ref t 2) inc))))))

  (define-option-require opt decl)
    <= (((move-context? t)) (tm-define-overloaded (geometry-variant t forward?) (circulate-unit (if forward? 1 -1))))
    => (define-option-match opt decl) <= ((lambda (t forward?) (move-context? t)) (tm-define-overloaded (geometry-variant t forward?) (circulate-unit (if forward? 1 -1))))

  (define-option-require opt decl)
    <= (((move-context? t)) (tm-define-overloaded (geometry-horizontal t forward?) (with inc (if forward? 1 -1) (with-focus-after t (replace-empty t 1 (get-zero-unit)) (length-increase (tree-ref t 1) inc)))))
    => (define-option-match opt decl) <= ((lambda (t forward?) (move-context? t)) (tm-define-overloaded (geometry-horizontal t forward?) (with inc (if forward? 1 -1) (with-focus-after t (replace-empty t 1 (get-zero-unit)) (length-increase (tree-ref t 1) inc)))))

  (define-option-require opt decl)
    <= (((move-context? t)) (tm-define-overloaded (geometry-vertical t down?) (with inc (if down? -1 1) (with-focus-after t (replace-empty t 2 (get-zero-unit)) (length-increase (tree-ref t 2) inc)))))
    => (define-option-match opt decl) <= ((lambda (t down?) (move-context? t)) (tm-define-overloaded (geometry-vertical t down?) (with inc (if down? -1 1) (with-focus-after t (replace-empty t 2 (get-zero-unit)) (length-increase (tree-ref t 2) inc)))))

  (define-option-argument opt decl)
    <= ((t "Top") (tm-define-overloaded (make-resize l b r t) (wrap-selection-small (insert-go-to (quasiquote (resize "" (unquote l) (unquote b) (unquote r) (unquote t))) (quote (0 0))) (set-adjust-message "Adjust extents" "resize"))))
    => cons <> cur-props <= ((quote make-resize) #:arguments (quote (l b r t)))
    => cons <> cur-props <= ((quote make-resize) (quote (#:argument t)) (quote ("Top")))
    => cur-props => (((quote make-resize) (quote (#:argument t)) (quote ("Top"))) ((quote make-resize) #:arguments (quote (l b r t))))

  (define-option-argument opt decl)
    <= ((r "Right") (tm-define-overloaded (make-resize l b r t) (wrap-selection-small (insert-go-to (quasiquote (resize "" (unquote l) (unquote b) (unquote r) (unquote t))) (quote (0 0))) (set-adjust-message "Adjust extents" "resize"))))
    => cons <> cur-props <= ((quote make-resize) #:arguments (quote (l b r t)))
    => cons <> cur-props <= ((quote make-resize) (quote (#:argument r)) (quote ("Right")))
    => cur-props => (((quote make-resize) (quote (#:argument r)) (quote ("Right"))) ((quote make-resize) #:arguments (quote (l b r t))) ((quote make-resize) (quote (#:argument t)) (quote ("Top"))) ((quote make-resize) #:arguments (quote (l b r t))))

  (define-option-argument opt decl)
    <= ((b "Bottom") (tm-define-overloaded (make-resize l b r t) (wrap-selection-small (insert-go-to (quasiquote (resize "" (unquote l) (unquote b) (unquote r) (unquote t))) (quote (0 0))) (set-adjust-message "Adjust extents" "resize"))))
    => cons <> cur-props <= ((quote make-resize) #:arguments (quote (l b r t)))
    => cons <> cur-props <= ((quote make-resize) (quote (#:argument b)) (quote ("Bottom")))
    => cur-props => (((quote make-resize) (quote (#:argument b)) (quote ("Bottom"))) ((quote make-resize) #:arguments (quote (l b r t))) ((quote make-resize) (quote (#:argument r)) (quote ("Right"))) ((quote make-resize) #:arguments (quote (l b r t))) ((quote make-resize) (quote (#:argument t)) (quote ("Top"))) ((quote make-resize) #:arguments (quote (l b r t))))

  (define-option-argument opt decl)
    <= ((l "Left") (tm-define-overloaded (make-resize l b r t) (wrap-selection-small (insert-go-to (quasiquote (resize "" (unquote l) (unquote b) (unquote r) (unquote t))) (quote (0 0))) (set-adjust-message "Adjust extents" "resize"))))
    => cons <> cur-props <= ((quote make-resize) #:arguments (quote (l b r t)))
    => cons <> cur-props <= ((quote make-resize) (quote (#:argument l)) (quote ("Left")))
    => cur-props => (((quote make-resize) (quote (#:argument l)) (quote ("Left"))) ((quote make-resize) #:arguments (quote (l b r t))) ((quote make-resize) (quote (#:argument b)) (quote ("Bottom"))) ((quote make-resize) #:arguments (quote (l b r t))) ((quote make-resize) (quote (#:argument r)) (quote ("Right"))) ((quote make-resize) #:arguments (quote (l b r t))) ((quote make-resize) (quote (#:argument t)) (quote ("Top"))) ((quote make-resize) #:arguments (quote (l b r t))))

(property-set! var prop what conds*)
  <= (make-resize (#:argument l) ("Left") ())

(property-set! var prop what conds*)
  <= (make-resize #:arguments (l b r t) ())

(property-set! var prop what conds*)
  <= (make-resize (#:argument b) ("Bottom") ())

(property-set! var prop what conds*)
  <= (make-resize #:arguments (l b r t) ())

(property-set! var prop what conds*)
  <= (make-resize (#:argument r) ("Right") ())

(property-set! var prop what conds*)
  <= (make-resize #:arguments (l b r t) ())

(property-set! var prop what conds*)
  <= (make-resize (#:argument t) ("Top") ())

(property-set! var prop what conds*)
  <= (make-resize #:arguments (l b r t) ())

  (define-option-argument opt decl)
    <= ((t "Top") (tm-define-overloaded (make-extend l b r t) (wrap-selection-small (insert-go-to (quasiquote (extend "" (unquote l) (unquote b) (unquote r) (unquote t))) (quote (0 0))) (set-adjust-message "Adjust extension" "extend"))))
    => cons <> cur-props <= ((quote make-extend) #:arguments (quote (l b r t)))
    => cons <> cur-props <= ((quote make-extend) (quote (#:argument t)) (quote ("Top")))
    => cur-props => (((quote make-extend) (quote (#:argument t)) (quote ("Top"))) ((quote make-extend) #:arguments (quote (l b r t))))

  (define-option-argument opt decl)
    <= ((r "Right") (tm-define-overloaded (make-extend l b r t) (wrap-selection-small (insert-go-to (quasiquote (extend "" (unquote l) (unquote b) (unquote r) (unquote t))) (quote (0 0))) (set-adjust-message "Adjust extension" "extend"))))
    => cons <> cur-props <= ((quote make-extend) #:arguments (quote (l b r t)))
    => cons <> cur-props <= ((quote make-extend) (quote (#:argument r)) (quote ("Right")))
    => cur-props => (((quote make-extend) (quote (#:argument r)) (quote ("Right"))) ((quote make-extend) #:arguments (quote (l b r t))) ((quote make-extend) (quote (#:argument t)) (quote ("Top"))) ((quote make-extend) #:arguments (quote (l b r t))))

  (define-option-argument opt decl)
    <= ((b "Bottom") (tm-define-overloaded (make-extend l b r t) (wrap-selection-small (insert-go-to (quasiquote (extend "" (unquote l) (unquote b) (unquote r) (unquote t))) (quote (0 0))) (set-adjust-message "Adjust extension" "extend"))))
    => cons <> cur-props <= ((quote make-extend) #:arguments (quote (l b r t)))
    => cons <> cur-props <= ((quote make-extend) (quote (#:argument b)) (quote ("Bottom")))
    => cur-props => (((quote make-extend) (quote (#:argument b)) (quote ("Bottom"))) ((quote make-extend) #:arguments (quote (l b r t))) ((quote make-extend) (quote (#:argument r)) (quote ("Right"))) ((quote make-extend) #:arguments (quote (l b r t))) ((quote make-extend) (quote (#:argument t)) (quote ("Top"))) ((quote make-extend) #:arguments (quote (l b r t))))

  (define-option-argument opt decl)
    <= ((l "Left") (tm-define-overloaded (make-extend l b r t) (wrap-selection-small (insert-go-to (quasiquote (extend "" (unquote l) (unquote b) (unquote r) (unquote t))) (quote (0 0))) (set-adjust-message "Adjust extension" "extend"))))
    => cons <> cur-props <= ((quote make-extend) #:arguments (quote (l b r t)))
    => cons <> cur-props <= ((quote make-extend) (quote (#:argument l)) (quote ("Left")))
    => cur-props => (((quote make-extend) (quote (#:argument l)) (quote ("Left"))) ((quote make-extend) #:arguments (quote (l b r t))) ((quote make-extend) (quote (#:argument b)) (quote ("Bottom"))) ((quote make-extend) #:arguments (quote (l b r t))) ((quote make-extend) (quote (#:argument r)) (quote ("Right"))) ((quote make-extend) #:arguments (quote (l b r t))) ((quote make-extend) (quote (#:argument t)) (quote ("Top"))) ((quote make-extend) #:arguments (quote (l b r t))))

(property-set! var prop what conds*)
  <= (make-extend (#:argument l) ("Left") ())

(property-set! var prop what conds*)
  <= (make-extend #:arguments (l b r t) ())

(property-set! var prop what conds*)
  <= (make-extend (#:argument b) ("Bottom") ())

(property-set! var prop what conds*)
  <= (make-extend #:arguments (l b r t) ())

(property-set! var prop what conds*)
  <= (make-extend (#:argument r) ("Right") ())

(property-set! var prop what conds*)
  <= (make-extend #:arguments (l b r t) ())

(property-set! var prop what conds*)
  <= (make-extend (#:argument t) ("Top") ())

(property-set! var prop what conds*)
  <= (make-extend #:arguments (l b r t) ())

  (define-option-argument opt decl)
    <= ((t "Top") (tm-define-overloaded (make-clipped l b r t) (wrap-selection-small (insert-go-to (quasiquote (clipped "" (unquote l) (unquote b) (unquote r) (unquote t))) (quote (0 0))) (set-adjust-message "Adjust clipping" "clipped"))))
    => cons <> cur-props <= ((quote make-clipped) #:arguments (quote (l b r t)))
    => cons <> cur-props <= ((quote make-clipped) (quote (#:argument t)) (quote ("Top")))
    => cur-props => (((quote make-clipped) (quote (#:argument t)) (quote ("Top"))) ((quote make-clipped) #:arguments (quote (l b r t))))

  (define-option-argument opt decl)
    <= ((r "Right") (tm-define-overloaded (make-clipped l b r t) (wrap-selection-small (insert-go-to (quasiquote (clipped "" (unquote l) (unquote b) (unquote r) (unquote t))) (quote (0 0))) (set-adjust-message "Adjust clipping" "clipped"))))
    => cons <> cur-props <= ((quote make-clipped) #:arguments (quote (l b r t)))
    => cons <> cur-props <= ((quote make-clipped) (quote (#:argument r)) (quote ("Right")))
    => cur-props => (((quote make-clipped) (quote (#:argument r)) (quote ("Right"))) ((quote make-clipped) #:arguments (quote (l b r t))) ((quote make-clipped) (quote (#:argument t)) (quote ("Top"))) ((quote make-clipped) #:arguments (quote (l b r t))))

  (define-option-argument opt decl)
    <= ((b "Bottom") (tm-define-overloaded (make-clipped l b r t) (wrap-selection-small (insert-go-to (quasiquote (clipped "" (unquote l) (unquote b) (unquote r) (unquote t))) (quote (0 0))) (set-adjust-message "Adjust clipping" "clipped"))))
    => cons <> cur-props <= ((quote make-clipped) #:arguments (quote (l b r t)))
    => cons <> cur-props <= ((quote make-clipped) (quote (#:argument b)) (quote ("Bottom")))
    => cur-props => (((quote make-clipped) (quote (#:argument b)) (quote ("Bottom"))) ((quote make-clipped) #:arguments (quote (l b r t))) ((quote make-clipped) (quote (#:argument r)) (quote ("Right"))) ((quote make-clipped) #:arguments (quote (l b r t))) ((quote make-clipped) (quote (#:argument t)) (quote ("Top"))) ((quote make-clipped) #:arguments (quote (l b r t))))

  (define-option-argument opt decl)
    <= ((l "Left") (tm-define-overloaded (make-clipped l b r t) (wrap-selection-small (insert-go-to (quasiquote (clipped "" (unquote l) (unquote b) (unquote r) (unquote t))) (quote (0 0))) (set-adjust-message "Adjust clipping" "clipped"))))
    => cons <> cur-props <= ((quote make-clipped) #:arguments (quote (l b r t)))
    => cons <> cur-props <= ((quote make-clipped) (quote (#:argument l)) (quote ("Left")))
    => cur-props => (((quote make-clipped) (quote (#:argument l)) (quote ("Left"))) ((quote make-clipped) #:arguments (quote (l b r t))) ((quote make-clipped) (quote (#:argument b)) (quote ("Bottom"))) ((quote make-clipped) #:arguments (quote (l b r t))) ((quote make-clipped) (quote (#:argument r)) (quote ("Right"))) ((quote make-clipped) #:arguments (quote (l b r t))) ((quote make-clipped) (quote (#:argument t)) (quote ("Top"))) ((quote make-clipped) #:arguments (quote (l b r t))))

(property-set! var prop what conds*)
  <= (make-clipped (#:argument l) ("Left") ())

(property-set! var prop what conds*)
  <= (make-clipped #:arguments (l b r t) ())

(property-set! var prop what conds*)
  <= (make-clipped (#:argument b) ("Bottom") ())

(property-set! var prop what conds*)
  <= (make-clipped #:arguments (l b r t) ())

(property-set! var prop what conds*)
  <= (make-clipped (#:argument r) ("Right") ())

(property-set! var prop what conds*)
  <= (make-clipped #:arguments (l b r t) ())

(property-set! var prop what conds*)
  <= (make-clipped (#:argument t) ("Top") ())

(property-set! var prop what conds*)
  <= (make-clipped #:arguments (l b r t) ())

  (define-option-argument opt decl)
    <= ((by "Reduce by") (tm-define-overloaded (make-reduce-by by) (wrap-selection-small (insert-go-to (quasiquote (reduce-by "" (unquote by))) (quote (0 0))) (set-adjust-message "Reduce vertical size" "reduce-by"))))
    => cons <> cur-props <= ((quote make-reduce-by) #:arguments (quote (by)))
    => cons <> cur-props <= ((quote make-reduce-by) (quote (#:argument by)) (quote ("Reduce by")))
    => cur-props => (((quote make-reduce-by) (quote (#:argument by)) (quote ("Reduce by"))) ((quote make-reduce-by) #:arguments (quote (by))))

(property-set! var prop what conds*)
  <= (make-reduce-by (#:argument by) ("Reduce by") ())

(property-set! var prop what conds*)
  <= (make-reduce-by #:arguments (by) ())

  (define-option-require opt decl)
    <= (((resize-context? t)) (tm-define-overloaded (geometry-speed t inc?) (with inc (if inc? -1 1) (with-focus-after t (length-increase-step (tree-ref t 3) inc) (when (not (lengths-consistent? (tree-ref t 3) (tree-ref t 4))) (length-increase-step (tree-ref t 3) inc))))))
    => (define-option-match opt decl) <= ((lambda (t inc?) (resize-context? t)) (tm-define-overloaded (geometry-speed t inc?) (with inc (if inc? -1 1) (with-focus-after t (length-increase-step (tree-ref t 3) inc) (when (not (lengths-consistent? (tree-ref t 3) (tree-ref t 4))) (length-increase-step (tree-ref t 3) inc))))))

  (define-option-require opt decl)
    <= (((resize-context? t)) (tm-define-overloaded (geometry-variant t forward?) (circulate-unit (if forward? 1 -1))))
    => (define-option-match opt decl) <= ((lambda (t forward?) (resize-context? t)) (tm-define-overloaded (geometry-variant t forward?) (circulate-unit (if forward? 1 -1))))

  (define-option-require opt decl)
    <= (((resize-context? t)) (tm-define-overloaded (geometry-horizontal t forward?) (with inc (if forward? 1 -1) (with-focus-after t (replace-empty-horizontal t) (length-increase (tree-ref t 3) inc)))))
    => (define-option-match opt decl) <= ((lambda (t forward?) (resize-context? t)) (tm-define-overloaded (geometry-horizontal t forward?) (with inc (if forward? 1 -1) (with-focus-after t (replace-empty-horizontal t) (length-increase (tree-ref t 3) inc)))))

  (define-option-require opt decl)
    <= (((resize-context? t)) (tm-define-overloaded (geometry-vertical t down?) (with inc (if down? -1 1) (with-focus-after t (replace-empty-vertical t) (length-increase (tree-ref t 4) inc)))))
    => (define-option-match opt decl) <= ((lambda (t down?) (resize-context? t)) (tm-define-overloaded (geometry-vertical t down?) (with inc (if down? -1 1) (with-focus-after t (replace-empty-vertical t) (length-increase (tree-ref t 4) inc)))))

  (define-option-require opt decl)
    <= (((resize-context? t)) (tm-define-overloaded (geometry-extremal t forward?) (with inc (if forward? 1 -1) (with-focus-after t (when (resize-consistent-horizontal? t) (length-increase (tree-ref t 1) inc) (length-increase (tree-ref t 3) inc))))))
    => (define-option-match opt decl) <= ((lambda (t forward?) (resize-context? t)) (tm-define-overloaded (geometry-extremal t forward?) (with inc (if forward? 1 -1) (with-focus-after t (when (resize-consistent-horizontal? t) (length-increase (tree-ref t 1) inc) (length-increase (tree-ref t 3) inc))))))

  (define-option-require opt decl)
    <= (((resize-context? t)) (tm-define-overloaded (geometry-incremental t down?) (with inc (if down? -1 1) (with-focus-after t (when (resize-consistent-vertical? t) (length-increase (tree-ref t 2) inc) (length-increase (tree-ref t 4) inc))))))
    => (define-option-match opt decl) <= ((lambda (t down?) (resize-context? t)) (tm-define-overloaded (geometry-incremental t down?) (with inc (if down? -1 1) (with-focus-after t (when (resize-consistent-vertical? t) (length-increase (tree-ref t 2) inc) (length-increase (tree-ref t 4) inc))))))

  (define-option-require opt decl)
    <= (((image-context? t)) (tm-define-overloaded (geometry-speed t inc?) (with inc (if inc? 1 -1) (with-focus-after t (length-increase-step (tree-ref t 0) inc)))))
    => (define-option-match opt decl) <= ((lambda (t inc?) (image-context? t)) (tm-define-overloaded (geometry-speed t inc?) (with inc (if inc? 1 -1) (with-focus-after t (length-increase-step (tree-ref t 0) inc)))))

  (define-option-require opt decl)
    <= (((image-context? t)) (tm-define-overloaded (geometry-horizontal t forward?) (with inc (if forward? 1 -1) (with-focus-after t (replace-empty t 1 "1w") (length-increase (tree-ref t 1) inc)))))
    => (define-option-match opt decl) <= ((lambda (t forward?) (image-context? t)) (tm-define-overloaded (geometry-horizontal t forward?) (with inc (if forward? 1 -1) (with-focus-after t (replace-empty t 1 "1w") (length-increase (tree-ref t 1) inc)))))

  (define-option-require opt decl)
    <= (((image-context? t)) (tm-define-overloaded (geometry-vertical t down?) (with inc (if down? 1 -1) (with-focus-after t (replace-empty t 2 "1h") (length-increase (tree-ref t 2) inc)))))
    => (define-option-match opt decl) <= ((lambda (t down?) (image-context? t)) (tm-define-overloaded (geometry-vertical t down?) (with inc (if down? 1 -1) (with-focus-after t (replace-empty t 2 "1h") (length-increase (tree-ref t 2) inc)))))

  (define-option-require opt decl)
    <= (((image-context? t)) (tm-define-overloaded (geometry-incremental t down?) (with inc (if down? -1 1) (with-focus-after t (replace-empty t 4 "0h") (length-increase (tree-ref t 4) inc)))))
    => (define-option-match opt decl) <= ((lambda (t down?) (image-context? t)) (tm-define-overloaded (geometry-incremental t down?) (with inc (if down? -1 1) (with-focus-after t (replace-empty t 4 "0h") (length-increase (tree-ref t 4) inc)))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote hybrid))) (tm-define-overloaded (kbd-enter t forwards?) (activate-hybrid #f)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (tree-is? t (quote hybrid))) (tm-define-overloaded (kbd-enter t forwards?) (activate-hybrid #f)))

  (define-option-require opt decl)
    <= (((tree-is? t (quote compound))) (tm-define-overloaded (kbd-enter t forwards?) (activate-compound)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (tree-is? t (quote compound))) (tm-define-overloaded (kbd-enter t forwards?) (activate-compound)))

  (define-option-require opt decl)
    <= (((tree-is? t (quote latex))) (tm-define-overloaded (kbd-enter t forwards?) (activate-latex)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (tree-is? t (quote latex))) (tm-define-overloaded (kbd-enter t forwards?) (activate-latex)))

  (define-option-require opt decl)
    <= (((tree-is? t (quote symbol))) (tm-define-overloaded (kbd-enter t forwards?) (activate-symbol)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (tree-is? t (quote symbol))) (tm-define-overloaded (kbd-enter t forwards?) (activate-symbol)))

  (define-option-require opt decl)
    <= (((tree-is? t (quote inactive))) (tm-define-overloaded (kbd-enter t forwards?) (activate)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (tree-is? t (quote inactive))) (tm-define-overloaded (kbd-enter t forwards?) (activate)))

  (define-option-require opt decl)
    <= (((tree-is? t (quote hybrid))) (tm-define-overloaded (kbd-variant t forwards?) (activate-hybrid #t)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (tree-is? t (quote hybrid))) (tm-define-overloaded (kbd-variant t forwards?) (activate-hybrid #t)))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (inactive tuple attr)))) (tm-define-overloaded (kbd-variant t forwards?) (insert-argument forwards?)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (tree-in? t (quote (inactive tuple attr)))) (tm-define-overloaded (kbd-variant t forwards?) (insert-argument forwards?)))

  (define-option-require opt decl)
    <= (((in-source?)) (tm-define-overloaded (kbd-variant t forwards?) (insert-argument forwards?)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (in-source?)) (tm-define-overloaded (kbd-variant t forwards?) (insert-argument forwards?)))

  (define-option-require opt decl)
    <= (((tree-is? t (quote hybrid))) (tm-define-overloaded (structured-insert-horizontal t forwards?) (activate-hybrid #t)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (tree-is? t (quote hybrid))) (tm-define-overloaded (structured-insert-horizontal t forwards?) (activate-hybrid #t)))

  (define-option-require opt decl)
    <= (((and (tree-is? t (quote hybrid)) (tree-is? t #:up (quote inactive)))) (tm-define-overloaded (inactive-toggle t) (activate-hybrid #f)))
    => (define-option-match opt decl) <= ((lambda (t) (and (tree-is? t (quote hybrid)) (tree-is? t #:up (quote inactive)))) (tm-define-overloaded (inactive-toggle t) (activate-hybrid #f)))

  (define-option-require opt decl)
    <= (((and (tree-is? t (quote compound)) (tree-is? t #:up (quote inactive)))) (tm-define-overloaded (inactive-toggle t) (activate-compound)))
    => (define-option-match opt decl) <= ((lambda (t) (and (tree-is? t (quote compound)) (tree-is? t #:up (quote inactive)))) (tm-define-overloaded (inactive-toggle t) (activate-compound)))

  (define-option-require opt decl)
    <= (((and (tree-is? t (quote latex)) (tree-is? t #:up (quote inactive)))) (tm-define-overloaded (inactive-toggle t) (activate-latex)))
    => (define-option-match opt decl) <= ((lambda (t) (and (tree-is? t (quote latex)) (tree-is? t #:up (quote inactive)))) (tm-define-overloaded (inactive-toggle t) (activate-latex)))

  (define-option-require opt decl)
    <= (((and (tree-is? t (quote symbol)) (tree-is? t #:up (quote inactive)))) (tm-define-overloaded (inactive-toggle t) (activate-symbol)))
    => (define-option-match opt decl) <= ((lambda (t) (and (tree-is? t (quote symbol)) (tree-is? t #:up (quote inactive)))) (tm-define-overloaded (inactive-toggle t) (activate-symbol)))

  (define-option-require opt decl)
    <= (((string-variable-name? t i)) (tm-define-overloaded (string-input-icon t i) (menu-dynamic (with c (tree-ref t i) (with s (if (tree-atomic? c) (tree->string c) "n.a.") (glue #f #f 3 0) (mini #t (group (eval (string-append s ":")))))))))
    => (define-option-match opt decl) <= ((lambda (t i) (string-variable-name? t i)) (tm-define-overloaded (string-input-icon t i) (menu-dynamic (with c (tree-ref t i) (with s (if (tree-atomic? c) (tree->string c) "n.a.") (glue #f #f 3 0) (mini #t (group (eval (string-append s ":")))))))))

  (define-option-require opt decl)
    <= (((and (tree-label-parameter? (string->symbol l)) (string? (get-init-env l)) (nin? (tree-label-type (string->symbol l)) (list "unknown" "regular" "adhoc")))) (tm-define-overloaded (focus-parameter-menu-item l) (menu-dynamic (-> (eval (focus-tag-name (string->symbol l))) (dynamic (init-env-menu l (list #:other)))))))
    => (define-option-match opt decl) <= ((lambda (l) (and (tree-label-parameter? (string->symbol l)) (string? (get-init-env l)) (nin? (tree-label-type (string->symbol l)) (list "unknown" "regular" "adhoc")))) (tm-define-overloaded (focus-parameter-menu-item l) (menu-dynamic (-> (eval (focus-tag-name (string->symbol l))) (dynamic (init-env-menu l (list #:other)))))))

  (define-option-require opt decl)
    <= (((and (tree-label-parameter? (string->symbol l)) (string? (get-init-env l)) (== (tree-label-type (string->symbol l)) "boolean"))) (tm-define-overloaded (focus-parameter-menu-item l) (menu-dynamic ((check (eval (focus-tag-name (string->symbol l))) "v" (== (get-init-env l) "true")) (toggle-init-env l)))))
    => (define-option-match opt decl) <= ((lambda (l) (and (tree-label-parameter? (string->symbol l)) (string? (get-init-env l)) (== (tree-label-type (string->symbol l)) "boolean"))) (tm-define-overloaded (focus-parameter-menu-item l) (menu-dynamic ((check (eval (focus-tag-name (string->symbol l))) "v" (== (get-init-env l) "true")) (toggle-init-env l)))))

  (define-option-require opt decl)
    <= (((and (tree-label-parameter? (string->symbol l)) (== (tree-label-type (string->symbol l)) "color"))) (tm-define-overloaded (focus-parameter-menu-item l) (menu-dynamic (-> (eval (focus-tag-name (string->symbol l))) ((check "Default" "*" (test-default? l)) (init-default l)) --- (pick-background "" (init-env-tree l answer)) --- (if (in? l (list "locus-color" "visited-color")) ((check "Preserve" "*" (test-init? l "preserve")) (set-init-env l "preserve"))) ("Palette" (interactive-color (lambda (col) (init-env l col)) (quote ()))) ("Other" (init-interactive-env l))))))
    => (define-option-match opt decl) <= ((lambda (l) (and (tree-label-parameter? (string->symbol l)) (== (tree-label-type (string->symbol l)) "color"))) (tm-define-overloaded (focus-parameter-menu-item l) (menu-dynamic (-> (eval (focus-tag-name (string->symbol l))) ((check "Default" "*" (test-default? l)) (init-default l)) --- (pick-background "" (init-env-tree l answer)) --- (if (in? l (list "locus-color" "visited-color")) ((check "Preserve" "*" (test-init? l "preserve")) (set-init-env l "preserve"))) ("Palette" (interactive-color (lambda (col) (init-env l col)) (quote ()))) ("Other" (init-interactive-env l))))))

  (define-option-require opt decl)
    <= (((parameter-choice-list l)) (tm-define-overloaded (focus-parameter-menu-item l) (menu-dynamic (with cs (parameter-choice-list l) (-> (eval (focus-tag-name (string->symbol l))) (dynamic (init-env-menu l cs)))))))
    => (define-option-match opt decl) <= ((lambda (l) (parameter-choice-list l)) (tm-define-overloaded (focus-parameter-menu-item l) (menu-dynamic (with cs (parameter-choice-list l) (-> (eval (focus-tag-name (string->symbol l))) (dynamic (init-env-menu l cs)))))))

  (define-option-require opt decl)
    <= (((in? l (list "the-label" "auto-nr" "current-part" "language" "page-nr" "page-the-page" "prog-language" "caption-summarized" "figure-width"))) (tm-define-overloaded (parameter-show-in-menu? l) #f))
    => (define-option-match opt decl) <= ((lambda (l) (in? l (list "the-label" "auto-nr" "current-part" "language" "page-nr" "page-the-page" "prog-language" "caption-summarized" "figure-width"))) (tm-define-overloaded (parameter-show-in-menu? l) #f))

  (define-option-require opt decl)
    <= (((pure-alternate-context? t)) (tm-define-overloaded (focus-hidden-menu t) (menu-dynamic)))
    => (define-option-match opt decl) <= ((lambda (t) (pure-alternate-context? t)) (tm-define-overloaded (focus-hidden-menu t) (menu-dynamic)))

  (define-option-require opt decl)
    <= (((pure-alternate-context? t)) (tm-define-overloaded (focus-hidden-icons t) (menu-dynamic)))
    => (define-option-match opt decl) <= ((lambda (t) (pure-alternate-context? t)) (tm-define-overloaded (focus-hidden-icons t) (menu-dynamic)))

  (define-option-require opt decl)
    <= (((parameter-choice-list var)) (tm-define-overloaded (focus-customizable-menu-item setter var name) (menu-dynamic (-> (eval name) (for (val (parameter-choice-list var)) ((eval val) (setter val)))))))
    => (define-option-match opt decl) <= ((lambda (setter var name) (parameter-choice-list var)) (tm-define-overloaded (focus-customizable-menu-item setter var name) (menu-dynamic (-> (eval name) (for (val (parameter-choice-list var)) ((eval val) (setter val)))))))

  (define-option-require opt decl)
    <= (((== (tree-label-type (string->symbol var)) "color")) (tm-define-overloaded (focus-customizable-menu-item setter var name) (menu-dynamic (-> (eval name) (pick-background "" (setter answer)) --- ("Palette" (interactive-color setter (quote ()))) ("Other" (interactive setter (list name "string" (get-env var))))))))
    => (define-option-match opt decl) <= ((lambda (setter var name) (== (tree-label-type (string->symbol var)) "color")) (tm-define-overloaded (focus-customizable-menu-item setter var name) (menu-dynamic (-> (eval name) (pick-background "" (setter answer)) --- ("Palette" (interactive-color setter (quote ()))) ("Other" (interactive setter (list name "string" (get-env var))))))))

  (define-option-require opt decl)
    <= (((customizable-context? t)) (tm-define-overloaded (focus-extra-menu t) (menu-dynamic --- (for (p (customizable-parameters t)) (with (var name) p (with l (tree-label t) (with setter (lambda (val) (when (tree-is? (focus-tree) l) (tree-with-set (focus-tree) var val))) (dynamic (focus-customizable-menu-item setter var name)))))))))
    => (define-option-match opt decl) <= ((lambda (t) (customizable-context? t)) (tm-define-overloaded (focus-extra-menu t) (menu-dynamic --- (for (p (customizable-parameters t)) (with (var name) p (with l (tree-label t) (with setter (lambda (val) (when (tree-is? (focus-tree) l) (tree-with-set (focus-tree) var val))) (dynamic (focus-customizable-menu-item setter var name)))))))))

  (define-option-require opt decl)
    <= (((parameter-choice-list var)) (tm-define-overloaded (focus-customizable-icons-item setter var name) (menu-dynamic (mini #t (=> (eval (get-env var)) (for (val (parameter-choice-list var)) ((eval val) (setter val))))))))
    => (define-option-match opt decl) <= ((lambda (setter var name) (parameter-choice-list var)) (tm-define-overloaded (focus-customizable-icons-item setter var name) (menu-dynamic (mini #t (=> (eval (get-env var)) (for (val (parameter-choice-list var)) ((eval val) (setter val))))))))

  (define-option-require opt decl)
    <= (((== (tree-label-type (string->symbol var)) "color")) (tm-define-overloaded (focus-customizable-icons-item setter var name) (menu-dynamic (=> (color (tree->stree (get-env-tree var)) #f #f 24 16) (pick-background "" (setter answer)) --- ("Palette" (interactive-color setter (quote ()))) ("Other" (interactive setter (list name "string" (get-env var))))))))
    => (define-option-match opt decl) <= ((lambda (setter var name) (== (tree-label-type (string->symbol var)) "color")) (tm-define-overloaded (focus-customizable-icons-item setter var name) (menu-dynamic (=> (color (tree->stree (get-env-tree var)) #f #f 24 16) (pick-background "" (setter answer)) --- ("Palette" (interactive-color setter (quote ()))) ("Other" (interactive setter (list name "string" (get-env var))))))))

  (define-option-require opt decl)
    <= (((customizable-context? t)) (tm-define-overloaded (focus-extra-icons t) (menu-dynamic (for (p (customizable-parameters t)) (with (var name) p (with l (tree-label t) (with setter (lambda (val) (when (tree-is? (focus-tree) l) (tree-with-set (focus-tree) var val))) (glue #f #f 3 0) (mini #t (group (eval (string-append name ":")))) (dynamic (focus-customizable-icons-item setter var name)))))))))
    => (define-option-match opt decl) <= ((lambda (t) (customizable-context? t)) (tm-define-overloaded (focus-extra-icons t) (menu-dynamic (for (p (customizable-parameters t)) (with (var name) p (with l (tree-label t) (with setter (lambda (val) (when (tree-is? (focus-tree) l) (tree-with-set (focus-tree) var val))) (glue #f #f 3 0) (mini #t (group (eval (string-append name ":")))) (dynamic (focus-customizable-icons-item setter var name)))))))))

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" test-default-font?) (tm-define-overloaded (init-default-font) (init-default "font") (init-default "math-font")))
    => ((quote init-default-font) #:check-mark (list "*" test-default-font?))
 => cons <> cur-props
    => cur-props => (((quote init-default-font) #:check-mark (list "*" test-default-font?)))

(property-set! var prop what conds*)
  <= (init-default-font #:check-mark ("*" #<procedure test-default-font? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" test-init-font?) (tm-define-overloaded (init-font val math-val) (init-env "font" val) (init-env "math-font" math-val)))
    => ((quote init-font) #:check-mark (list "*" test-init-font?))
 => cons <> cur-props
    => cur-props => (((quote init-font) #:check-mark (list "*" test-init-font?)))

(property-set! var prop what conds*)
  <= (init-font #:check-mark ("*" #<procedure test-init-font? (val math-val)>) ())

  (define-option-require opt decl)
    <= (((tree-is-buffer? t)) (tm-define-overloaded (standard-focus-menu t) (menu-dynamic (dynamic (focus-style-menu t)) --- (dynamic (focus-document-menu t)) (dynamic (focus-document-extra-menu t)) --- ("Help" (focus-help)))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is-buffer? t)) (tm-define-overloaded (standard-focus-menu t) (menu-dynamic (dynamic (focus-style-menu t)) --- (dynamic (focus-document-menu t)) (dynamic (focus-document-extra-menu t)) --- ("Help" (focus-help)))))

  (define-option-require opt decl)
    <= (((tree-is-buffer? t)) (tm-define-overloaded (standard-focus-icons t) (menu-dynamic (dynamic (focus-style-icons t)) // (dynamic (focus-document-icons t)) // (dynamic (focus-document-extra-icons t)))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is-buffer? t)) (tm-define-overloaded (standard-focus-icons t) (menu-dynamic (dynamic (focus-style-icons t)) // (dynamic (focus-document-icons t)) // (dynamic (focus-document-extra-icons t)))))

  (define-option-require opt decl)
    <= (((pen-effect-context? t)) (tm-define-overloaded (focus-misc-menu t) (menu-dynamic (-> "Effect pen" (dynamic (select-effect-pen-menu t))))))
    => (define-option-match opt decl) <= ((lambda (t) (pen-effect-context? t)) (tm-define-overloaded (focus-misc-menu t) (menu-dynamic (-> "Effect pen" (dynamic (select-effect-pen-menu t))))))

  (define-option-require opt decl)
    <= (((pen-effect-context? t)) (tm-define-overloaded (focus-misc-icons t) (menu-dynamic (=> (balloon (icon (eval (effect-pen-icon t))) "Select pen") (dynamic (select-effect-pen-menu t))))))
    => (define-option-match opt decl) <= ((lambda (t) (pen-effect-context? t)) (tm-define-overloaded (focus-misc-icons t) (menu-dynamic (=> (balloon (icon (eval (effect-pen-icon t))) "Select pen") (dynamic (select-effect-pen-menu t))))))

  (define-option-require opt decl)
    <= (((page-numbering-context? t)) (tm-define-overloaded (notify-activated t) (refresh-window)))
    => (define-option-match opt decl) <= ((lambda (t) (page-numbering-context? t)) (tm-define-overloaded (notify-activated t) (refresh-window)))

  (define-option-require opt decl)
    <= (((page-numbering-context? t)) (tm-define-overloaded (notify-disactivated t) (refresh-window)))
    => (define-option-match opt decl) <= ((lambda (t) (page-numbering-context? t)) (tm-define-overloaded (notify-disactivated t) (refresh-window)))

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (open-paragraph-format) (let* ((old (get-env-table paragraph-parameters)) (new (get-env-table paragraph-parameters)) (u (current-buffer))) (dialogue-window (paragraph-formatter old new make-multi-line-with u #f) noop "Paragraph format"))))
    => ((quote open-paragraph-format) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-paragraph-format) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-paragraph-format #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (open-page-format) (let* ((u (current-buffer)) (st (list-remove-duplicates (rcons (get-style-list) "macro-editor"))) (t (make-ahash-table))) (dialogue-window (page-formatter u st t) noop "Page format" (header-buffer) (footer-buffer)))))
    => ((quote open-page-format) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-page-format) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-page-format #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (open-pattern-selector cmd w) (with u (current-buffer) (dialogue-window (pattern-selector u "white" w "100@") cmd "Pattern selector"))))
    => ((quote open-pattern-selector) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-pattern-selector) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-pattern-selector #:interactive (#t) ())

  (define-option-require opt decl)
    <= (((fold-context? t)) (tm-define-overloaded (alternate-second-name t) "Unfold"))
    => (define-option-match opt decl) <= ((lambda (t) (fold-context? t)) (tm-define-overloaded (alternate-second-name t) "Unfold"))

  (define-option-require opt decl)
    <= (((fold-context? t)) (tm-define-overloaded (alternate-second-icon t) "tm_alternate_both.xpm"))
    => (define-option-match opt decl) <= ((lambda (t) (fold-context? t)) (tm-define-overloaded (alternate-second-icon t) "tm_alternate_both.xpm"))

  (define-option-require opt decl)
    <= (((style-has? "beamer-style")) (tm-define-overloaded (document-style-extra-menu) (menu-dynamic (=> "Beamer theme" (for (theme (beamer-themes)) ((check (eval (upcase-first theme)) "v" (has-style-package? theme)) (add-style-package theme)))))))
    => (define-option-match opt decl) <= ((lambda () (style-has? "beamer-style")) (tm-define-overloaded (document-style-extra-menu) (menu-dynamic (=> "Beamer theme" (for (theme (beamer-themes)) ((check (eval (upcase-first theme)) "v" (has-style-package? theme)) (add-style-package theme)))))))

  (define-option-require opt decl)
    <= (((style-has? "beamer-style")) (tm-define-overloaded (focus-style-extra-menu t) (menu-dynamic (=> "Beamer theme" (for (theme (beamer-themes)) ((check (eval (upcase-first theme)) "v" (has-style-package? theme)) (add-style-package theme)))))))
    => (define-option-match opt decl) <= ((lambda (t) (style-has? "beamer-style")) (tm-define-overloaded (focus-style-extra-menu t) (menu-dynamic (=> "Beamer theme" (for (theme (beamer-themes)) ((check (eval (upcase-first theme)) "v" (has-style-package? theme)) (add-style-package theme)))))))

  (define-option-require opt decl)
    <= (((style-has? "beamer-style")) (tm-define-overloaded (focus-style-extra-icons t) (menu-dynamic (=> (balloon (eval (upcase-first (current-beamer-theme))) "Beamer theme") (for (theme (beamer-themes)) ((check (eval (upcase-first theme)) "v" (has-style-package? theme)) (add-style-package theme)))))))
    => (define-option-match opt decl) <= ((lambda (t) (style-has? "beamer-style")) (tm-define-overloaded (focus-style-extra-icons t) (menu-dynamic (=> (balloon (eval (upcase-first (current-beamer-theme))) "Beamer theme") (for (theme (beamer-themes)) ((check (eval (upcase-first theme)) "v" (has-style-package? theme)) (add-style-package theme)))))))

  (define-option-require opt decl)
    <= (((document-propose-screens?)) (tm-define-overloaded (focus-document-extra-menu t) (menu-dynamic ("Screens" (make-switch (quote screens))))))
    => (define-option-match opt decl) <= ((lambda (t) (document-propose-screens?)) (tm-define-overloaded (focus-document-extra-menu t) (menu-dynamic ("Screens" (make-switch (quote screens))))))

  (define-option-require opt decl)
    <= (((document-propose-screens?)) (tm-define-overloaded (focus-document-extra-icons t) (menu-dynamic (minibar ((balloon "Screens" "Make a multi-slide presentation") (make-screens))))))
    => (define-option-match opt decl) <= ((lambda (t) (document-propose-screens?)) (tm-define-overloaded (focus-document-extra-icons t) (menu-dynamic (minibar ((balloon "Screens" "Make a multi-slide presentation") (make-screens))))))

  (define-option-require opt decl)
    <= (((== l (quote tit))) (tm-define-overloaded (standard-options l) (list "framed-title" "title-bar")))
    => (define-option-match opt decl) <= ((lambda (l) (== l (quote tit))) (tm-define-overloaded (standard-options l) (list "framed-title" "title-bar")))

  (define-option-require opt decl)
    <= (((== l "title-theme")) (tm-define-overloaded (parameter-show-in-menu? l) #f))
    => (define-option-match opt decl) <= ((lambda (l) (== l "title-theme")) (tm-define-overloaded (parameter-show-in-menu? l) #f))

  (define-option-require opt decl)
    <= (((or (inside? (quote screens)) (inside? (quote slideshow)))) (tm-define-overloaded (open-page-format) (dialogue-window slide-page-formatter noop "Page format")))
    => (define-option-match opt decl) <= ((lambda () (or (inside? (quote screens)) (inside? (quote slideshow)))) (tm-define-overloaded (open-page-format) (dialogue-window slide-page-formatter noop "Page format")))

  (define-option-require opt decl)
    <= (((screens-context? t)) (tm-define-overloaded (focus-can-move? t) #f))
    => (define-option-match opt decl) <= ((lambda (t) (screens-context? t)) (tm-define-overloaded (focus-can-move? t) #f))

  (define-option-require opt decl)
    <= (((screens-context? t)) (tm-define-overloaded (focus-tag-menu t) (menu-dynamic (inert ((eval (focus-tag-name (tree-label t))) (noop) (noop))) (-> (eval (upcase-first (get-init "page-type"))) (link document-page-size-menu)) (-> (eval (upcase-first (get-init-page-rendering))) (link page-rendering-menu)) (-> "Preferences" (dynamic (focus-preferences-menu t))) ("Describe" (focus-help)))))
    => (define-option-match opt decl) <= ((lambda (t) (screens-context? t)) (tm-define-overloaded (focus-tag-menu t) (menu-dynamic (inert ((eval (focus-tag-name (tree-label t))) (noop) (noop))) (-> (eval (upcase-first (get-init "page-type"))) (link document-page-size-menu)) (-> (eval (upcase-first (get-init-page-rendering))) (link page-rendering-menu)) (-> "Preferences" (dynamic (focus-preferences-menu t))) ("Describe" (focus-help)))))

  (define-option-require opt decl)
    <= (((screens-context? t)) (tm-define-overloaded (standard-focus-menu t) (menu-dynamic (dynamic (focus-style-menu t)) --- (dynamic (focus-tag-menu t)) --- (dynamic (focus-insert-menu t)) --- (dynamic (focus-slides-menu t)) (assuming (slide-propose-title? t) --- ("Title" (slide-insert-title t))) (assuming (slide-propose-graphics? t) --- ("Draw" (slide-insert-graphics t))))))
    => (define-option-match opt decl) <= ((lambda (t) (screens-context? t)) (tm-define-overloaded (standard-focus-menu t) (menu-dynamic (dynamic (focus-style-menu t)) --- (dynamic (focus-tag-menu t)) --- (dynamic (focus-insert-menu t)) --- (dynamic (focus-slides-menu t)) (assuming (slide-propose-title? t) --- ("Title" (slide-insert-title t))) (assuming (slide-propose-graphics? t) --- ("Draw" (slide-insert-graphics t))))))

  (define-option-require opt decl)
    <= (((screens-context? t)) (tm-define-overloaded (focus-tag-icons t) (menu-dynamic (mini #t (inert ((eval (focus-tag-name (tree-label t))) (noop)))) (=> (balloon (eval (upcase-first (get-init "page-type"))) "Paper size") (link document-page-size-menu)) (=> (balloon (icon (eval (current-page-icon))) "Page layout") (link page-rendering-menu)) (assuming (focus-has-preferences? t) (=> (balloon (icon "tm_focus_prefs.xpm") "Preferences for tag") (dynamic (focus-preferences-menu t)))) ((balloon (icon "tm_focus_help.xpm") "Describe tag") (focus-help)))))
    => (define-option-match opt decl) <= ((lambda (t) (screens-context? t)) (tm-define-overloaded (focus-tag-icons t) (menu-dynamic (mini #t (inert ((eval (focus-tag-name (tree-label t))) (noop)))) (=> (balloon (eval (upcase-first (get-init "page-type"))) "Paper size") (link document-page-size-menu)) (=> (balloon (icon (eval (current-page-icon))) "Page layout") (link page-rendering-menu)) (assuming (focus-has-preferences? t) (=> (balloon (icon "tm_focus_prefs.xpm") "Preferences for tag") (dynamic (focus-preferences-menu t)))) ((balloon (icon "tm_focus_help.xpm") "Describe tag") (focus-help)))))

  (define-option-require opt decl)
    <= (((screens-context? t)) (tm-define-overloaded (standard-focus-icons t) (menu-dynamic (dynamic (focus-style-icons t)) // (minibar (dynamic (focus-insert-icons t))) // (minibar (dynamic (focus-tag-icons t))) // (with u (slide-get-switch t) (with i (tree-index (tree-down u)) (mini #t (=> (eval (get-slide-name (tree-ref u i) i)) (dynamic (focus-slides-menu t)))))) (assuming (slide-propose-title? t) // (minibar ((balloon "Title" "Insert title") (slide-insert-title t)))) (assuming (slide-propose-graphics? t) // (minibar ((balloon "Draw" "Draw graphics") (slide-insert-graphics t)))))))
    => (define-option-match opt decl) <= ((lambda (t) (screens-context? t)) (tm-define-overloaded (standard-focus-icons t) (menu-dynamic (dynamic (focus-style-icons t)) // (minibar (dynamic (focus-insert-icons t))) // (minibar (dynamic (focus-tag-icons t))) // (with u (slide-get-switch t) (with i (tree-index (tree-down u)) (mini #t (=> (eval (get-slide-name (tree-ref u i) i)) (dynamic (focus-slides-menu t)))))) (assuming (slide-propose-title? t) // (minibar ((balloon "Title" "Insert title") (slide-insert-title t)))) (assuming (slide-propose-graphics? t) // (minibar ((balloon "Draw" "Draw graphics") (slide-insert-graphics t)))))))

  (define-option-require opt decl)
    <= (((overlays-context? t)) (tm-define-overloaded (focus-can-insert-remove? t) #t))
    => (define-option-match opt decl) <= ((lambda (t) (overlays-context? t)) (tm-define-overloaded (focus-can-insert-remove? t) #t))

  (define-option-require opt decl)
    <= (((overlays-context? t)) (tm-define-overloaded (focus-can-insert? t) #t))
    => (define-option-match opt decl) <= ((lambda (t) (overlays-context? t)) (tm-define-overloaded (focus-can-insert? t) #t))

  (define-option-require opt decl)
    <= (((overlays-context? t)) (tm-define-overloaded (focus-can-remove? t) #t))
    => (define-option-match opt decl) <= ((lambda (t) (overlays-context? t)) (tm-define-overloaded (focus-can-remove? t) #t))

  (define-option-require opt decl)
    <= (((== l "overlay-nr")) (tm-define-overloaded (parameter-show-in-menu? l) #f))
    => (define-option-match opt decl) <= ((lambda (l) (== l "overlay-nr")) (tm-define-overloaded (parameter-show-in-menu? l) #f))

  (define-option-require opt decl)
    <= (((overlays-context? t)) (tm-define-overloaded (focus-hidden-menu t) (menu-dynamic --- (dynamic (focus-overlays-menu t)))))
    => (define-option-match opt decl) <= ((lambda (t) (overlays-context? t)) (tm-define-overloaded (focus-hidden-menu t) (menu-dynamic --- (dynamic (focus-overlays-menu t)))))

  (define-option-require opt decl)
    <= (((overlays-context? t)) (tm-define-overloaded (focus-hidden-icons t) (menu-dynamic // (=> (eval (get-overlays-menu-name "Overlay " t)) (dynamic (focus-overlays-menu t))))))
    => (define-option-match opt decl) <= ((lambda (t) (overlays-context? t)) (tm-define-overloaded (focus-hidden-icons t) (menu-dynamic // (=> (eval (get-overlays-menu-name "Overlay " t)) (dynamic (focus-overlays-menu t))))))

  (define-option-require opt decl)
    <= (((overlay-context? t)) (tm-define-overloaded (focus-hidden-icons t) (menu-dynamic // (dynamic (focus-overlay-icons t)))))
    => (define-option-match opt decl) <= ((lambda (t) (overlay-context? t)) (tm-define-overloaded (focus-hidden-icons t) (menu-dynamic // (dynamic (focus-overlay-icons t)))))

(property var prop)
  <= (update-document #:check-mark) => #f

(property var prop)
  <= (update-document #:interactive) => #f

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" test-matching-brackets?) (tm-define-overloaded (toggle-matching-brackets) (set-preference "automatic brackets" (if (== (get-preference "automatic brackets") "off") "mathematics" "off"))))
    => ((quote toggle-matching-brackets) #:check-mark (list "v" test-matching-brackets?))
 => cons <> cur-props
    => cur-props => (((quote toggle-matching-brackets) #:check-mark (list "v" test-matching-brackets?)))

(property-set! var prop what conds*)
  <= (toggle-matching-brackets #:check-mark ("v" #<procedure test-matching-brackets? ()>) ())

  (define-option-require opt decl)
    <= (((and (tree-is-buffer? t) (in-math?))) (tm-define-overloaded (kbd-space-bar t shift?) (let* ((b (skip-decorations-leftwards (before-cursor))) (p (get-preference "math spacebar"))) (cond ((== p "allow spurious spaces") (insert " ")) ((and (== b " ") (== p "no spurious spaces")) (noop)) ((== b " ") (remove-text #f) (make-space "1em")) ((and (tree? b) (tree-func? b (quote space) 1)) (if (and (tree-atomic? (tree-ref b 0)) (string-ends? (tree->string (tree-ref b 0)) "em")) (make-space "1em") (geometry-horizontal b #t))) ((not (allow-space-after? b)) (noop)) (else (insert " "))))))
    => (define-option-match opt decl) <= ((lambda (t shift?) (and (tree-is-buffer? t) (in-math?))) (tm-define-overloaded (kbd-space-bar t shift?) (let* ((b (skip-decorations-leftwards (before-cursor))) (p (get-preference "math spacebar"))) (cond ((== p "allow spurious spaces") (insert " ")) ((and (== b " ") (== p "no spurious spaces")) (noop)) ((== b " ") (remove-text #f) (make-space "1em")) ((and (tree? b) (tree-func? b (quote space) 1)) (if (and (tree-atomic? (tree-ref b 0)) (string-ends? (tree->string (tree-ref b 0)) "em")) (make-space "1em") (geometry-horizontal b #t))) ((not (allow-space-after? b)) (noop)) (else (insert " "))))))

  (define-option-require opt decl)
    <= (((in-math?)) (tm-define-overloaded (kbd-insert s) (when (== (before-cursor) " ") (let* ((p (get-preference "math spacebar")) (type (if (string? s) (math-symbol-type s) "symbol"))) (when (in? type (list "postfix" "infix" "separator" "middle-bracket" "closing-bracket")) (remove-text #f)))) (former s)))
    => (define-option-match opt decl) <= ((lambda (s) (in-math?)) (tm-define-overloaded (kbd-insert s) (when (== (before-cursor) " ") (let* ((p (get-preference "math spacebar")) (type (if (string? s) (math-symbol-type s) "symbol"))) (when (in? type (list "postfix" "infix" "separator" "middle-bracket" "closing-bracket")) (remove-text #f)))) (former s)))

  (define-option-require opt decl)
    <= (((tree-is? t (quote equation))) (tm-define-overloaded (kbd-enter t shift?) (go-end-of (quote equation)) (insert-return)))
    => (define-option-match opt decl) <= ((lambda (t shift?) (tree-is? t (quote equation))) (tm-define-overloaded (kbd-enter t shift?) (go-end-of (quote equation)) (insert-return)))

  (define-option-require opt decl)
    <= (((tree-is? t (quote equation*))) (tm-define-overloaded (kbd-enter t shift?) (go-end-of (quote equation*)) (insert-return)))
    => (define-option-match opt decl) <= ((lambda (t shift?) (tree-is? t (quote equation*))) (tm-define-overloaded (kbd-enter t shift?) (go-end-of (quote equation*)) (insert-return)))

  (define-option-require opt decl)
    <= (((tree-is? t (quote eqnarray*))) (tm-define-overloaded (label-insert t) (go-end-line) (make (quote label))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote eqnarray*))) (tm-define-overloaded (label-insert t) (go-end-line) (make (quote label))))

  (define-option-require opt decl)
    <= (((with-math-context? t)) (tm-define-overloaded (variant-circulate t forward?) (tree-set! t (quasiquote (math (unquote (tree-ref t 2))))) (math->equation* t)))
    => (define-option-match opt decl) <= ((lambda (t forward?) (with-math-context? t)) (tm-define-overloaded (variant-circulate t forward?) (tree-set! t (quasiquote (math (unquote (tree-ref t 2))))) (math->equation* t)))

  (define-option-require opt decl)
    <= (((tree-is? t (quote math))) (tm-define-overloaded (variant-circulate t forward?) (math->equation* t)))
    => (define-option-match opt decl) <= ((lambda (t forward?) (tree-is? t (quote math))) (tm-define-overloaded (variant-circulate t forward?) (math->equation* t)))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (equation equation*)))) (tm-define-overloaded (variant-circulate t forward?) (equation*->math t)))
    => (define-option-match opt decl) <= ((lambda (t forward?) (tree-in? t (quote (equation equation*)))) (tm-define-overloaded (variant-circulate t forward?) (equation*->math t)))

  (define-option-require opt decl)
    <= (((script-context? t)) (tm-define-overloaded (variant-circulate t forward?) (when (script-only-script? t) (cond ((tree-is? t (quote lsub)) (variant-set t (quote lsup))) ((tree-is? t (quote lsup)) (variant-set t (quote lsub))) ((tree-is? t (quote rsub)) (variant-set t (quote rsup))) ((tree-is? t (quote rsup)) (variant-set t (quote rsub)))))))
    => (define-option-match opt decl) <= ((lambda (t forward?) (script-context? t)) (tm-define-overloaded (variant-circulate t forward?) (when (script-only-script? t) (cond ((tree-is? t (quote lsub)) (variant-set t (quote lsup))) ((tree-is? t (quote lsup)) (variant-set t (quote lsub))) ((tree-is? t (quote rsub)) (variant-set t (quote rsup))) ((tree-is? t (quote rsup)) (variant-set t (quote rsub)))))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (lsub rsub)))) (tm-define-overloaded (structured-insert-vertical t downwards?) (when (and (not downwards?) (script-only-script? t)) (tree-go-to t #:end) (cond ((tree-is? t (quote lsub)) (make (quote lsup))) ((tree-is? t (quote rsub)) (make (quote rsup)))))))
    => (define-option-match opt decl) <= ((lambda (t downwards?) (tree-in? t (quote (lsub rsub)))) (tm-define-overloaded (structured-insert-vertical t downwards?) (when (and (not downwards?) (script-only-script? t)) (tree-go-to t #:end) (cond ((tree-is? t (quote lsub)) (make (quote lsup))) ((tree-is? t (quote rsub)) (make (quote rsup)))))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (lsup rsup)))) (tm-define-overloaded (structured-insert-vertical t downwards?) (when (and downwards? (script-only-script? t)) (tree-go-to t #:end) (cond ((tree-is? t (quote lsup)) (make (quote lsub))) ((tree-is? t (quote rsup)) (make (quote rsub)))))))
    => (define-option-match opt decl) <= ((lambda (t downwards?) (tree-in? t (quote (lsup rsup)))) (tm-define-overloaded (structured-insert-vertical t downwards?) (when (and downwards? (script-only-script? t)) (tree-go-to t #:end) (cond ((tree-is? t (quote lsup)) (make (quote lsub))) ((tree-is? t (quote rsup)) (make (quote rsub)))))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (wide wide*)))) (tm-define-overloaded (variant-circulate t forward?) (when (tree-atomic? (tree-ref t 1)) (with s (tree->string (tree-ref t 1)) (and-with i (list-find-index wide-list-1 (lambda (x) (== x s))) (with j (modulo (+ i (if forward? 1 -1)) (length wide-list-1)) (tree-set t 1 (list-ref wide-list-1 j)))) (and-with i (list-find-index wide-list-2 (lambda (x) (== x s))) (with j (modulo (+ i (if forward? 1 -1)) (length wide-list-2)) (tree-set t 1 (list-ref wide-list-2 j)))) (and-with i (list-find-index wide-list-3 (lambda (x) (== x s))) (with j (modulo (+ i (if forward? 1 -1)) (length wide-list-3)) (tree-set t 1 (list-ref wide-list-3 j)))) (and-with i (list-find-index wide-list-4 (lambda (x) (== x s))) (with j (modulo (+ i (if forward? 1 -1)) (length wide-list-4)) (tree-set t 1 (list-ref wide-list-4 j)))) (and-with i (list-find-index wide-list-5 (lambda (x) (== x s))) (with j (modulo (+ i (if forward? 1 -1)) (length wide-list-5)) (tree-set t 1 (list-ref wide-list-5 j))))))))
    => (define-option-match opt decl) <= ((lambda (t forward?) (tree-in? t (quote (wide wide*)))) (tm-define-overloaded (variant-circulate t forward?) (when (tree-atomic? (tree-ref t 1)) (with s (tree->string (tree-ref t 1)) (and-with i (list-find-index wide-list-1 (lambda (x) (== x s))) (with j (modulo (+ i (if forward? 1 -1)) (length wide-list-1)) (tree-set t 1 (list-ref wide-list-1 j)))) (and-with i (list-find-index wide-list-2 (lambda (x) (== x s))) (with j (modulo (+ i (if forward? 1 -1)) (length wide-list-2)) (tree-set t 1 (list-ref wide-list-2 j)))) (and-with i (list-find-index wide-list-3 (lambda (x) (== x s))) (with j (modulo (+ i (if forward? 1 -1)) (length wide-list-3)) (tree-set t 1 (list-ref wide-list-3 j)))) (and-with i (list-find-index wide-list-4 (lambda (x) (== x s))) (with j (modulo (+ i (if forward? 1 -1)) (length wide-list-4)) (tree-set t 1 (list-ref wide-list-4 j)))) (and-with i (list-find-index wide-list-5 (lambda (x) (== x s))) (with j (modulo (+ i (if forward? 1 -1)) (length wide-list-5)) (tree-set t 1 (list-ref wide-list-5 j))))))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (left mid right around around*)))) (tm-define-overloaded (variant-circulate t forward?) (bracket-circulate t forward? mbrackets)))
    => (define-option-match opt decl) <= ((lambda (t forward?) (tree-in? t (quote (left mid right around around*)))) (tm-define-overloaded (variant-circulate t forward?) (bracket-circulate t forward? mbrackets)))

  (define-option-require opt decl)
    <= (((tree-is? t (quote big-around))) (tm-define-overloaded (variant-circulate t forward?) (when (and (== (tree-arity t) 2) (tree-atomic? (tree-ref t 0))) (with s (tree->string (tree-ref t 0)) (when (in? s bigops) (let* ((i (list-find-index bigops (lambda (x) (== x s)))) (j (modulo (+ i (if forward? 1 -1)) (length bigops))) (ns (list-ref bigops j))) (tree-assign (tree-ref t 0) ns)))))))
    => (define-option-match opt decl) <= ((lambda (t forward?) (tree-is? t (quote big-around))) (tm-define-overloaded (variant-circulate t forward?) (when (and (== (tree-arity t) 2) (tree-atomic? (tree-ref t 0))) (with s (tree->string (tree-ref t 0)) (when (in? s bigops) (let* ((i (list-find-index bigops (lambda (x) (== x s)))) (j (modulo (+ i (if forward? 1 -1)) (length bigops))) (ns (list-ref bigops j))) (tree-assign (tree-ref t 0) ns)))))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (left mid right around around*)))) (tm-define-overloaded (geometry-vertical t down?) (with inc (if down? -1 1) (bracket-size-increase t inc))))
    => (define-option-match opt decl) <= ((lambda (t down?) (tree-in? t (quote (left mid right around around*)))) (tm-define-overloaded (geometry-vertical t down?) (with inc (if down? -1 1) (bracket-size-increase t inc))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (around around*)))) (tm-define-overloaded (geometry-default t) (when (== (tree-arity t) 3) (bracket-size-reset (tree-ref t 0)) (bracket-size-reset (tree-ref t 2)))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (around around*)))) (tm-define-overloaded (geometry-default t) (when (== (tree-arity t) 3) (bracket-size-reset (tree-ref t 0)) (bracket-size-reset (tree-ref t 2)))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Correct selected formula or all formulas in document") (tm-define-overloaded (math-correct-all) (if (selection-active-any?) (if (== (selection-tree) (path->tree (selection-path))) (math-correct-tree (path->tree (selection-path))) (set-message "Only implemented for complete subtrees" "correct formula")) (math-correct-tree (buffer-tree)))))
   => ((quote math-correct-all) #:synopsis (quote ("Correct selected formula or all formulas in document")))
 => cons <> cur-props
   => cur-props => (((quote math-correct-all) #:synopsis (quote ("Correct selected formula or all formulas in document"))))

(property-set! var prop what conds*)
  <= (math-correct-all #:synopsis ("Correct selected formula or all formulas in document") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Manually correct selected formula or all formulas in document") (tm-define-overloaded (math-correct-manually) (if (selection-active-any?) (if (== (selection-tree) (path->tree (selection-path))) (math-manually-correct-tree (path->tree (selection-path))) (set-message "Only implemented for complete subtrees" "correct formula")) (math-manually-correct-tree (buffer-tree)))))
   => ((quote math-correct-manually) #:synopsis (quote ("Manually correct selected formula or all formulas in document")))
 => cons <> cur-props
   => cur-props => (((quote math-correct-manually) #:synopsis (quote ("Manually correct selected formula or all formulas in document"))))

(property-set! var prop what conds*)
  <= (math-correct-manually #:synopsis ("Manually correct selected formula or all formulas in document") ())

  (define-option-require opt decl)
    <= (((table-markup-context? t)) (tm-define-overloaded (kbd-enter t shift?) (let ((x (inside-which (quote (table document))))) (cond ((== x (quote document)) (insert-return)) (else (table-insert-row #t) (table-go-to (table-which-row) 1))))))
    => (define-option-match opt decl) <= ((lambda (t shift?) (table-markup-context? t)) (tm-define-overloaded (kbd-enter t shift?) (let ((x (inside-which (quote (table document))))) (cond ((== x (quote document)) (insert-return)) (else (table-insert-row #t) (table-go-to (table-which-row) 1))))))

  (define-option-require opt decl)
    <= (((table-markup-context? t)) (tm-define-overloaded (structured-insert-horizontal t forwards?) (table-insert-column forwards?)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (table-markup-context? t)) (tm-define-overloaded (structured-insert-horizontal t forwards?) (table-insert-column forwards?)))

  (define-option-require opt decl)
    <= (((table-markup-context? t)) (tm-define-overloaded (structured-insert-vertical t downwards?) (table-insert-row downwards?)))
    => (define-option-match opt decl) <= ((lambda (t downwards?) (table-markup-context? t)) (tm-define-overloaded (structured-insert-vertical t downwards?) (table-insert-row downwards?)))

  (define-option-require opt decl)
    <= (((table-markup-context? t)) (tm-define-overloaded (structured-remove-horizontal t forwards?) (table-remove-column forwards?)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (table-markup-context? t)) (tm-define-overloaded (structured-remove-horizontal t forwards?) (table-remove-column forwards?)))

  (define-option-require opt decl)
    <= (((table-markup-context? t)) (tm-define-overloaded (structured-remove-vertical t downwards?) (table-remove-row downwards?)))
    => (define-option-match opt decl) <= ((lambda (t downwards?) (table-markup-context? t)) (tm-define-overloaded (structured-remove-vertical t downwards?) (table-remove-row downwards?)))

  (define-option-require opt decl)
    <= (((table-markup-context? t)) (tm-define-overloaded (geometry-default t) (with-focus-after t (cell-del-format ""))))
    => (define-option-match opt decl) <= ((lambda (t) (table-markup-context? t)) (tm-define-overloaded (geometry-default t) (with-focus-after t (cell-del-format ""))))

  (define-option-require opt decl)
    <= (((table-markup-context? t)) (tm-define-overloaded (geometry-horizontal t forward?) (with-focus-after t (if forward? (cell-halign-right) (cell-halign-left)))))
    => (define-option-match opt decl) <= ((lambda (t forward?) (table-markup-context? t)) (tm-define-overloaded (geometry-horizontal t forward?) (with-focus-after t (if forward? (cell-halign-right) (cell-halign-left)))))

  (define-option-require opt decl)
    <= (((table-markup-context? t)) (tm-define-overloaded (geometry-vertical t down?) (with-focus-after t (if down? (cell-valign-down) (cell-valign-up)))))
    => (define-option-match opt decl) <= ((lambda (t down?) (table-markup-context? t)) (tm-define-overloaded (geometry-vertical t down?) (with-focus-after t (if down? (cell-valign-down) (cell-valign-up)))))

  (define-option-require opt decl)
    <= (((table-non-extremal-context? t downwards?)) (tm-define-overloaded (traverse-vertical t downwards?) (and-with c (cell-search-downwards t) (cell-move-relative c (if downwards? 1 -1) 0))))
    => (define-option-match opt decl) <= ((lambda (t downwards?) (table-non-extremal-context? t downwards?)) (tm-define-overloaded (traverse-vertical t downwards?) (and-with c (cell-search-downwards t) (cell-move-relative c (if downwards? 1 -1) 0))))

  (define-option-require opt decl)
    <= (((table-markup-context? t)) (tm-define-overloaded (structured-horizontal t forwards?) (with-focus-after t (and-with c (cell-search-downwards t) (cell-move-relative c 0 (if forwards? 1 -1))))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (table-markup-context? t)) (tm-define-overloaded (structured-horizontal t forwards?) (with-focus-after t (and-with c (cell-search-downwards t) (cell-move-relative c 0 (if forwards? 1 -1))))))

  (define-option-require opt decl)
    <= (((table-markup-context? t)) (tm-define-overloaded (structured-vertical t downwards?) (with-focus-after t (and-with c (cell-search-downwards t) (cell-move-relative c (if downwards? 1 -1) 0)))))
    => (define-option-match opt decl) <= ((lambda (t downwards?) (table-markup-context? t)) (tm-define-overloaded (structured-vertical t downwards?) (with-focus-after t (and-with c (cell-search-downwards t) (cell-move-relative c (if downwards? 1 -1) 0)))))

  (define-option-require opt decl)
    <= (((table-markup-context? t)) (tm-define-overloaded (structured-inner-extremal t forwards?) (with-focus-after t (and-with c (cell-search-downwards t) (tree-go-to c (if forwards? #:end #:start))))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (table-markup-context? t)) (tm-define-overloaded (structured-inner-extremal t forwards?) (with-focus-after t (and-with c (cell-search-downwards t) (tree-go-to c (if forwards? #:end #:start))))))

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (table-interactive-set var) (interactive (lambda (s) (table-set-format* var s)) (logic-ref env-var-description% var))))
    => ((quote table-interactive-set) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote table-interactive-set) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (table-interactive-set #:interactive (#t) ())

  (define-option-argument opt decl)
    <= ((nr "Number of rows") (tm-define-overloaded (table-set-rows nr) (table-set-extents (string->number nr) (table-nr-columns))))
    => cons <> cur-props <= ((quote table-set-rows) #:arguments (quote (nr)))
    => cons <> cur-props <= ((quote table-set-rows) (quote (#:argument nr)) (quote ("Number of rows")))
    => cur-props => (((quote table-set-rows) (quote (#:argument nr)) (quote ("Number of rows"))) ((quote table-set-rows) #:arguments (quote (nr))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set the number of rows of the table to @nr.") (tm-define-overloaded (table-set-rows nr) (table-set-extents (string->number nr) (table-nr-columns))))
   => ((quote table-set-rows) #:synopsis (quote ("Set the number of rows of the table to @nr.")))
 => cons <> cur-props
   => cur-props => (((quote table-set-rows) #:synopsis (quote ("Set the number of rows of the table to @nr."))) ((quote table-set-rows) (quote (#:argument nr)) (quote ("Number of rows"))) ((quote table-set-rows) #:arguments (quote (nr))))

(property-set! var prop what conds*)
  <= (table-set-rows #:synopsis ("Set the number of rows of the table to @nr.") ())

(property-set! var prop what conds*)
  <= (table-set-rows (#:argument nr) ("Number of rows") ())

(property-set! var prop what conds*)
  <= (table-set-rows #:arguments (nr) ())

  (define-option-argument opt decl)
    <= ((nr "Number of columns") (tm-define-overloaded (table-set-columns nr) (table-set-extents (table-nr-rows) (string->number nr))))
    => cons <> cur-props <= ((quote table-set-columns) #:arguments (quote (nr)))
    => cons <> cur-props <= ((quote table-set-columns) (quote (#:argument nr)) (quote ("Number of columns")))
    => cur-props => (((quote table-set-columns) (quote (#:argument nr)) (quote ("Number of columns"))) ((quote table-set-columns) #:arguments (quote (nr))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set the number of columns of the table to @nr.") (tm-define-overloaded (table-set-columns nr) (table-set-extents (table-nr-rows) (string->number nr))))
   => ((quote table-set-columns) #:synopsis (quote ("Set the number of columns of the table to @nr.")))
 => cons <> cur-props
   => cur-props => (((quote table-set-columns) #:synopsis (quote ("Set the number of columns of the table to @nr."))) ((quote table-set-columns) (quote (#:argument nr)) (quote ("Number of columns"))) ((quote table-set-columns) #:arguments (quote (nr))))

(property-set! var prop what conds*)
  <= (table-set-columns #:synopsis ("Set the number of columns of the table to @nr.") ())

(property-set! var prop what conds*)
  <= (table-set-columns (#:argument nr) ("Number of columns") ())

(property-set! var prop what conds*)
  <= (table-set-columns #:arguments (nr) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" table-test-automatic-width?) (tm-define-overloaded (table-set-automatic-width) (table-set-format-list (quote ("table-width" "table-hmode")) (quote ("" "auto")))))
    => ((quote table-set-automatic-width) #:check-mark (list "o" table-test-automatic-width?))
 => cons <> cur-props
    => cur-props => (((quote table-set-automatic-width) #:check-mark (list "o" table-test-automatic-width?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Automatic determination of table width.") (tm-define-overloaded (table-set-automatic-width) (table-set-format-list (quote ("table-width" "table-hmode")) (quote ("" "auto")))))
   => ((quote table-set-automatic-width) #:synopsis (quote ("Automatic determination of table width.")))
 => cons <> cur-props
   => cur-props => (((quote table-set-automatic-width) #:synopsis (quote ("Automatic determination of table width."))) ((quote table-set-automatic-width) #:check-mark (list "o" table-test-automatic-width?)))

(property-set! var prop what conds*)
  <= (table-set-automatic-width #:synopsis ("Automatic determination of table width.") ())

(property-set! var prop what conds*)
  <= (table-set-automatic-width #:check-mark ("o" #<procedure table-test-automatic-width? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" table-test-minimal-width?) (tm-define-overloaded (table-set-minimal-width w) (table-set-format-list (quote ("table-width" "table-hmode")) (quasiquote ((unquote w) "max")))))
    => ((quote table-set-minimal-width) #:check-mark (list "o" table-test-minimal-width?))
 => cons <> cur-props
    => cur-props => (((quote table-set-minimal-width) #:check-mark (list "o" table-test-minimal-width?)))

  (define-option-argument opt decl)
    <= ((w "Minimal table width") (tm-define-overloaded (table-set-minimal-width w) (table-set-format-list (quote ("table-width" "table-hmode")) (quasiquote ((unquote w) "max")))))
    => cons <> cur-props <= ((quote table-set-minimal-width) #:arguments (quote (w)))
    => cons <> cur-props <= ((quote table-set-minimal-width) (quote (#:argument w)) (quote ("Minimal table width")))
    => cur-props => (((quote table-set-minimal-width) (quote (#:argument w)) (quote ("Minimal table width"))) ((quote table-set-minimal-width) #:arguments (quote (w))) ((quote table-set-minimal-width) #:check-mark (list "o" table-test-minimal-width?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set minimal table width.") (tm-define-overloaded (table-set-minimal-width w) (table-set-format-list (quote ("table-width" "table-hmode")) (quasiquote ((unquote w) "max")))))
   => ((quote table-set-minimal-width) #:synopsis (quote ("Set minimal table width.")))
 => cons <> cur-props
   => cur-props => (((quote table-set-minimal-width) #:synopsis (quote ("Set minimal table width."))) ((quote table-set-minimal-width) (quote (#:argument w)) (quote ("Minimal table width"))) ((quote table-set-minimal-width) #:arguments (quote (w))) ((quote table-set-minimal-width) #:check-mark (list "o" table-test-minimal-width?)))

(property-set! var prop what conds*)
  <= (table-set-minimal-width #:synopsis ("Set minimal table width.") ())

(property-set! var prop what conds*)
  <= (table-set-minimal-width (#:argument w) ("Minimal table width") ())

(property-set! var prop what conds*)
  <= (table-set-minimal-width #:arguments (w) ())

(property-set! var prop what conds*)
  <= (table-set-minimal-width #:check-mark ("o" #<procedure table-test-minimal-width? args>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" table-test-minimal-width?) (tm-define-overloaded (table-ia-minimal-width) (interactive table-set-minimal-width)))
    => ((quote table-ia-minimal-width) #:check-mark (list "o" table-test-minimal-width?))
 => cons <> cur-props
    => cur-props => (((quote table-ia-minimal-width) #:check-mark (list "o" table-test-minimal-width?)))

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (table-ia-minimal-width) (interactive table-set-minimal-width)))
    => ((quote table-ia-minimal-width) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote table-ia-minimal-width) #:interactive (list #t)) ((quote table-ia-minimal-width) #:check-mark (list "o" table-test-minimal-width?)))

(property-set! var prop what conds*)
  <= (table-ia-minimal-width #:interactive (#t) ())

(property-set! var prop what conds*)
  <= (table-ia-minimal-width #:check-mark ("o" #<procedure table-test-minimal-width? args>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" table-test-exact-width?) (tm-define-overloaded (table-set-exact-width w) (table-set-format-list (quote ("table-width" "table-hmode")) (quasiquote ((unquote w) "exact")))))
    => ((quote table-set-exact-width) #:check-mark (list "o" table-test-exact-width?))
 => cons <> cur-props
    => cur-props => (((quote table-set-exact-width) #:check-mark (list "o" table-test-exact-width?)))

  (define-option-argument opt decl)
    <= ((w "Table width") (tm-define-overloaded (table-set-exact-width w) (table-set-format-list (quote ("table-width" "table-hmode")) (quasiquote ((unquote w) "exact")))))
    => cons <> cur-props <= ((quote table-set-exact-width) #:arguments (quote (w)))
    => cons <> cur-props <= ((quote table-set-exact-width) (quote (#:argument w)) (quote ("Table width")))
    => cur-props => (((quote table-set-exact-width) (quote (#:argument w)) (quote ("Table width"))) ((quote table-set-exact-width) #:arguments (quote (w))) ((quote table-set-exact-width) #:check-mark (list "o" table-test-exact-width?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set table width.") (tm-define-overloaded (table-set-exact-width w) (table-set-format-list (quote ("table-width" "table-hmode")) (quasiquote ((unquote w) "exact")))))
   => ((quote table-set-exact-width) #:synopsis (quote ("Set table width.")))
 => cons <> cur-props
   => cur-props => (((quote table-set-exact-width) #:synopsis (quote ("Set table width."))) ((quote table-set-exact-width) (quote (#:argument w)) (quote ("Table width"))) ((quote table-set-exact-width) #:arguments (quote (w))) ((quote table-set-exact-width) #:check-mark (list "o" table-test-exact-width?)))

(property-set! var prop what conds*)
  <= (table-set-exact-width #:synopsis ("Set table width.") ())

(property-set! var prop what conds*)
  <= (table-set-exact-width (#:argument w) ("Table width") ())

(property-set! var prop what conds*)
  <= (table-set-exact-width #:arguments (w) ())

(property-set! var prop what conds*)
  <= (table-set-exact-width #:check-mark ("o" #<procedure table-test-exact-width? args>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" table-test-exact-width?) (tm-define-overloaded (table-ia-exact-width) (interactive table-set-exact-width)))
    => ((quote table-ia-exact-width) #:check-mark (list "o" table-test-exact-width?))
 => cons <> cur-props
    => cur-props => (((quote table-ia-exact-width) #:check-mark (list "o" table-test-exact-width?)))

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (table-ia-exact-width) (interactive table-set-exact-width)))
    => ((quote table-ia-exact-width) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote table-ia-exact-width) #:interactive (list #t)) ((quote table-ia-exact-width) #:check-mark (list "o" table-test-exact-width?)))

(property-set! var prop what conds*)
  <= (table-ia-exact-width #:interactive (#t) ())

(property-set! var prop what conds*)
  <= (table-ia-exact-width #:check-mark ("o" #<procedure table-test-exact-width? args>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" table-test-maximal-width?) (tm-define-overloaded (table-set-maximal-width w) (table-set-format-list (quote ("table-width" "table-hmode")) (quasiquote ((unquote w) "min")))))
    => ((quote table-set-maximal-width) #:check-mark (list "o" table-test-maximal-width?))
 => cons <> cur-props
    => cur-props => (((quote table-set-maximal-width) #:check-mark (list "o" table-test-maximal-width?)))

  (define-option-argument opt decl)
    <= ((w "Maximal table width") (tm-define-overloaded (table-set-maximal-width w) (table-set-format-list (quote ("table-width" "table-hmode")) (quasiquote ((unquote w) "min")))))
    => cons <> cur-props <= ((quote table-set-maximal-width) #:arguments (quote (w)))
    => cons <> cur-props <= ((quote table-set-maximal-width) (quote (#:argument w)) (quote ("Maximal table width")))
    => cur-props => (((quote table-set-maximal-width) (quote (#:argument w)) (quote ("Maximal table width"))) ((quote table-set-maximal-width) #:arguments (quote (w))) ((quote table-set-maximal-width) #:check-mark (list "o" table-test-maximal-width?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set maximal table width.") (tm-define-overloaded (table-set-maximal-width w) (table-set-format-list (quote ("table-width" "table-hmode")) (quasiquote ((unquote w) "min")))))
   => ((quote table-set-maximal-width) #:synopsis (quote ("Set maximal table width.")))
 => cons <> cur-props
   => cur-props => (((quote table-set-maximal-width) #:synopsis (quote ("Set maximal table width."))) ((quote table-set-maximal-width) (quote (#:argument w)) (quote ("Maximal table width"))) ((quote table-set-maximal-width) #:arguments (quote (w))) ((quote table-set-maximal-width) #:check-mark (list "o" table-test-maximal-width?)))

(property-set! var prop what conds*)
  <= (table-set-maximal-width #:synopsis ("Set maximal table width.") ())

(property-set! var prop what conds*)
  <= (table-set-maximal-width (#:argument w) ("Maximal table width") ())

(property-set! var prop what conds*)
  <= (table-set-maximal-width #:arguments (w) ())

(property-set! var prop what conds*)
  <= (table-set-maximal-width #:check-mark ("o" #<procedure table-test-maximal-width? args>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" table-test-maximal-width?) (tm-define-overloaded (table-ia-maximal-width) (interactive table-set-maximal-width)))
    => ((quote table-ia-maximal-width) #:check-mark (list "o" table-test-maximal-width?))
 => cons <> cur-props
    => cur-props => (((quote table-ia-maximal-width) #:check-mark (list "o" table-test-maximal-width?)))

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (table-ia-maximal-width) (interactive table-set-maximal-width)))
    => ((quote table-ia-maximal-width) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote table-ia-maximal-width) #:interactive (list #t)) ((quote table-ia-maximal-width) #:check-mark (list "o" table-test-maximal-width?)))

(property-set! var prop what conds*)
  <= (table-ia-maximal-width #:interactive (#t) ())

(property-set! var prop what conds*)
  <= (table-ia-maximal-width #:check-mark ("o" #<procedure table-test-maximal-width? args>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" table-test-parwidth?) (tm-define-overloaded (table-toggle-parwidth) (if (table-test-parwidth?) (table-set-format-list (quote ("table-width" "table-hmode")) (quote ("" ""))) (table-set-format-list (quote ("table-width" "table-hmode")) (quote ("1par" "exact"))))))
    => ((quote table-toggle-parwidth) #:check-mark (list "o" table-test-parwidth?))
 => cons <> cur-props
    => cur-props => (((quote table-toggle-parwidth) #:check-mark (list "o" table-test-parwidth?)))

(property-set! var prop what conds*)
  <= (table-toggle-parwidth #:check-mark ("o" #<procedure table-test-parwidth? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" table-test-automatic-height?) (tm-define-overloaded (table-set-automatic-height) (table-set-format-list (quote ("table-height" "table-vmode")) (quote ("" "auto")))))
    => ((quote table-set-automatic-height) #:check-mark (list "o" table-test-automatic-height?))
 => cons <> cur-props
    => cur-props => (((quote table-set-automatic-height) #:check-mark (list "o" table-test-automatic-height?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Automatic determination of table height.") (tm-define-overloaded (table-set-automatic-height) (table-set-format-list (quote ("table-height" "table-vmode")) (quote ("" "auto")))))
   => ((quote table-set-automatic-height) #:synopsis (quote ("Automatic determination of table height.")))
 => cons <> cur-props
   => cur-props => (((quote table-set-automatic-height) #:synopsis (quote ("Automatic determination of table height."))) ((quote table-set-automatic-height) #:check-mark (list "o" table-test-automatic-height?)))

(property-set! var prop what conds*)
  <= (table-set-automatic-height #:synopsis ("Automatic determination of table height.") ())

(property-set! var prop what conds*)
  <= (table-set-automatic-height #:check-mark ("o" #<procedure table-test-automatic-height? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" table-test-minimal-height?) (tm-define-overloaded (table-set-minimal-height h) (table-set-format-list (quote ("table-height" "table-vmode")) (quasiquote ((unquote h) "max")))))
    => ((quote table-set-minimal-height) #:check-mark (list "o" table-test-minimal-height?))
 => cons <> cur-props
    => cur-props => (((quote table-set-minimal-height) #:check-mark (list "o" table-test-minimal-height?)))

  (define-option-argument opt decl)
    <= ((h "Minimal table height") (tm-define-overloaded (table-set-minimal-height h) (table-set-format-list (quote ("table-height" "table-vmode")) (quasiquote ((unquote h) "max")))))
    => cons <> cur-props <= ((quote table-set-minimal-height) #:arguments (quote (h)))
    => cons <> cur-props <= ((quote table-set-minimal-height) (quote (#:argument h)) (quote ("Minimal table height")))
    => cur-props => (((quote table-set-minimal-height) (quote (#:argument h)) (quote ("Minimal table height"))) ((quote table-set-minimal-height) #:arguments (quote (h))) ((quote table-set-minimal-height) #:check-mark (list "o" table-test-minimal-height?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set minimal table height.") (tm-define-overloaded (table-set-minimal-height h) (table-set-format-list (quote ("table-height" "table-vmode")) (quasiquote ((unquote h) "max")))))
   => ((quote table-set-minimal-height) #:synopsis (quote ("Set minimal table height.")))
 => cons <> cur-props
   => cur-props => (((quote table-set-minimal-height) #:synopsis (quote ("Set minimal table height."))) ((quote table-set-minimal-height) (quote (#:argument h)) (quote ("Minimal table height"))) ((quote table-set-minimal-height) #:arguments (quote (h))) ((quote table-set-minimal-height) #:check-mark (list "o" table-test-minimal-height?)))

(property-set! var prop what conds*)
  <= (table-set-minimal-height #:synopsis ("Set minimal table height.") ())

(property-set! var prop what conds*)
  <= (table-set-minimal-height (#:argument h) ("Minimal table height") ())

(property-set! var prop what conds*)
  <= (table-set-minimal-height #:arguments (h) ())

(property-set! var prop what conds*)
  <= (table-set-minimal-height #:check-mark ("o" #<procedure table-test-minimal-height? args>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" table-test-minimal-height?) (tm-define-overloaded (table-ia-minimal-height) (interactive table-set-minimal-height)))
    => ((quote table-ia-minimal-height) #:check-mark (list "o" table-test-minimal-height?))
 => cons <> cur-props
    => cur-props => (((quote table-ia-minimal-height) #:check-mark (list "o" table-test-minimal-height?)))

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (table-ia-minimal-height) (interactive table-set-minimal-height)))
    => ((quote table-ia-minimal-height) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote table-ia-minimal-height) #:interactive (list #t)) ((quote table-ia-minimal-height) #:check-mark (list "o" table-test-minimal-height?)))

(property-set! var prop what conds*)
  <= (table-ia-minimal-height #:interactive (#t) ())

(property-set! var prop what conds*)
  <= (table-ia-minimal-height #:check-mark ("o" #<procedure table-test-minimal-height? args>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" table-test-exact-height?) (tm-define-overloaded (table-set-exact-height h) (table-set-format-list (quote ("table-height" "table-vmode")) (quasiquote ((unquote h) "exact")))))
    => ((quote table-set-exact-height) #:check-mark (list "o" table-test-exact-height?))
 => cons <> cur-props
    => cur-props => (((quote table-set-exact-height) #:check-mark (list "o" table-test-exact-height?)))

  (define-option-argument opt decl)
    <= ((h "Table height") (tm-define-overloaded (table-set-exact-height h) (table-set-format-list (quote ("table-height" "table-vmode")) (quasiquote ((unquote h) "exact")))))
    => cons <> cur-props <= ((quote table-set-exact-height) #:arguments (quote (h)))
    => cons <> cur-props <= ((quote table-set-exact-height) (quote (#:argument h)) (quote ("Table height")))
    => cur-props => (((quote table-set-exact-height) (quote (#:argument h)) (quote ("Table height"))) ((quote table-set-exact-height) #:arguments (quote (h))) ((quote table-set-exact-height) #:check-mark (list "o" table-test-exact-height?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set table height.") (tm-define-overloaded (table-set-exact-height h) (table-set-format-list (quote ("table-height" "table-vmode")) (quasiquote ((unquote h) "exact")))))
   => ((quote table-set-exact-height) #:synopsis (quote ("Set table height.")))
 => cons <> cur-props
   => cur-props => (((quote table-set-exact-height) #:synopsis (quote ("Set table height."))) ((quote table-set-exact-height) (quote (#:argument h)) (quote ("Table height"))) ((quote table-set-exact-height) #:arguments (quote (h))) ((quote table-set-exact-height) #:check-mark (list "o" table-test-exact-height?)))

(property-set! var prop what conds*)
  <= (table-set-exact-height #:synopsis ("Set table height.") ())

(property-set! var prop what conds*)
  <= (table-set-exact-height (#:argument h) ("Table height") ())

(property-set! var prop what conds*)
  <= (table-set-exact-height #:arguments (h) ())

(property-set! var prop what conds*)
  <= (table-set-exact-height #:check-mark ("o" #<procedure table-test-exact-height? args>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" table-test-exact-height?) (tm-define-overloaded (table-ia-exact-height) (interactive table-set-exact-height)))
    => ((quote table-ia-exact-height) #:check-mark (list "o" table-test-exact-height?))
 => cons <> cur-props
    => cur-props => (((quote table-ia-exact-height) #:check-mark (list "o" table-test-exact-height?)))

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (table-ia-exact-height) (interactive table-set-exact-height)))
    => ((quote table-ia-exact-height) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote table-ia-exact-height) #:interactive (list #t)) ((quote table-ia-exact-height) #:check-mark (list "o" table-test-exact-height?)))

(property-set! var prop what conds*)
  <= (table-ia-exact-height #:interactive (#t) ())

(property-set! var prop what conds*)
  <= (table-ia-exact-height #:check-mark ("o" #<procedure table-test-exact-height? args>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" table-test-maximal-height?) (tm-define-overloaded (table-set-maximal-height h) (table-set-format-list (quote ("table-height" "table-vmode")) (quasiquote ((unquote h) "min")))))
    => ((quote table-set-maximal-height) #:check-mark (list "o" table-test-maximal-height?))
 => cons <> cur-props
    => cur-props => (((quote table-set-maximal-height) #:check-mark (list "o" table-test-maximal-height?)))

  (define-option-argument opt decl)
    <= ((h "Maximal table height") (tm-define-overloaded (table-set-maximal-height h) (table-set-format-list (quote ("table-height" "table-vmode")) (quasiquote ((unquote h) "min")))))
    => cons <> cur-props <= ((quote table-set-maximal-height) #:arguments (quote (h)))
    => cons <> cur-props <= ((quote table-set-maximal-height) (quote (#:argument h)) (quote ("Maximal table height")))
    => cur-props => (((quote table-set-maximal-height) (quote (#:argument h)) (quote ("Maximal table height"))) ((quote table-set-maximal-height) #:arguments (quote (h))) ((quote table-set-maximal-height) #:check-mark (list "o" table-test-maximal-height?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set maximal table height.") (tm-define-overloaded (table-set-maximal-height h) (table-set-format-list (quote ("table-height" "table-vmode")) (quasiquote ((unquote h) "min")))))
   => ((quote table-set-maximal-height) #:synopsis (quote ("Set maximal table height.")))
 => cons <> cur-props
   => cur-props => (((quote table-set-maximal-height) #:synopsis (quote ("Set maximal table height."))) ((quote table-set-maximal-height) (quote (#:argument h)) (quote ("Maximal table height"))) ((quote table-set-maximal-height) #:arguments (quote (h))) ((quote table-set-maximal-height) #:check-mark (list "o" table-test-maximal-height?)))

(property-set! var prop what conds*)
  <= (table-set-maximal-height #:synopsis ("Set maximal table height.") ())

(property-set! var prop what conds*)
  <= (table-set-maximal-height (#:argument h) ("Maximal table height") ())

(property-set! var prop what conds*)
  <= (table-set-maximal-height #:arguments (h) ())

(property-set! var prop what conds*)
  <= (table-set-maximal-height #:check-mark ("o" #<procedure table-test-maximal-height? args>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" table-test-maximal-height?) (tm-define-overloaded (table-ia-maximal-height) (interactive table-set-maximal-height)))
    => ((quote table-ia-maximal-height) #:check-mark (list "o" table-test-maximal-height?))
 => cons <> cur-props
    => cur-props => (((quote table-ia-maximal-height) #:check-mark (list "o" table-test-maximal-height?)))

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (table-ia-maximal-height) (interactive table-set-maximal-height)))
    => ((quote table-ia-maximal-height) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote table-ia-maximal-height) #:interactive (list #t)) ((quote table-ia-maximal-height) #:check-mark (list "o" table-test-maximal-height?)))

(property-set! var prop what conds*)
  <= (table-ia-maximal-height #:interactive (#t) ())

(property-set! var prop what conds*)
  <= (table-ia-maximal-height #:check-mark ("o" #<procedure table-test-maximal-height? args>) ())

  (define-option-argument opt decl)
    <= ((padding "Padding") (tm-define-overloaded (table-set-padding padding) (table-set-format-list (list "table-lsep" "table-rsep" "table-bsep" "table-tsep") (list padding padding padding padding))))
    => cons <> cur-props <= ((quote table-set-padding) #:arguments (quote (padding)))
    => cons <> cur-props <= ((quote table-set-padding) (quote (#:argument padding)) (quote ("Padding")))
    => cur-props => (((quote table-set-padding) (quote (#:argument padding)) (quote ("Padding"))) ((quote table-set-padding) #:arguments (quote (padding))))

(property-set! var prop what conds*)
  <= (table-set-padding (#:argument padding) ("Padding") ())

(property-set! var prop what conds*)
  <= (table-set-padding #:arguments (padding) ())

  (define-option-argument opt decl)
    <= ((border "Border width") (tm-define-overloaded (table-set-border border) (table-set-format-list (list "table-lborder" "table-rborder" "table-bborder" "table-tborder") (list border border border border))))
    => cons <> cur-props <= ((quote table-set-border) #:arguments (quote (border)))
    => cons <> cur-props <= ((quote table-set-border) (quote (#:argument border)) (quote ("Border width")))
    => cur-props => (((quote table-set-border) (quote (#:argument border)) (quote ("Border width"))) ((quote table-set-border) #:arguments (quote (border))))

(property-set! var prop what conds*)
  <= (table-set-border (#:argument border) ("Border width") ())

(property-set! var prop what conds*)
  <= (table-set-border #:arguments (border) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" table-test-halign?) (tm-define-overloaded (table-set-halign s) (table-set-format* "table-halign" s)))
    => ((quote table-set-halign) #:check-mark (list "*" table-test-halign?))
 => cons <> cur-props
    => cur-props => (((quote table-set-halign) #:check-mark (list "*" table-test-halign?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set horizontal table alignment.") (tm-define-overloaded (table-set-halign s) (table-set-format* "table-halign" s)))
   => ((quote table-set-halign) #:synopsis (quote ("Set horizontal table alignment.")))
 => cons <> cur-props
   => cur-props => (((quote table-set-halign) #:synopsis (quote ("Set horizontal table alignment."))) ((quote table-set-halign) #:check-mark (list "*" table-test-halign?)))

(property-set! var prop what conds*)
  <= (table-set-halign #:synopsis ("Set horizontal table alignment.") ())

(property-set! var prop what conds*)
  <= (table-set-halign #:check-mark ("*" #<procedure table-test-halign? (s)>) ())

  (define-option-argument opt decl)
    <= ((col "Align at column") (tm-define-overloaded (table-specific-halign col) (table-set-format-list (list "table-col-origin" "table-halign") (list col "O"))))
    => cons <> cur-props <= ((quote table-specific-halign) #:arguments (quote (col)))
    => cons <> cur-props <= ((quote table-specific-halign) (quote (#:argument col)) (quote ("Align at column")))
    => cur-props => (((quote table-specific-halign) (quote (#:argument col)) (quote ("Align at column"))) ((quote table-specific-halign) #:arguments (quote (col))))

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" table-test-specific-halign?) (tm-define-overloaded (table-specific-halign col) (table-set-format-list (list "table-col-origin" "table-halign") (list col "O"))))
    => ((quote table-specific-halign) #:check-mark (list "*" table-test-specific-halign?))
 => cons <> cur-props
    => cur-props => (((quote table-specific-halign) #:check-mark (list "*" table-test-specific-halign?)) ((quote table-specific-halign) (quote (#:argument col)) (quote ("Align at column"))) ((quote table-specific-halign) #:arguments (quote (col))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Align horizontally at the baseline of a specific column.") (tm-define-overloaded (table-specific-halign col) (table-set-format-list (list "table-col-origin" "table-halign") (list col "O"))))
   => ((quote table-specific-halign) #:synopsis (quote ("Align horizontally at the baseline of a specific column.")))
 => cons <> cur-props
   => cur-props => (((quote table-specific-halign) #:synopsis (quote ("Align horizontally at the baseline of a specific column."))) ((quote table-specific-halign) #:check-mark (list "*" table-test-specific-halign?)) ((quote table-specific-halign) (quote (#:argument col)) (quote ("Align at column"))) ((quote table-specific-halign) #:arguments (quote (col))))

(property-set! var prop what conds*)
  <= (table-specific-halign #:synopsis ("Align horizontally at the baseline of a specific column.") ())

(property-set! var prop what conds*)
  <= (table-specific-halign #:check-mark ("*" #<procedure table-test-specific-halign? l>) ())

(property-set! var prop what conds*)
  <= (table-specific-halign (#:argument col) ("Align at column") ())

(property-set! var prop what conds*)
  <= (table-specific-halign #:arguments (col) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" table-test-valign?) (tm-define-overloaded (table-set-valign s) (table-set-format* "table-valign" s)))
    => ((quote table-set-valign) #:check-mark (list "*" table-test-valign?))
 => cons <> cur-props
    => cur-props => (((quote table-set-valign) #:check-mark (list "*" table-test-valign?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set vertical table alignment.") (tm-define-overloaded (table-set-valign s) (table-set-format* "table-valign" s)))
   => ((quote table-set-valign) #:synopsis (quote ("Set vertical table alignment.")))
 => cons <> cur-props
   => cur-props => (((quote table-set-valign) #:synopsis (quote ("Set vertical table alignment."))) ((quote table-set-valign) #:check-mark (list "*" table-test-valign?)))

(property-set! var prop what conds*)
  <= (table-set-valign #:synopsis ("Set vertical table alignment.") ())

(property-set! var prop what conds*)
  <= (table-set-valign #:check-mark ("*" #<procedure table-test-valign? (s)>) ())

  (define-option-argument opt decl)
    <= ((row "Align at row") (tm-define-overloaded (table-specific-valign row) (table-set-format-list (list "table-row-origin" "table-valign") (list row "O"))))
    => cons <> cur-props <= ((quote table-specific-valign) #:arguments (quote (row)))
    => cons <> cur-props <= ((quote table-specific-valign) (quote (#:argument row)) (quote ("Align at row")))
    => cur-props => (((quote table-specific-valign) (quote (#:argument row)) (quote ("Align at row"))) ((quote table-specific-valign) #:arguments (quote (row))))

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" table-test-specific-valign?) (tm-define-overloaded (table-specific-valign row) (table-set-format-list (list "table-row-origin" "table-valign") (list row "O"))))
    => ((quote table-specific-valign) #:check-mark (list "*" table-test-specific-valign?))
 => cons <> cur-props
    => cur-props => (((quote table-specific-valign) #:check-mark (list "*" table-test-specific-valign?)) ((quote table-specific-valign) (quote (#:argument row)) (quote ("Align at row"))) ((quote table-specific-valign) #:arguments (quote (row))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Align vertically at the baseline of a specific row.") (tm-define-overloaded (table-specific-valign row) (table-set-format-list (list "table-row-origin" "table-valign") (list row "O"))))
   => ((quote table-specific-valign) #:synopsis (quote ("Align vertically at the baseline of a specific row.")))
 => cons <> cur-props
   => cur-props => (((quote table-specific-valign) #:synopsis (quote ("Align vertically at the baseline of a specific row."))) ((quote table-specific-valign) #:check-mark (list "*" table-test-specific-valign?)) ((quote table-specific-valign) (quote (#:argument row)) (quote ("Align at row"))) ((quote table-specific-valign) #:arguments (quote (row))))

(property-set! var prop what conds*)
  <= (table-specific-valign #:synopsis ("Align vertically at the baseline of a specific row.") ())

(property-set! var prop what conds*)
  <= (table-specific-valign #:check-mark ("*" #<procedure table-test-specific-valign? l>) ())

(property-set! var prop what conds*)
  <= (table-specific-valign (#:argument row) ("Align at row") ())

(property-set! var prop what conds*)
  <= (table-specific-valign #:arguments (row) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" table-hyphen?) (tm-define-overloaded (toggle-table-hyphen) (table-set-hyphen (if (table-hyphen?) "n" "y"))))
    => ((quote toggle-table-hyphen) #:check-mark (list "v" table-hyphen?))
 => cons <> cur-props
    => cur-props => (((quote toggle-table-hyphen) #:check-mark (list "v" table-hyphen?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle table hyphenation.") (tm-define-overloaded (toggle-table-hyphen) (table-set-hyphen (if (table-hyphen?) "n" "y"))))
   => ((quote toggle-table-hyphen) #:synopsis (quote ("Toggle table hyphenation.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-table-hyphen) #:synopsis (quote ("Toggle table hyphenation."))) ((quote toggle-table-hyphen) #:check-mark (list "v" table-hyphen?)))

(property-set! var prop what conds*)
  <= (toggle-table-hyphen #:synopsis ("Toggle table hyphenation.") ())

(property-set! var prop what conds*)
  <= (toggle-table-hyphen #:check-mark ("v" #<procedure table-hyphen? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" test-cell-mode?) (tm-property-overloaded (set-cell-mode s)))
    => ((quote set-cell-mode) #:check-mark (list "*" test-cell-mode?))
 => cons <> cur-props
    => cur-props => (((quote set-cell-mode) #:check-mark (list "*" test-cell-mode?)))

(property-set! var prop what conds*)
  <= (set-cell-mode #:check-mark ("*" #<procedure test-cell-mode? (s)>) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (cell-interactive-set var) (interactive (lambda (s) (cell-set-format* var s)) (logic-ref env-var-description% var))))
    => ((quote cell-interactive-set) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote cell-interactive-set) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (cell-interactive-set #:interactive (#t) ())

  (define-option-default opt decl)
    <= ((h "0.5spc") (tm-define-overloaded (table-insert-blank-row h) (with old-mode (get-cell-mode) (set-cell-mode "row") (table-insert-row #t) (cell-set-format "cell-background" "") (cell-set-format "cell-lborder" "0ln") (cell-set-format "cell-rborder" "0ln") (cell-set-format "cell-lsep" "0ln") (cell-set-format "cell-rsep" "0ln") (cell-set-format "cell-tsep" "0ln") (cell-set-format "cell-bsep" "0ln") (cell-set-format "cell-vcorrect" "n") (cell-set-format "cell-vmode" "exact") (cell-set-format "cell-height" h) (set-cell-mode old-mode))))
    => cons <> cur-props <= ((quote table-insert-blank-row) (quote (#:default h)) (lambda () "0.5spc"))
    => cur-props => (((quote table-insert-blank-row) (quote (#:default h)) (lambda () "0.5spc")))

  (define-option-argument opt decl)
    <= ((h "Height of row") (tm-define-overloaded (table-insert-blank-row h) (with old-mode (get-cell-mode) (set-cell-mode "row") (table-insert-row #t) (cell-set-format "cell-background" "") (cell-set-format "cell-lborder" "0ln") (cell-set-format "cell-rborder" "0ln") (cell-set-format "cell-lsep" "0ln") (cell-set-format "cell-rsep" "0ln") (cell-set-format "cell-tsep" "0ln") (cell-set-format "cell-bsep" "0ln") (cell-set-format "cell-vcorrect" "n") (cell-set-format "cell-vmode" "exact") (cell-set-format "cell-height" h) (set-cell-mode old-mode))))
    => cons <> cur-props <= ((quote table-insert-blank-row) #:arguments (quote (h)))
    => cons <> cur-props <= ((quote table-insert-blank-row) (quote (#:argument h)) (quote ("Height of row")))
    => cur-props => (((quote table-insert-blank-row) (quote (#:argument h)) (quote ("Height of row"))) ((quote table-insert-blank-row) #:arguments (quote (h))) ((quote table-insert-blank-row) (quote (#:default h)) (lambda () "0.5spc")))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Insert a blank row below cursor.") (tm-define-overloaded (table-insert-blank-row h) (with old-mode (get-cell-mode) (set-cell-mode "row") (table-insert-row #t) (cell-set-format "cell-background" "") (cell-set-format "cell-lborder" "0ln") (cell-set-format "cell-rborder" "0ln") (cell-set-format "cell-lsep" "0ln") (cell-set-format "cell-rsep" "0ln") (cell-set-format "cell-tsep" "0ln") (cell-set-format "cell-bsep" "0ln") (cell-set-format "cell-vcorrect" "n") (cell-set-format "cell-vmode" "exact") (cell-set-format "cell-height" h) (set-cell-mode old-mode))))
   => ((quote table-insert-blank-row) #:synopsis (quote ("Insert a blank row below cursor.")))
 => cons <> cur-props
   => cur-props => (((quote table-insert-blank-row) #:synopsis (quote ("Insert a blank row below cursor."))) ((quote table-insert-blank-row) (quote (#:argument h)) (quote ("Height of row"))) ((quote table-insert-blank-row) #:arguments (quote (h))) ((quote table-insert-blank-row) (quote (#:default h)) (lambda () "0.5spc")))

(property-set! var prop what conds*)
  <= (table-insert-blank-row #:synopsis ("Insert a blank row below cursor.") ())

(property-set! var prop what conds*)
  <= (table-insert-blank-row (#:argument h) ("Height of row") ())

(property-set! var prop what conds*)
  <= (table-insert-blank-row #:arguments (h) ())

(property-set! var prop what conds*)
  <= (table-insert-blank-row (#:default h) #<procedure #f ()> ())

  (define-option-default opt decl)
    <= ((w "0.5spc") (tm-define-overloaded (table-insert-blank-column w) (with old-mode (get-cell-mode) (set-cell-mode "column") (table-insert-column #t) (cell-set-format "cell-background" "") (cell-set-format "cell-tborder" "0ln") (cell-set-format "cell-bborder" "0ln") (cell-set-format "cell-lsep" "0ln") (cell-set-format "cell-rsep" "0ln") (cell-set-format "cell-tsep" "0ln") (cell-set-format "cell-bsep" "0ln") (cell-set-format "cell-vcorrect" "n") (cell-set-format "cell-hmode" "exact") (cell-set-format "cell-width" w) (set-cell-mode old-mode))))
    => cons <> cur-props <= ((quote table-insert-blank-column) (quote (#:default w)) (lambda () "0.5spc"))
    => cur-props => (((quote table-insert-blank-column) (quote (#:default w)) (lambda () "0.5spc")))

  (define-option-argument opt decl)
    <= ((w "Width of the column") (tm-define-overloaded (table-insert-blank-column w) (with old-mode (get-cell-mode) (set-cell-mode "column") (table-insert-column #t) (cell-set-format "cell-background" "") (cell-set-format "cell-tborder" "0ln") (cell-set-format "cell-bborder" "0ln") (cell-set-format "cell-lsep" "0ln") (cell-set-format "cell-rsep" "0ln") (cell-set-format "cell-tsep" "0ln") (cell-set-format "cell-bsep" "0ln") (cell-set-format "cell-vcorrect" "n") (cell-set-format "cell-hmode" "exact") (cell-set-format "cell-width" w) (set-cell-mode old-mode))))
    => cons <> cur-props <= ((quote table-insert-blank-column) #:arguments (quote (w)))
    => cons <> cur-props <= ((quote table-insert-blank-column) (quote (#:argument w)) (quote ("Width of the column")))
    => cur-props => (((quote table-insert-blank-column) (quote (#:argument w)) (quote ("Width of the column"))) ((quote table-insert-blank-column) #:arguments (quote (w))) ((quote table-insert-blank-column) (quote (#:default w)) (lambda () "0.5spc")))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Insert a blank column at the right of the cursor.") (tm-define-overloaded (table-insert-blank-column w) (with old-mode (get-cell-mode) (set-cell-mode "column") (table-insert-column #t) (cell-set-format "cell-background" "") (cell-set-format "cell-tborder" "0ln") (cell-set-format "cell-bborder" "0ln") (cell-set-format "cell-lsep" "0ln") (cell-set-format "cell-rsep" "0ln") (cell-set-format "cell-tsep" "0ln") (cell-set-format "cell-bsep" "0ln") (cell-set-format "cell-vcorrect" "n") (cell-set-format "cell-hmode" "exact") (cell-set-format "cell-width" w) (set-cell-mode old-mode))))
   => ((quote table-insert-blank-column) #:synopsis (quote ("Insert a blank column at the right of the cursor.")))
 => cons <> cur-props
   => cur-props => (((quote table-insert-blank-column) #:synopsis (quote ("Insert a blank column at the right of the cursor."))) ((quote table-insert-blank-column) (quote (#:argument w)) (quote ("Width of the column"))) ((quote table-insert-blank-column) #:arguments (quote (w))) ((quote table-insert-blank-column) (quote (#:default w)) (lambda () "0.5spc")))

(property-set! var prop what conds*)
  <= (table-insert-blank-column #:synopsis ("Insert a blank column at the right of the cursor.") ())

(property-set! var prop what conds*)
  <= (table-insert-blank-column (#:argument w) ("Width of the column") ())

(property-set! var prop what conds*)
  <= (table-insert-blank-column #:arguments (w) ())

(property-set! var prop what conds*)
  <= (table-insert-blank-column (#:default w) #<procedure #f ()> ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" cell-test-automatic-width?) (tm-define-overloaded (cell-set-automatic-width) (cell-set-format-list (quote ("cell-width" "cell-hmode")) (quote ("" "auto")))))
    => ((quote cell-set-automatic-width) #:check-mark (list "o" cell-test-automatic-width?))
 => cons <> cur-props
    => cur-props => (((quote cell-set-automatic-width) #:check-mark (list "o" cell-test-automatic-width?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Automatic determination of cell width.") (tm-define-overloaded (cell-set-automatic-width) (cell-set-format-list (quote ("cell-width" "cell-hmode")) (quote ("" "auto")))))
   => ((quote cell-set-automatic-width) #:synopsis (quote ("Automatic determination of cell width.")))
 => cons <> cur-props
   => cur-props => (((quote cell-set-automatic-width) #:synopsis (quote ("Automatic determination of cell width."))) ((quote cell-set-automatic-width) #:check-mark (list "o" cell-test-automatic-width?)))

(property-set! var prop what conds*)
  <= (cell-set-automatic-width #:synopsis ("Automatic determination of cell width.") ())

(property-set! var prop what conds*)
  <= (cell-set-automatic-width #:check-mark ("o" #<procedure cell-test-automatic-width? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" cell-test-minimal-width?) (tm-define-overloaded (cell-set-minimal-width w) (cell-set-format-list (quote ("cell-width" "cell-hmode")) (quasiquote ((unquote w) "max")))))
    => ((quote cell-set-minimal-width) #:check-mark (list "o" cell-test-minimal-width?))
 => cons <> cur-props
    => cur-props => (((quote cell-set-minimal-width) #:check-mark (list "o" cell-test-minimal-width?)))

  (define-option-argument opt decl)
    <= ((w "Minimal cell width") (tm-define-overloaded (cell-set-minimal-width w) (cell-set-format-list (quote ("cell-width" "cell-hmode")) (quasiquote ((unquote w) "max")))))
    => cons <> cur-props <= ((quote cell-set-minimal-width) #:arguments (quote (w)))
    => cons <> cur-props <= ((quote cell-set-minimal-width) (quote (#:argument w)) (quote ("Minimal cell width")))
    => cur-props => (((quote cell-set-minimal-width) (quote (#:argument w)) (quote ("Minimal cell width"))) ((quote cell-set-minimal-width) #:arguments (quote (w))) ((quote cell-set-minimal-width) #:check-mark (list "o" cell-test-minimal-width?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set minimal cell width.") (tm-define-overloaded (cell-set-minimal-width w) (cell-set-format-list (quote ("cell-width" "cell-hmode")) (quasiquote ((unquote w) "max")))))
   => ((quote cell-set-minimal-width) #:synopsis (quote ("Set minimal cell width.")))
 => cons <> cur-props
   => cur-props => (((quote cell-set-minimal-width) #:synopsis (quote ("Set minimal cell width."))) ((quote cell-set-minimal-width) (quote (#:argument w)) (quote ("Minimal cell width"))) ((quote cell-set-minimal-width) #:arguments (quote (w))) ((quote cell-set-minimal-width) #:check-mark (list "o" cell-test-minimal-width?)))

(property-set! var prop what conds*)
  <= (cell-set-minimal-width #:synopsis ("Set minimal cell width.") ())

(property-set! var prop what conds*)
  <= (cell-set-minimal-width (#:argument w) ("Minimal cell width") ())

(property-set! var prop what conds*)
  <= (cell-set-minimal-width #:arguments (w) ())

(property-set! var prop what conds*)
  <= (cell-set-minimal-width #:check-mark ("o" #<procedure cell-test-minimal-width? args>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" cell-test-minimal-width?) (tm-define-overloaded (cell-ia-minimal-width) (interactive cell-set-minimal-width)))
    => ((quote cell-ia-minimal-width) #:check-mark (list "o" cell-test-minimal-width?))
 => cons <> cur-props
    => cur-props => (((quote cell-ia-minimal-width) #:check-mark (list "o" cell-test-minimal-width?)))

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (cell-ia-minimal-width) (interactive cell-set-minimal-width)))
    => ((quote cell-ia-minimal-width) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote cell-ia-minimal-width) #:interactive (list #t)) ((quote cell-ia-minimal-width) #:check-mark (list "o" cell-test-minimal-width?)))

(property-set! var prop what conds*)
  <= (cell-ia-minimal-width #:interactive (#t) ())

(property-set! var prop what conds*)
  <= (cell-ia-minimal-width #:check-mark ("o" #<procedure cell-test-minimal-width? args>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" cell-test-exact-width?) (tm-define-overloaded (cell-set-exact-width w) (cell-set-format-list (quote ("cell-width" "cell-hmode")) (quasiquote ((unquote w) "exact")))))
    => ((quote cell-set-exact-width) #:check-mark (list "o" cell-test-exact-width?))
 => cons <> cur-props
    => cur-props => (((quote cell-set-exact-width) #:check-mark (list "o" cell-test-exact-width?)))

  (define-option-argument opt decl)
    <= ((w "Cell width") (tm-define-overloaded (cell-set-exact-width w) (cell-set-format-list (quote ("cell-width" "cell-hmode")) (quasiquote ((unquote w) "exact")))))
    => cons <> cur-props <= ((quote cell-set-exact-width) #:arguments (quote (w)))
    => cons <> cur-props <= ((quote cell-set-exact-width) (quote (#:argument w)) (quote ("Cell width")))
    => cur-props => (((quote cell-set-exact-width) (quote (#:argument w)) (quote ("Cell width"))) ((quote cell-set-exact-width) #:arguments (quote (w))) ((quote cell-set-exact-width) #:check-mark (list "o" cell-test-exact-width?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set cell width.") (tm-define-overloaded (cell-set-exact-width w) (cell-set-format-list (quote ("cell-width" "cell-hmode")) (quasiquote ((unquote w) "exact")))))
   => ((quote cell-set-exact-width) #:synopsis (quote ("Set cell width.")))
 => cons <> cur-props
   => cur-props => (((quote cell-set-exact-width) #:synopsis (quote ("Set cell width."))) ((quote cell-set-exact-width) (quote (#:argument w)) (quote ("Cell width"))) ((quote cell-set-exact-width) #:arguments (quote (w))) ((quote cell-set-exact-width) #:check-mark (list "o" cell-test-exact-width?)))

(property-set! var prop what conds*)
  <= (cell-set-exact-width #:synopsis ("Set cell width.") ())

(property-set! var prop what conds*)
  <= (cell-set-exact-width (#:argument w) ("Cell width") ())

(property-set! var prop what conds*)
  <= (cell-set-exact-width #:arguments (w) ())

(property-set! var prop what conds*)
  <= (cell-set-exact-width #:check-mark ("o" #<procedure cell-test-exact-width? args>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" cell-test-exact-width?) (tm-define-overloaded (cell-ia-exact-width) (interactive cell-set-exact-width)))
    => ((quote cell-ia-exact-width) #:check-mark (list "o" cell-test-exact-width?))
 => cons <> cur-props
    => cur-props => (((quote cell-ia-exact-width) #:check-mark (list "o" cell-test-exact-width?)))

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (cell-ia-exact-width) (interactive cell-set-exact-width)))
    => ((quote cell-ia-exact-width) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote cell-ia-exact-width) #:interactive (list #t)) ((quote cell-ia-exact-width) #:check-mark (list "o" cell-test-exact-width?)))

(property-set! var prop what conds*)
  <= (cell-ia-exact-width #:interactive (#t) ())

(property-set! var prop what conds*)
  <= (cell-ia-exact-width #:check-mark ("o" #<procedure cell-test-exact-width? args>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" cell-test-maximal-width?) (tm-define-overloaded (cell-set-maximal-width w) (cell-set-format-list (quote ("cell-width" "cell-hmode")) (quasiquote ((unquote w) "min")))))
    => ((quote cell-set-maximal-width) #:check-mark (list "o" cell-test-maximal-width?))
 => cons <> cur-props
    => cur-props => (((quote cell-set-maximal-width) #:check-mark (list "o" cell-test-maximal-width?)))

  (define-option-argument opt decl)
    <= ((w "Maximal cell width") (tm-define-overloaded (cell-set-maximal-width w) (cell-set-format-list (quote ("cell-width" "cell-hmode")) (quasiquote ((unquote w) "min")))))
    => cons <> cur-props <= ((quote cell-set-maximal-width) #:arguments (quote (w)))
    => cons <> cur-props <= ((quote cell-set-maximal-width) (quote (#:argument w)) (quote ("Maximal cell width")))
    => cur-props => (((quote cell-set-maximal-width) (quote (#:argument w)) (quote ("Maximal cell width"))) ((quote cell-set-maximal-width) #:arguments (quote (w))) ((quote cell-set-maximal-width) #:check-mark (list "o" cell-test-maximal-width?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set maximal cell width.") (tm-define-overloaded (cell-set-maximal-width w) (cell-set-format-list (quote ("cell-width" "cell-hmode")) (quasiquote ((unquote w) "min")))))
   => ((quote cell-set-maximal-width) #:synopsis (quote ("Set maximal cell width.")))
 => cons <> cur-props
   => cur-props => (((quote cell-set-maximal-width) #:synopsis (quote ("Set maximal cell width."))) ((quote cell-set-maximal-width) (quote (#:argument w)) (quote ("Maximal cell width"))) ((quote cell-set-maximal-width) #:arguments (quote (w))) ((quote cell-set-maximal-width) #:check-mark (list "o" cell-test-maximal-width?)))

(property-set! var prop what conds*)
  <= (cell-set-maximal-width #:synopsis ("Set maximal cell width.") ())

(property-set! var prop what conds*)
  <= (cell-set-maximal-width (#:argument w) ("Maximal cell width") ())

(property-set! var prop what conds*)
  <= (cell-set-maximal-width #:arguments (w) ())

(property-set! var prop what conds*)
  <= (cell-set-maximal-width #:check-mark ("o" #<procedure cell-test-maximal-width? args>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" cell-test-maximal-width?) (tm-define-overloaded (cell-ia-maximal-width) (interactive cell-set-maximal-width)))
    => ((quote cell-ia-maximal-width) #:check-mark (list "o" cell-test-maximal-width?))
 => cons <> cur-props
    => cur-props => (((quote cell-ia-maximal-width) #:check-mark (list "o" cell-test-maximal-width?)))

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (cell-ia-maximal-width) (interactive cell-set-maximal-width)))
    => ((quote cell-ia-maximal-width) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote cell-ia-maximal-width) #:interactive (list #t)) ((quote cell-ia-maximal-width) #:check-mark (list "o" cell-test-maximal-width?)))

(property-set! var prop what conds*)
  <= (cell-ia-maximal-width #:interactive (#t) ())

(property-set! var prop what conds*)
  <= (cell-ia-maximal-width #:check-mark ("o" #<procedure cell-test-maximal-width? args>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" cell-test-automatic-height?) (tm-define-overloaded (cell-set-automatic-height) (cell-set-format-list (quote ("cell-height" "cell-vmode")) (quote ("" "auto")))))
    => ((quote cell-set-automatic-height) #:check-mark (list "o" cell-test-automatic-height?))
 => cons <> cur-props
    => cur-props => (((quote cell-set-automatic-height) #:check-mark (list "o" cell-test-automatic-height?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Automatic determination of cell height.") (tm-define-overloaded (cell-set-automatic-height) (cell-set-format-list (quote ("cell-height" "cell-vmode")) (quote ("" "auto")))))
   => ((quote cell-set-automatic-height) #:synopsis (quote ("Automatic determination of cell height.")))
 => cons <> cur-props
   => cur-props => (((quote cell-set-automatic-height) #:synopsis (quote ("Automatic determination of cell height."))) ((quote cell-set-automatic-height) #:check-mark (list "o" cell-test-automatic-height?)))

(property-set! var prop what conds*)
  <= (cell-set-automatic-height #:synopsis ("Automatic determination of cell height.") ())

(property-set! var prop what conds*)
  <= (cell-set-automatic-height #:check-mark ("o" #<procedure cell-test-automatic-height? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" cell-test-minimal-height?) (tm-define-overloaded (cell-set-minimal-height h) (cell-set-format-list (quote ("cell-height" "cell-vmode")) (quasiquote ((unquote h) "max")))))
    => ((quote cell-set-minimal-height) #:check-mark (list "o" cell-test-minimal-height?))
 => cons <> cur-props
    => cur-props => (((quote cell-set-minimal-height) #:check-mark (list "o" cell-test-minimal-height?)))

  (define-option-argument opt decl)
    <= ((h "Minimal cell height") (tm-define-overloaded (cell-set-minimal-height h) (cell-set-format-list (quote ("cell-height" "cell-vmode")) (quasiquote ((unquote h) "max")))))
    => cons <> cur-props <= ((quote cell-set-minimal-height) #:arguments (quote (h)))
    => cons <> cur-props <= ((quote cell-set-minimal-height) (quote (#:argument h)) (quote ("Minimal cell height")))
    => cur-props => (((quote cell-set-minimal-height) (quote (#:argument h)) (quote ("Minimal cell height"))) ((quote cell-set-minimal-height) #:arguments (quote (h))) ((quote cell-set-minimal-height) #:check-mark (list "o" cell-test-minimal-height?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set minimal cell height.") (tm-define-overloaded (cell-set-minimal-height h) (cell-set-format-list (quote ("cell-height" "cell-vmode")) (quasiquote ((unquote h) "max")))))
   => ((quote cell-set-minimal-height) #:synopsis (quote ("Set minimal cell height.")))
 => cons <> cur-props
   => cur-props => (((quote cell-set-minimal-height) #:synopsis (quote ("Set minimal cell height."))) ((quote cell-set-minimal-height) (quote (#:argument h)) (quote ("Minimal cell height"))) ((quote cell-set-minimal-height) #:arguments (quote (h))) ((quote cell-set-minimal-height) #:check-mark (list "o" cell-test-minimal-height?)))

(property-set! var prop what conds*)
  <= (cell-set-minimal-height #:synopsis ("Set minimal cell height.") ())

(property-set! var prop what conds*)
  <= (cell-set-minimal-height (#:argument h) ("Minimal cell height") ())

(property-set! var prop what conds*)
  <= (cell-set-minimal-height #:arguments (h) ())

(property-set! var prop what conds*)
  <= (cell-set-minimal-height #:check-mark ("o" #<procedure cell-test-minimal-height? args>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" cell-test-minimal-height?) (tm-define-overloaded (cell-ia-minimal-height) (interactive cell-set-minimal-height)))
    => ((quote cell-ia-minimal-height) #:check-mark (list "o" cell-test-minimal-height?))
 => cons <> cur-props
    => cur-props => (((quote cell-ia-minimal-height) #:check-mark (list "o" cell-test-minimal-height?)))

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (cell-ia-minimal-height) (interactive cell-set-minimal-height)))
    => ((quote cell-ia-minimal-height) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote cell-ia-minimal-height) #:interactive (list #t)) ((quote cell-ia-minimal-height) #:check-mark (list "o" cell-test-minimal-height?)))

(property-set! var prop what conds*)
  <= (cell-ia-minimal-height #:interactive (#t) ())

(property-set! var prop what conds*)
  <= (cell-ia-minimal-height #:check-mark ("o" #<procedure cell-test-minimal-height? args>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" cell-test-exact-height?) (tm-define-overloaded (cell-set-exact-height h) (cell-set-format-list (quote ("cell-height" "cell-vmode")) (quasiquote ((unquote h) "exact")))))
    => ((quote cell-set-exact-height) #:check-mark (list "o" cell-test-exact-height?))
 => cons <> cur-props
    => cur-props => (((quote cell-set-exact-height) #:check-mark (list "o" cell-test-exact-height?)))

  (define-option-argument opt decl)
    <= ((h "Cell height") (tm-define-overloaded (cell-set-exact-height h) (cell-set-format-list (quote ("cell-height" "cell-vmode")) (quasiquote ((unquote h) "exact")))))
    => cons <> cur-props <= ((quote cell-set-exact-height) #:arguments (quote (h)))
    => cons <> cur-props <= ((quote cell-set-exact-height) (quote (#:argument h)) (quote ("Cell height")))
    => cur-props => (((quote cell-set-exact-height) (quote (#:argument h)) (quote ("Cell height"))) ((quote cell-set-exact-height) #:arguments (quote (h))) ((quote cell-set-exact-height) #:check-mark (list "o" cell-test-exact-height?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set cell height.") (tm-define-overloaded (cell-set-exact-height h) (cell-set-format-list (quote ("cell-height" "cell-vmode")) (quasiquote ((unquote h) "exact")))))
   => ((quote cell-set-exact-height) #:synopsis (quote ("Set cell height.")))
 => cons <> cur-props
   => cur-props => (((quote cell-set-exact-height) #:synopsis (quote ("Set cell height."))) ((quote cell-set-exact-height) (quote (#:argument h)) (quote ("Cell height"))) ((quote cell-set-exact-height) #:arguments (quote (h))) ((quote cell-set-exact-height) #:check-mark (list "o" cell-test-exact-height?)))

(property-set! var prop what conds*)
  <= (cell-set-exact-height #:synopsis ("Set cell height.") ())

(property-set! var prop what conds*)
  <= (cell-set-exact-height (#:argument h) ("Cell height") ())

(property-set! var prop what conds*)
  <= (cell-set-exact-height #:arguments (h) ())

(property-set! var prop what conds*)
  <= (cell-set-exact-height #:check-mark ("o" #<procedure cell-test-exact-height? args>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" cell-test-exact-height?) (tm-define-overloaded (cell-ia-exact-height) (interactive cell-set-exact-height)))
    => ((quote cell-ia-exact-height) #:check-mark (list "o" cell-test-exact-height?))
 => cons <> cur-props
    => cur-props => (((quote cell-ia-exact-height) #:check-mark (list "o" cell-test-exact-height?)))

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (cell-ia-exact-height) (interactive cell-set-exact-height)))
    => ((quote cell-ia-exact-height) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote cell-ia-exact-height) #:interactive (list #t)) ((quote cell-ia-exact-height) #:check-mark (list "o" cell-test-exact-height?)))

(property-set! var prop what conds*)
  <= (cell-ia-exact-height #:interactive (#t) ())

(property-set! var prop what conds*)
  <= (cell-ia-exact-height #:check-mark ("o" #<procedure cell-test-exact-height? args>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" cell-test-maximal-height?) (tm-define-overloaded (cell-set-maximal-height h) (cell-set-format-list (quote ("cell-height" "cell-vmode")) (quasiquote ((unquote h) "min")))))
    => ((quote cell-set-maximal-height) #:check-mark (list "o" cell-test-maximal-height?))
 => cons <> cur-props
    => cur-props => (((quote cell-set-maximal-height) #:check-mark (list "o" cell-test-maximal-height?)))

  (define-option-argument opt decl)
    <= ((h "Maximal cell height") (tm-define-overloaded (cell-set-maximal-height h) (cell-set-format-list (quote ("cell-height" "cell-vmode")) (quasiquote ((unquote h) "min")))))
    => cons <> cur-props <= ((quote cell-set-maximal-height) #:arguments (quote (h)))
    => cons <> cur-props <= ((quote cell-set-maximal-height) (quote (#:argument h)) (quote ("Maximal cell height")))
    => cur-props => (((quote cell-set-maximal-height) (quote (#:argument h)) (quote ("Maximal cell height"))) ((quote cell-set-maximal-height) #:arguments (quote (h))) ((quote cell-set-maximal-height) #:check-mark (list "o" cell-test-maximal-height?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set maximal cell height.") (tm-define-overloaded (cell-set-maximal-height h) (cell-set-format-list (quote ("cell-height" "cell-vmode")) (quasiquote ((unquote h) "min")))))
   => ((quote cell-set-maximal-height) #:synopsis (quote ("Set maximal cell height.")))
 => cons <> cur-props
   => cur-props => (((quote cell-set-maximal-height) #:synopsis (quote ("Set maximal cell height."))) ((quote cell-set-maximal-height) (quote (#:argument h)) (quote ("Maximal cell height"))) ((quote cell-set-maximal-height) #:arguments (quote (h))) ((quote cell-set-maximal-height) #:check-mark (list "o" cell-test-maximal-height?)))

(property-set! var prop what conds*)
  <= (cell-set-maximal-height #:synopsis ("Set maximal cell height.") ())

(property-set! var prop what conds*)
  <= (cell-set-maximal-height (#:argument h) ("Maximal cell height") ())

(property-set! var prop what conds*)
  <= (cell-set-maximal-height #:arguments (h) ())

(property-set! var prop what conds*)
  <= (cell-set-maximal-height #:check-mark ("o" #<procedure cell-test-maximal-height? args>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" cell-test-maximal-height?) (tm-define-overloaded (cell-ia-maximal-height) (interactive cell-set-maximal-height)))
    => ((quote cell-ia-maximal-height) #:check-mark (list "o" cell-test-maximal-height?))
 => cons <> cur-props
    => cur-props => (((quote cell-ia-maximal-height) #:check-mark (list "o" cell-test-maximal-height?)))

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (cell-ia-maximal-height) (interactive cell-set-maximal-height)))
    => ((quote cell-ia-maximal-height) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote cell-ia-maximal-height) #:interactive (list #t)) ((quote cell-ia-maximal-height) #:check-mark (list "o" cell-test-maximal-height?)))

(property-set! var prop what conds*)
  <= (cell-ia-maximal-height #:interactive (#t) ())

(property-set! var prop what conds*)
  <= (cell-ia-maximal-height #:check-mark ("o" #<procedure cell-test-maximal-height? args>) ())

  (define-option-argument opt decl)
    <= ((padding "Cell padding") (tm-define-overloaded (cell-set-padding padding) (cell-set-format-list (quote ("cell-lsep" "cell-rsep" "cell-bsep" "cell-tsep")) (make-list 4 padding))))
    => cons <> cur-props <= ((quote cell-set-padding) #:arguments (quote (padding)))
    => cons <> cur-props <= ((quote cell-set-padding) (quote (#:argument padding)) (quote ("Cell padding")))
    => cur-props => (((quote cell-set-padding) (quote (#:argument padding)) (quote ("Cell padding"))) ((quote cell-set-padding) #:arguments (quote (padding))))

(property-set! var prop what conds*)
  <= (cell-set-padding (#:argument padding) ("Cell padding") ())

(property-set! var prop what conds*)
  <= (cell-set-padding #:arguments (padding) ())

  (define-option-argument opt decl)
    <= ((padding "Horizontal cell padding") (tm-define-overloaded (cell-set-hpadding padding) (cell-set-format-list (quote ("cell-lsep" "cell-rsep")) (make-list 2 padding))))
    => cons <> cur-props <= ((quote cell-set-hpadding) #:arguments (quote (padding)))
    => cons <> cur-props <= ((quote cell-set-hpadding) (quote (#:argument padding)) (quote ("Horizontal cell padding")))
    => cur-props => (((quote cell-set-hpadding) (quote (#:argument padding)) (quote ("Horizontal cell padding"))) ((quote cell-set-hpadding) #:arguments (quote (padding))))

(property-set! var prop what conds*)
  <= (cell-set-hpadding (#:argument padding) ("Horizontal cell padding") ())

(property-set! var prop what conds*)
  <= (cell-set-hpadding #:arguments (padding) ())

  (define-option-argument opt decl)
    <= ((padding "Vertical cell padding") (tm-define-overloaded (cell-set-vpadding padding) (cell-set-format-list (quote ("cell-bsep" "cell-tsep")) (make-list 2 padding))))
    => cons <> cur-props <= ((quote cell-set-vpadding) #:arguments (quote (padding)))
    => cons <> cur-props <= ((quote cell-set-vpadding) (quote (#:argument padding)) (quote ("Vertical cell padding")))
    => cur-props => (((quote cell-set-vpadding) (quote (#:argument padding)) (quote ("Vertical cell padding"))) ((quote cell-set-vpadding) #:arguments (quote (padding))))

(property-set! var prop what conds*)
  <= (cell-set-vpadding (#:argument padding) ("Vertical cell padding") ())

(property-set! var prop what conds*)
  <= (cell-set-vpadding #:arguments (padding) ())

  (define-option-argument opt decl)
    <= ((cs "Column span") (tm-define-overloaded (cell-set-span rs cs) (cell-set-format-list (quote ("cell-row-span" "cell-col-span")) (list rs cs))))
    => cons <> cur-props <= ((quote cell-set-span) #:arguments (quote (rs cs)))
    => cons <> cur-props <= ((quote cell-set-span) (quote (#:argument cs)) (quote ("Column span")))
    => cur-props => (((quote cell-set-span) (quote (#:argument cs)) (quote ("Column span"))) ((quote cell-set-span) #:arguments (quote (rs cs))))

  (define-option-argument opt decl)
    <= ((rs "Row span") (tm-define-overloaded (cell-set-span rs cs) (cell-set-format-list (quote ("cell-row-span" "cell-col-span")) (list rs cs))))
    => cons <> cur-props <= ((quote cell-set-span) #:arguments (quote (rs cs)))
    => cons <> cur-props <= ((quote cell-set-span) (quote (#:argument rs)) (quote ("Row span")))
    => cur-props => (((quote cell-set-span) (quote (#:argument rs)) (quote ("Row span"))) ((quote cell-set-span) #:arguments (quote (rs cs))) ((quote cell-set-span) (quote (#:argument cs)) (quote ("Column span"))) ((quote cell-set-span) #:arguments (quote (rs cs))))

(property-set! var prop what conds*)
  <= (cell-set-span (#:argument rs) ("Row span") ())

(property-set! var prop what conds*)
  <= (cell-set-span #:arguments (rs cs) ())

(property-set! var prop what conds*)
  <= (cell-set-span (#:argument cs) ("Column span") ())

(property-set! var prop what conds*)
  <= (cell-set-span #:arguments (rs cs) ())

  (define-option-argument opt decl)
    <= ((rs "Row span") (tm-define-overloaded (cell-set-row-span rs) (cell-set-format "cell-row-span" rs)))
    => cons <> cur-props <= ((quote cell-set-row-span) #:arguments (quote (rs)))
    => cons <> cur-props <= ((quote cell-set-row-span) (quote (#:argument rs)) (quote ("Row span")))
    => cur-props => (((quote cell-set-row-span) (quote (#:argument rs)) (quote ("Row span"))) ((quote cell-set-row-span) #:arguments (quote (rs))))

(property-set! var prop what conds*)
  <= (cell-set-row-span (#:argument rs) ("Row span") ())

(property-set! var prop what conds*)
  <= (cell-set-row-span #:arguments (rs) ())

  (define-option-argument opt decl)
    <= ((cs "Column span") (tm-define-overloaded (cell-set-column-span cs) (cell-set-format "cell-col-span" cs)))
    => cons <> cur-props <= ((quote cell-set-column-span) #:arguments (quote (cs)))
    => cons <> cur-props <= ((quote cell-set-column-span) (quote (#:argument cs)) (quote ("Column span")))
    => cur-props => (((quote cell-set-column-span) (quote (#:argument cs)) (quote ("Column span"))) ((quote cell-set-column-span) #:arguments (quote (cs))))

(property-set! var prop what conds*)
  <= (cell-set-column-span (#:argument cs) ("Column span") ())

(property-set! var prop what conds*)
  <= (cell-set-column-span #:arguments (cs) ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Sets the upper-left cell of a selection to span all of it") (tm-define-overloaded (cell-set-span-selection) (when (selection-active-table?) (with (srow erow scol ecol) (table-which-cells) (table-go-to srow scol) (selection-cancel) (cell-set-row-span (number->string (- (+ erow 1) srow))) (cell-set-column-span (number->string (- (+ ecol 1) scol)))))))
   => ((quote cell-set-span-selection) #:synopsis (quote ("Sets the upper-left cell of a selection to span all of it")))
 => cons <> cur-props
   => cur-props => (((quote cell-set-span-selection) #:synopsis (quote ("Sets the upper-left cell of a selection to span all of it"))))

(property-set! var prop what conds*)
  <= (cell-set-span-selection #:synopsis ("Sets the upper-left cell of a selection to span all of it") ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" cell-test-halign?) (tm-define-overloaded (cell-set-halign s) (cell-set-format* "cell-halign" s)))
    => ((quote cell-set-halign) #:check-mark (list "o" cell-test-halign?))
 => cons <> cur-props
    => cur-props => (((quote cell-set-halign) #:check-mark (list "o" cell-test-halign?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set horizontal cell alignment.") (tm-define-overloaded (cell-set-halign s) (cell-set-format* "cell-halign" s)))
   => ((quote cell-set-halign) #:synopsis (quote ("Set horizontal cell alignment.")))
 => cons <> cur-props
   => cur-props => (((quote cell-set-halign) #:synopsis (quote ("Set horizontal cell alignment."))) ((quote cell-set-halign) #:check-mark (list "o" cell-test-halign?)))

(property-set! var prop what conds*)
  <= (cell-set-halign #:synopsis ("Set horizontal cell alignment.") ())

(property-set! var prop what conds*)
  <= (cell-set-halign #:check-mark ("o" #<procedure cell-test-halign? (s)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" cell-test-valign?) (tm-define-overloaded (cell-set-valign s) (cell-set-format* "cell-valign" s)))
    => ((quote cell-set-valign) #:check-mark (list "o" cell-test-valign?))
 => cons <> cur-props
    => cur-props => (((quote cell-set-valign) #:check-mark (list "o" cell-test-valign?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set vertical cell alignment.") (tm-define-overloaded (cell-set-valign s) (cell-set-format* "cell-valign" s)))
   => ((quote cell-set-valign) #:synopsis (quote ("Set vertical cell alignment.")))
 => cons <> cur-props
   => cur-props => (((quote cell-set-valign) #:synopsis (quote ("Set vertical cell alignment."))) ((quote cell-set-valign) #:check-mark (list "o" cell-test-valign?)))

(property-set! var prop what conds*)
  <= (cell-set-valign #:synopsis ("Set vertical cell alignment.") ())

(property-set! var prop what conds*)
  <= (cell-set-valign #:check-mark ("o" #<procedure cell-test-valign? (s)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" cell-test-background?) (tm-define-overloaded (cell-set-background s) (cell-set-format* "cell-background" s)))
    => ((quote cell-set-background) #:check-mark (list "o" cell-test-background?))
 => cons <> cur-props
    => cur-props => (((quote cell-set-background) #:check-mark (list "o" cell-test-background?)))

  (define-option-argument opt decl)
    <= ((s "Cell color") (tm-define-overloaded (cell-set-background s) (cell-set-format* "cell-background" s)))
    => cons <> cur-props <= ((quote cell-set-background) #:arguments (quote (s)))
    => cons <> cur-props <= ((quote cell-set-background) (quote (#:argument s)) (quote ("Cell color")))
    => cur-props => (((quote cell-set-background) (quote (#:argument s)) (quote ("Cell color"))) ((quote cell-set-background) #:arguments (quote (s))) ((quote cell-set-background) #:check-mark (list "o" cell-test-background?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set background color of cell.") (tm-define-overloaded (cell-set-background s) (cell-set-format* "cell-background" s)))
   => ((quote cell-set-background) #:synopsis (quote ("Set background color of cell.")))
 => cons <> cur-props
   => cur-props => (((quote cell-set-background) #:synopsis (quote ("Set background color of cell."))) ((quote cell-set-background) (quote (#:argument s)) (quote ("Cell color"))) ((quote cell-set-background) #:arguments (quote (s))) ((quote cell-set-background) #:check-mark (list "o" cell-test-background?)))

(property-set! var prop what conds*)
  <= (cell-set-background #:synopsis ("Set background color of cell.") ())

(property-set! var prop what conds*)
  <= (cell-set-background (#:argument s) ("Cell color") ())

(property-set! var prop what conds*)
  <= (cell-set-background #:arguments (s) ())

(property-set! var prop what conds*)
  <= (cell-set-background #:check-mark ("o" #<procedure cell-test-background? (s)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" cell-test-vcorrect?) (tm-define-overloaded (cell-set-vcorrect s) (cell-set-format* "cell-vcorrect" s)))
    => ((quote cell-set-vcorrect) #:check-mark (list "o" cell-test-vcorrect?))
 => cons <> cur-props
    => cur-props => (((quote cell-set-vcorrect) #:check-mark (list "o" cell-test-vcorrect?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set vertical correction mode for cell.") (tm-define-overloaded (cell-set-vcorrect s) (cell-set-format* "cell-vcorrect" s)))
   => ((quote cell-set-vcorrect) #:synopsis (quote ("Set vertical correction mode for cell.")))
 => cons <> cur-props
   => cur-props => (((quote cell-set-vcorrect) #:synopsis (quote ("Set vertical correction mode for cell."))) ((quote cell-set-vcorrect) #:check-mark (list "o" cell-test-vcorrect?)))

(property-set! var prop what conds*)
  <= (cell-set-vcorrect #:synopsis ("Set vertical correction mode for cell.") ())

(property-set! var prop what conds*)
  <= (cell-set-vcorrect #:check-mark ("o" #<procedure cell-test-vcorrect? (s)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" cell-test-hyphen?) (tm-define-overloaded (cell-set-hyphen s) (cell-set-format* "cell-hyphen" s)))
    => ((quote cell-set-hyphen) #:check-mark (list "o" cell-test-hyphen?))
 => cons <> cur-props
    => cur-props => (((quote cell-set-hyphen) #:check-mark (list "o" cell-test-hyphen?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set cell wrapping mode.") (tm-define-overloaded (cell-set-hyphen s) (cell-set-format* "cell-hyphen" s)))
   => ((quote cell-set-hyphen) #:synopsis (quote ("Set cell wrapping mode.")))
 => cons <> cur-props
   => cur-props => (((quote cell-set-hyphen) #:synopsis (quote ("Set cell wrapping mode."))) ((quote cell-set-hyphen) #:check-mark (list "o" cell-test-hyphen?)))

(property-set! var prop what conds*)
  <= (cell-set-hyphen #:synopsis ("Set cell wrapping mode.") ())

(property-set! var prop what conds*)
  <= (cell-set-hyphen #:check-mark ("o" #<procedure cell-test-hyphen? (s)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" cell-test-wrap?) (tm-define-overloaded (cell-toggle-wrap) (if (cell-test-wrap?) (cell-set-format* "cell-hyphen" "n") (cell-set-format* "cell-hyphen" "t"))))
    => ((quote cell-toggle-wrap) #:check-mark (list "o" cell-test-wrap?))
 => cons <> cur-props
    => cur-props => (((quote cell-toggle-wrap) #:check-mark (list "o" cell-test-wrap?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle cell wrapping mode.") (tm-define-overloaded (cell-toggle-wrap) (if (cell-test-wrap?) (cell-set-format* "cell-hyphen" "n") (cell-set-format* "cell-hyphen" "t"))))
   => ((quote cell-toggle-wrap) #:synopsis (quote ("Toggle cell wrapping mode.")))
 => cons <> cur-props
   => cur-props => (((quote cell-toggle-wrap) #:synopsis (quote ("Toggle cell wrapping mode."))) ((quote cell-toggle-wrap) #:check-mark (list "o" cell-test-wrap?)))

(property-set! var prop what conds*)
  <= (cell-toggle-wrap #:synopsis ("Toggle cell wrapping mode.") ())

(property-set! var prop what conds*)
  <= (cell-toggle-wrap #:check-mark ("o" #<procedure cell-test-wrap? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" cell-test-block?) (tm-define-overloaded (cell-set-block s) (cell-set-format* "cell-block" s)))
    => ((quote cell-set-block) #:check-mark (list "o" cell-test-block?))
 => cons <> cur-props
    => cur-props => (((quote cell-set-block) #:check-mark (list "o" cell-test-block?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Does the cell contain block content?") (tm-define-overloaded (cell-set-block s) (cell-set-format* "cell-block" s)))
   => ((quote cell-set-block) #:synopsis (quote ("Does the cell contain block content?")))
 => cons <> cur-props
   => cur-props => (((quote cell-set-block) #:synopsis (quote ("Does the cell contain block content?"))) ((quote cell-set-block) #:check-mark (list "o" cell-test-block?)))

(property-set! var prop what conds*)
  <= (cell-set-block #:synopsis ("Does the cell contain block content?") ())

(property-set! var prop what conds*)
  <= (cell-set-block #:check-mark ("o" #<procedure cell-test-block? (s)>) ())

  (define-option-argument opt decl)
    <= ((r "Inner right border width") (tm-define-overloaded (cell-set-borders T B L R t b l r) (keep-table-selection (when (nnull? (table-get-extents)) (with (rows cols) (table-get-extents) (with (r1 r2 c1 c2) (table-which-cells) (let* ((vars (list "cell-tborder" "cell-bborder" "cell-lborder" "cell-rborder")) (vals (list t b l r)) (and* (lambda (a b) (and b a))) (vars* (list-filter (map and* vars vals) identity)) (vals* (list-filter vals identity))) (cell-set-format-list vars* vals*)) (when T (when (!= T t) (table-select-cells r1 r1 c1 c2) (cell-set-format "cell-tborder" T)) (when (> r1 1) (table-select-cells (- r1 1) (- r1 1) c1 c2) (cell-set-format "cell-bborder" T))) (when B (when (!= B b) (table-select-cells r2 r2 c1 c2) (cell-set-format "cell-bborder" B)) (when (< r2 rows) (table-select-cells (+ r2 1) (+ r2 1) c1 c2) (cell-set-format "cell-tborder" B))) (when L (when (!= L l) (table-select-cells r1 r2 c1 c1) (cell-set-format "cell-lborder" L)) (when (> c1 1) (table-select-cells r1 r2 (- c1 1) (- c1 1)) (cell-set-format "cell-rborder" L))) (when R (when (!= R r) (table-select-cells r1 r2 c2 c2) (cell-set-format "cell-rborder" R)) (when (< c2 cols) (table-select-cells r1 r2 (+ c2 1) (+ c2 1)) (cell-set-format "cell-lborder" R)))))))))
    => cons <> cur-props <= ((quote cell-set-borders) #:arguments (quote (T B L R t b l r)))
    => cons <> cur-props <= ((quote cell-set-borders) (quote (#:argument r)) (quote ("Inner right border width")))
    => cur-props => (((quote cell-set-borders) (quote (#:argument r)) (quote ("Inner right border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))))

  (define-option-argument opt decl)
    <= ((l "Inner left border width") (tm-define-overloaded (cell-set-borders T B L R t b l r) (keep-table-selection (when (nnull? (table-get-extents)) (with (rows cols) (table-get-extents) (with (r1 r2 c1 c2) (table-which-cells) (let* ((vars (list "cell-tborder" "cell-bborder" "cell-lborder" "cell-rborder")) (vals (list t b l r)) (and* (lambda (a b) (and b a))) (vars* (list-filter (map and* vars vals) identity)) (vals* (list-filter vals identity))) (cell-set-format-list vars* vals*)) (when T (when (!= T t) (table-select-cells r1 r1 c1 c2) (cell-set-format "cell-tborder" T)) (when (> r1 1) (table-select-cells (- r1 1) (- r1 1) c1 c2) (cell-set-format "cell-bborder" T))) (when B (when (!= B b) (table-select-cells r2 r2 c1 c2) (cell-set-format "cell-bborder" B)) (when (< r2 rows) (table-select-cells (+ r2 1) (+ r2 1) c1 c2) (cell-set-format "cell-tborder" B))) (when L (when (!= L l) (table-select-cells r1 r2 c1 c1) (cell-set-format "cell-lborder" L)) (when (> c1 1) (table-select-cells r1 r2 (- c1 1) (- c1 1)) (cell-set-format "cell-rborder" L))) (when R (when (!= R r) (table-select-cells r1 r2 c2 c2) (cell-set-format "cell-rborder" R)) (when (< c2 cols) (table-select-cells r1 r2 (+ c2 1) (+ c2 1)) (cell-set-format "cell-lborder" R)))))))))
    => cons <> cur-props <= ((quote cell-set-borders) #:arguments (quote (T B L R t b l r)))
    => cons <> cur-props <= ((quote cell-set-borders) (quote (#:argument l)) (quote ("Inner left border width")))
    => cur-props => (((quote cell-set-borders) (quote (#:argument l)) (quote ("Inner left border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))) ((quote cell-set-borders) (quote (#:argument r)) (quote ("Inner right border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))))

  (define-option-argument opt decl)
    <= ((b "Inner bottom border width") (tm-define-overloaded (cell-set-borders T B L R t b l r) (keep-table-selection (when (nnull? (table-get-extents)) (with (rows cols) (table-get-extents) (with (r1 r2 c1 c2) (table-which-cells) (let* ((vars (list "cell-tborder" "cell-bborder" "cell-lborder" "cell-rborder")) (vals (list t b l r)) (and* (lambda (a b) (and b a))) (vars* (list-filter (map and* vars vals) identity)) (vals* (list-filter vals identity))) (cell-set-format-list vars* vals*)) (when T (when (!= T t) (table-select-cells r1 r1 c1 c2) (cell-set-format "cell-tborder" T)) (when (> r1 1) (table-select-cells (- r1 1) (- r1 1) c1 c2) (cell-set-format "cell-bborder" T))) (when B (when (!= B b) (table-select-cells r2 r2 c1 c2) (cell-set-format "cell-bborder" B)) (when (< r2 rows) (table-select-cells (+ r2 1) (+ r2 1) c1 c2) (cell-set-format "cell-tborder" B))) (when L (when (!= L l) (table-select-cells r1 r2 c1 c1) (cell-set-format "cell-lborder" L)) (when (> c1 1) (table-select-cells r1 r2 (- c1 1) (- c1 1)) (cell-set-format "cell-rborder" L))) (when R (when (!= R r) (table-select-cells r1 r2 c2 c2) (cell-set-format "cell-rborder" R)) (when (< c2 cols) (table-select-cells r1 r2 (+ c2 1) (+ c2 1)) (cell-set-format "cell-lborder" R)))))))))
    => cons <> cur-props <= ((quote cell-set-borders) #:arguments (quote (T B L R t b l r)))
    => cons <> cur-props <= ((quote cell-set-borders) (quote (#:argument b)) (quote ("Inner bottom border width")))
    => cur-props => (((quote cell-set-borders) (quote (#:argument b)) (quote ("Inner bottom border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))) ((quote cell-set-borders) (quote (#:argument l)) (quote ("Inner left border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))) ((quote cell-set-borders) (quote (#:argument r)) (quote ("Inner right border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))))

  (define-option-argument opt decl)
    <= ((t "Inner top border width") (tm-define-overloaded (cell-set-borders T B L R t b l r) (keep-table-selection (when (nnull? (table-get-extents)) (with (rows cols) (table-get-extents) (with (r1 r2 c1 c2) (table-which-cells) (let* ((vars (list "cell-tborder" "cell-bborder" "cell-lborder" "cell-rborder")) (vals (list t b l r)) (and* (lambda (a b) (and b a))) (vars* (list-filter (map and* vars vals) identity)) (vals* (list-filter vals identity))) (cell-set-format-list vars* vals*)) (when T (when (!= T t) (table-select-cells r1 r1 c1 c2) (cell-set-format "cell-tborder" T)) (when (> r1 1) (table-select-cells (- r1 1) (- r1 1) c1 c2) (cell-set-format "cell-bborder" T))) (when B (when (!= B b) (table-select-cells r2 r2 c1 c2) (cell-set-format "cell-bborder" B)) (when (< r2 rows) (table-select-cells (+ r2 1) (+ r2 1) c1 c2) (cell-set-format "cell-tborder" B))) (when L (when (!= L l) (table-select-cells r1 r2 c1 c1) (cell-set-format "cell-lborder" L)) (when (> c1 1) (table-select-cells r1 r2 (- c1 1) (- c1 1)) (cell-set-format "cell-rborder" L))) (when R (when (!= R r) (table-select-cells r1 r2 c2 c2) (cell-set-format "cell-rborder" R)) (when (< c2 cols) (table-select-cells r1 r2 (+ c2 1) (+ c2 1)) (cell-set-format "cell-lborder" R)))))))))
    => cons <> cur-props <= ((quote cell-set-borders) #:arguments (quote (T B L R t b l r)))
    => cons <> cur-props <= ((quote cell-set-borders) (quote (#:argument t)) (quote ("Inner top border width")))
    => cur-props => (((quote cell-set-borders) (quote (#:argument t)) (quote ("Inner top border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))) ((quote cell-set-borders) (quote (#:argument b)) (quote ("Inner bottom border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))) ((quote cell-set-borders) (quote (#:argument l)) (quote ("Inner left border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))) ((quote cell-set-borders) (quote (#:argument r)) (quote ("Inner right border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))))

  (define-option-argument opt decl)
    <= ((R "Outer right border width") (tm-define-overloaded (cell-set-borders T B L R t b l r) (keep-table-selection (when (nnull? (table-get-extents)) (with (rows cols) (table-get-extents) (with (r1 r2 c1 c2) (table-which-cells) (let* ((vars (list "cell-tborder" "cell-bborder" "cell-lborder" "cell-rborder")) (vals (list t b l r)) (and* (lambda (a b) (and b a))) (vars* (list-filter (map and* vars vals) identity)) (vals* (list-filter vals identity))) (cell-set-format-list vars* vals*)) (when T (when (!= T t) (table-select-cells r1 r1 c1 c2) (cell-set-format "cell-tborder" T)) (when (> r1 1) (table-select-cells (- r1 1) (- r1 1) c1 c2) (cell-set-format "cell-bborder" T))) (when B (when (!= B b) (table-select-cells r2 r2 c1 c2) (cell-set-format "cell-bborder" B)) (when (< r2 rows) (table-select-cells (+ r2 1) (+ r2 1) c1 c2) (cell-set-format "cell-tborder" B))) (when L (when (!= L l) (table-select-cells r1 r2 c1 c1) (cell-set-format "cell-lborder" L)) (when (> c1 1) (table-select-cells r1 r2 (- c1 1) (- c1 1)) (cell-set-format "cell-rborder" L))) (when R (when (!= R r) (table-select-cells r1 r2 c2 c2) (cell-set-format "cell-rborder" R)) (when (< c2 cols) (table-select-cells r1 r2 (+ c2 1) (+ c2 1)) (cell-set-format "cell-lborder" R)))))))))
    => cons <> cur-props <= ((quote cell-set-borders) #:arguments (quote (T B L R t b l r)))
    => cons <> cur-props <= ((quote cell-set-borders) (quote (#:argument R)) (quote ("Outer right border width")))
    => cur-props => (((quote cell-set-borders) (quote (#:argument R)) (quote ("Outer right border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))) ((quote cell-set-borders) (quote (#:argument t)) (quote ("Inner top border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))) ((quote cell-set-borders) (quote (#:argument b)) (quote ("Inner bottom border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))) ((quote cell-set-borders) (quote (#:argument l)) (quote ("Inner left border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))) ((quote cell-set-borders) (quote (#:argument r)) (quote ("Inner right border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))))

  (define-option-argument opt decl)
    <= ((L "Outer left border width") (tm-define-overloaded (cell-set-borders T B L R t b l r) (keep-table-selection (when (nnull? (table-get-extents)) (with (rows cols) (table-get-extents) (with (r1 r2 c1 c2) (table-which-cells) (let* ((vars (list "cell-tborder" "cell-bborder" "cell-lborder" "cell-rborder")) (vals (list t b l r)) (and* (lambda (a b) (and b a))) (vars* (list-filter (map and* vars vals) identity)) (vals* (list-filter vals identity))) (cell-set-format-list vars* vals*)) (when T (when (!= T t) (table-select-cells r1 r1 c1 c2) (cell-set-format "cell-tborder" T)) (when (> r1 1) (table-select-cells (- r1 1) (- r1 1) c1 c2) (cell-set-format "cell-bborder" T))) (when B (when (!= B b) (table-select-cells r2 r2 c1 c2) (cell-set-format "cell-bborder" B)) (when (< r2 rows) (table-select-cells (+ r2 1) (+ r2 1) c1 c2) (cell-set-format "cell-tborder" B))) (when L (when (!= L l) (table-select-cells r1 r2 c1 c1) (cell-set-format "cell-lborder" L)) (when (> c1 1) (table-select-cells r1 r2 (- c1 1) (- c1 1)) (cell-set-format "cell-rborder" L))) (when R (when (!= R r) (table-select-cells r1 r2 c2 c2) (cell-set-format "cell-rborder" R)) (when (< c2 cols) (table-select-cells r1 r2 (+ c2 1) (+ c2 1)) (cell-set-format "cell-lborder" R)))))))))
    => cons <> cur-props <= ((quote cell-set-borders) #:arguments (quote (T B L R t b l r)))
    => cons <> cur-props <= ((quote cell-set-borders) (quote (#:argument L)) (quote ("Outer left border width")))
    => cur-props => (((quote cell-set-borders) (quote (#:argument L)) (quote ("Outer left border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))) ((quote cell-set-borders) (quote (#:argument R)) (quote ("Outer right border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))) ((quote cell-set-borders) (quote (#:argument t)) (quote ("Inner top border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))) ((quote cell-set-borders) (quote (#:argument b)) (quote ("Inner bottom border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))) ((quote cell-set-borders) (quote (#:argument l)) (quote ("Inner left border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))) ((quote cell-set-borders) (quote (#:argument r)) (quote ("Inner right border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))))

  (define-option-argument opt decl)
    <= ((B "Outer bottom border width") (tm-define-overloaded (cell-set-borders T B L R t b l r) (keep-table-selection (when (nnull? (table-get-extents)) (with (rows cols) (table-get-extents) (with (r1 r2 c1 c2) (table-which-cells) (let* ((vars (list "cell-tborder" "cell-bborder" "cell-lborder" "cell-rborder")) (vals (list t b l r)) (and* (lambda (a b) (and b a))) (vars* (list-filter (map and* vars vals) identity)) (vals* (list-filter vals identity))) (cell-set-format-list vars* vals*)) (when T (when (!= T t) (table-select-cells r1 r1 c1 c2) (cell-set-format "cell-tborder" T)) (when (> r1 1) (table-select-cells (- r1 1) (- r1 1) c1 c2) (cell-set-format "cell-bborder" T))) (when B (when (!= B b) (table-select-cells r2 r2 c1 c2) (cell-set-format "cell-bborder" B)) (when (< r2 rows) (table-select-cells (+ r2 1) (+ r2 1) c1 c2) (cell-set-format "cell-tborder" B))) (when L (when (!= L l) (table-select-cells r1 r2 c1 c1) (cell-set-format "cell-lborder" L)) (when (> c1 1) (table-select-cells r1 r2 (- c1 1) (- c1 1)) (cell-set-format "cell-rborder" L))) (when R (when (!= R r) (table-select-cells r1 r2 c2 c2) (cell-set-format "cell-rborder" R)) (when (< c2 cols) (table-select-cells r1 r2 (+ c2 1) (+ c2 1)) (cell-set-format "cell-lborder" R)))))))))
    => cons <> cur-props <= ((quote cell-set-borders) #:arguments (quote (T B L R t b l r)))
    => cons <> cur-props <= ((quote cell-set-borders) (quote (#:argument B)) (quote ("Outer bottom border width")))
    => cur-props => (((quote cell-set-borders) (quote (#:argument B)) (quote ("Outer bottom border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))) ((quote cell-set-borders) (quote (#:argument L)) (quote ("Outer left border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))) ((quote cell-set-borders) (quote (#:argument R)) (quote ("Outer right border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))) ((quote cell-set-borders) (quote (#:argument t)) (quote ("Inner top border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))) ((quote cell-set-borders) (quote (#:argument b)) (quote ("Inner bottom border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))) ((quote cell-set-borders) (quote (#:argument l)) (quote ("Inner left border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))) ((quote cell-set-borders) (quote (#:argument r)) (quote ("Inner right border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))))

  (define-option-argument opt decl)
    <= ((T "Outer top border width") (tm-define-overloaded (cell-set-borders T B L R t b l r) (keep-table-selection (when (nnull? (table-get-extents)) (with (rows cols) (table-get-extents) (with (r1 r2 c1 c2) (table-which-cells) (let* ((vars (list "cell-tborder" "cell-bborder" "cell-lborder" "cell-rborder")) (vals (list t b l r)) (and* (lambda (a b) (and b a))) (vars* (list-filter (map and* vars vals) identity)) (vals* (list-filter vals identity))) (cell-set-format-list vars* vals*)) (when T (when (!= T t) (table-select-cells r1 r1 c1 c2) (cell-set-format "cell-tborder" T)) (when (> r1 1) (table-select-cells (- r1 1) (- r1 1) c1 c2) (cell-set-format "cell-bborder" T))) (when B (when (!= B b) (table-select-cells r2 r2 c1 c2) (cell-set-format "cell-bborder" B)) (when (< r2 rows) (table-select-cells (+ r2 1) (+ r2 1) c1 c2) (cell-set-format "cell-tborder" B))) (when L (when (!= L l) (table-select-cells r1 r2 c1 c1) (cell-set-format "cell-lborder" L)) (when (> c1 1) (table-select-cells r1 r2 (- c1 1) (- c1 1)) (cell-set-format "cell-rborder" L))) (when R (when (!= R r) (table-select-cells r1 r2 c2 c2) (cell-set-format "cell-rborder" R)) (when (< c2 cols) (table-select-cells r1 r2 (+ c2 1) (+ c2 1)) (cell-set-format "cell-lborder" R)))))))))
    => cons <> cur-props <= ((quote cell-set-borders) #:arguments (quote (T B L R t b l r)))
    => cons <> cur-props <= ((quote cell-set-borders) (quote (#:argument T)) (quote ("Outer top border width")))
    => cur-props => (((quote cell-set-borders) (quote (#:argument T)) (quote ("Outer top border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))) ((quote cell-set-borders) (quote (#:argument B)) (quote ("Outer bottom border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))) ((quote cell-set-borders) (quote (#:argument L)) (quote ("Outer left border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))) ((quote cell-set-borders) (quote (#:argument R)) (quote ("Outer right border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))) ((quote cell-set-borders) (quote (#:argument t)) (quote ("Inner top border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))) ((quote cell-set-borders) (quote (#:argument b)) (quote ("Inner bottom border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))) ((quote cell-set-borders) (quote (#:argument l)) (quote ("Inner left border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))) ((quote cell-set-borders) (quote (#:argument r)) (quote ("Inner right border width"))) ((quote cell-set-borders) #:arguments (quote (T B L R t b l r))))

(property-set! var prop what conds*)
  <= (cell-set-borders (#:argument T) ("Outer top border width") ())

(property-set! var prop what conds*)
  <= (cell-set-borders #:arguments (T B L R t b l r) ())

(property-set! var prop what conds*)
  <= (cell-set-borders (#:argument B) ("Outer bottom border width") ())

(property-set! var prop what conds*)
  <= (cell-set-borders #:arguments (T B L R t b l r) ())

(property-set! var prop what conds*)
  <= (cell-set-borders (#:argument L) ("Outer left border width") ())

(property-set! var prop what conds*)
  <= (cell-set-borders #:arguments (T B L R t b l r) ())

(property-set! var prop what conds*)
  <= (cell-set-borders (#:argument R) ("Outer right border width") ())

(property-set! var prop what conds*)
  <= (cell-set-borders #:arguments (T B L R t b l r) ())

(property-set! var prop what conds*)
  <= (cell-set-borders (#:argument t) ("Inner top border width") ())

(property-set! var prop what conds*)
  <= (cell-set-borders #:arguments (T B L R t b l r) ())

(property-set! var prop what conds*)
  <= (cell-set-borders (#:argument b) ("Inner bottom border width") ())

(property-set! var prop what conds*)
  <= (cell-set-borders #:arguments (T B L R t b l r) ())

(property-set! var prop what conds*)
  <= (cell-set-borders (#:argument l) ("Inner left border width") ())

(property-set! var prop what conds*)
  <= (cell-set-borders #:arguments (T B L R t b l r) ())

(property-set! var prop what conds*)
  <= (cell-set-borders (#:argument r) ("Inner right border width") ())

(property-set! var prop what conds*)
  <= (cell-set-borders #:arguments (T B L R t b l r) ())

  (define-option-argument opt decl)
    <= ((b "Border width") (tm-define-overloaded (cell-set-border b) (cell-set-borders b b b b b b b b)))
    => cons <> cur-props <= ((quote cell-set-border) #:arguments (quote (b)))
    => cons <> cur-props <= ((quote cell-set-border) (quote (#:argument b)) (quote ("Border width")))
    => cur-props => (((quote cell-set-border) (quote (#:argument b)) (quote ("Border width"))) ((quote cell-set-border) #:arguments (quote (b))))

(property-set! var prop what conds*)
  <= (cell-set-border (#:argument b) ("Border width") ())

(property-set! var prop what conds*)
  <= (cell-set-border #:arguments (b) ())

  (define-option-argument opt decl)
    <= ((b "Horizontal border width") (tm-define-overloaded (cell-set-hborder b) (cell-set-borders #f #f b b #f #f b b)))
    => cons <> cur-props <= ((quote cell-set-hborder) #:arguments (quote (b)))
    => cons <> cur-props <= ((quote cell-set-hborder) (quote (#:argument b)) (quote ("Horizontal border width")))
    => cur-props => (((quote cell-set-hborder) (quote (#:argument b)) (quote ("Horizontal border width"))) ((quote cell-set-hborder) #:arguments (quote (b))))

(property-set! var prop what conds*)
  <= (cell-set-hborder (#:argument b) ("Horizontal border width") ())

(property-set! var prop what conds*)
  <= (cell-set-hborder #:arguments (b) ())

  (define-option-argument opt decl)
    <= ((b "Vertical border width") (tm-define-overloaded (cell-set-vborder b) (cell-set-borders b b #f #f b b #f #f)))
    => cons <> cur-props <= ((quote cell-set-vborder) #:arguments (quote (b)))
    => cons <> cur-props <= ((quote cell-set-vborder) (quote (#:argument b)) (quote ("Vertical border width")))
    => cur-props => (((quote cell-set-vborder) (quote (#:argument b)) (quote ("Vertical border width"))) ((quote cell-set-vborder) #:arguments (quote (b))))

(property-set! var prop what conds*)
  <= (cell-set-vborder (#:argument b) ("Vertical border width") ())

(property-set! var prop what conds*)
  <= (cell-set-vborder #:arguments (b) ())

  (define-option-argument opt decl)
    <= ((b "Left border width") (tm-define-overloaded (cell-set-lborder b) (cell-set-borders #f #f b #f #f #f b #f)))
    => cons <> cur-props <= ((quote cell-set-lborder) #:arguments (quote (b)))
    => cons <> cur-props <= ((quote cell-set-lborder) (quote (#:argument b)) (quote ("Left border width")))
    => cur-props => (((quote cell-set-lborder) (quote (#:argument b)) (quote ("Left border width"))) ((quote cell-set-lborder) #:arguments (quote (b))))

(property-set! var prop what conds*)
  <= (cell-set-lborder (#:argument b) ("Left border width") ())

(property-set! var prop what conds*)
  <= (cell-set-lborder #:arguments (b) ())

  (define-option-argument opt decl)
    <= ((b "Right border width") (tm-define-overloaded (cell-set-rborder b) (cell-set-borders #f #f #f b #f #f #f b)))
    => cons <> cur-props <= ((quote cell-set-rborder) #:arguments (quote (b)))
    => cons <> cur-props <= ((quote cell-set-rborder) (quote (#:argument b)) (quote ("Right border width")))
    => cur-props => (((quote cell-set-rborder) (quote (#:argument b)) (quote ("Right border width"))) ((quote cell-set-rborder) #:arguments (quote (b))))

(property-set! var prop what conds*)
  <= (cell-set-rborder (#:argument b) ("Right border width") ())

(property-set! var prop what conds*)
  <= (cell-set-rborder #:arguments (b) ())

  (define-option-argument opt decl)
    <= ((b "Bottom border width") (tm-define-overloaded (cell-set-bborder b) (cell-set-borders #f b #f #f #f b #f #f)))
    => cons <> cur-props <= ((quote cell-set-bborder) #:arguments (quote (b)))
    => cons <> cur-props <= ((quote cell-set-bborder) (quote (#:argument b)) (quote ("Bottom border width")))
    => cur-props => (((quote cell-set-bborder) (quote (#:argument b)) (quote ("Bottom border width"))) ((quote cell-set-bborder) #:arguments (quote (b))))

(property-set! var prop what conds*)
  <= (cell-set-bborder (#:argument b) ("Bottom border width") ())

(property-set! var prop what conds*)
  <= (cell-set-bborder #:arguments (b) ())

  (define-option-argument opt decl)
    <= ((b "Top border width") (tm-define-overloaded (cell-set-tborder b) (cell-set-borders b #f #f #f b #f #f #f)))
    => cons <> cur-props <= ((quote cell-set-tborder) #:arguments (quote (b)))
    => cons <> cur-props <= ((quote cell-set-tborder) (quote (#:argument b)) (quote ("Top border width")))
    => cur-props => (((quote cell-set-tborder) (quote (#:argument b)) (quote ("Top border width"))) ((quote cell-set-tborder) #:arguments (quote (b))))

(property-set! var prop what conds*)
  <= (cell-set-tborder (#:argument b) ("Top border width") ())

(property-set! var prop what conds*)
  <= (cell-set-tborder #:arguments (b) ())

  (define-option-require opt decl)
    <= (((tree-in? t (quote (eqnarray eqnarray*)))) (tm-define-overloaded (numbered-numbered? t) (and (== t (tree-innermost (quote (eqnarray eqnarray*)))) (if (table-search-number-equation) #t #f))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (eqnarray eqnarray*)))) (tm-define-overloaded (numbered-numbered? t) (and (== t (tree-innermost (quote (eqnarray eqnarray*)))) (if (table-search-number-equation) #t #f))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (eqnarray eqnarray*)))) (tm-define-overloaded (numbered-toggle t) (when (== t (tree-innermost (quote (eqnarray eqnarray*)))) (if (table-search-number-equation) (table-nonumber-equation) (table-number-equation)))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (eqnarray eqnarray*)))) (tm-define-overloaded (numbered-toggle t) (when (== t (tree-innermost (quote (eqnarray eqnarray*)))) (if (table-search-number-equation) (table-nonumber-equation) (table-number-equation)))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Non-correcting constructor of horizontal concatenations.") (tm-define-overloaded (tmconcat* . l) (cond ((null? l) "") ((null? (cdr l)) (car l)) (else (cons (quote concat) l)))))
   => ((quote tmconcat*) #:synopsis (quote ("Non-correcting constructor of horizontal concatenations.")))
 => cons <> cur-props
   => cur-props => (((quote tmconcat*) #:synopsis (quote ("Non-correcting constructor of horizontal concatenations."))))

(property-set! var prop what conds*)
  <= (tmconcat* #:synopsis ("Non-correcting constructor of horizontal concatenations.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Constructor of horizontal concatenations with corrections.") (tm-define-overloaded (tmconcat . in) (apply tmconcat* (tmconcat-simplify in))))
   => ((quote tmconcat) #:synopsis (quote ("Constructor of horizontal concatenations with corrections.")))
 => cons <> cur-props
   => cur-props => (((quote tmconcat) #:synopsis (quote ("Constructor of horizontal concatenations with corrections."))))

(property-set! var prop what conds*)
  <= (tmconcat #:synopsis ("Constructor of horizontal concatenations with corrections.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Decompose mathematical string @s into list of tokens.") (tm-define-overloaded (tmconcat-tokenize-math s) (tmconcat-math-sub s 0)))
   => ((quote tmconcat-tokenize-math) #:synopsis (quote ("Decompose mathematical string @s into list of tokens.")))
 => cons <> cur-props
   => cur-props => (((quote tmconcat-tokenize-math) #:synopsis (quote ("Decompose mathematical string @s into list of tokens."))))

  ((define-property which)  opt decl)
    <= ((#:type)  ((-> string (list string))) (tm-define-overloaded (tmconcat-tokenize-math s) (tmconcat-math-sub s 0)))
   => ((quote tmconcat-tokenize-math) #:type (quote ((-> string (list string)))))
 => cons <> cur-props
   => cur-props => (((quote tmconcat-tokenize-math) #:type (quote ((-> string (list string))))) ((quote tmconcat-tokenize-math) #:synopsis (quote ("Decompose mathematical string @s into list of tokens."))))

(property-set! var prop what conds*)
  <= (tmconcat-tokenize-math #:type ((-> string (list string))) ())

(property-set! var prop what conds*)
  <= (tmconcat-tokenize-math #:synopsis ("Decompose mathematical string @s into list of tokens.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Rewrite weak left and write tabs in concatenation @l.") (tm-define-overloaded (tmconcat-simplify-tabs l) (with c (cons (quote concat) l) (cdr (simplify-tabs c (list) c)))))
   => ((quote tmconcat-simplify-tabs) #:synopsis (quote ("Rewrite weak left and write tabs in concatenation @l.")))
 => cons <> cur-props
   => cur-props => (((quote tmconcat-simplify-tabs) #:synopsis (quote ("Rewrite weak left and write tabs in concatenation @l."))))

  ((define-property which)  opt decl)
    <= ((#:type)  ((forall T (-> (list T) (list T)))) (tm-define-overloaded (tmconcat-simplify-tabs l) (with c (cons (quote concat) l) (cdr (simplify-tabs c (list) c)))))
   => ((quote tmconcat-simplify-tabs) #:type (quote ((forall T (-> (list T) (list T))))))
 => cons <> cur-props
   => cur-props => (((quote tmconcat-simplify-tabs) #:type (quote ((forall T (-> (list T) (list T)))))) ((quote tmconcat-simplify-tabs) #:synopsis (quote ("Rewrite weak left and write tabs in concatenation @l."))))

(property-set! var prop what conds*)
  <= (tmconcat-simplify-tabs #:type ((forall T (-> (list T) (list T)))) ())

(property-set! var prop what conds*)
  <= (tmconcat-simplify-tabs #:synopsis ("Rewrite weak left and write tabs in concatenation @l.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Structure tabs in concatenation @l.") (tm-define-overloaded (tmconcat-structure-tabs l) (set! l (tmconcat-simplify-tabs l)) (with r (list-scatter l tab? #t) (if (null? (cdr r)) l (tmconcat-tabs-sub (car r) (cdr r) (quote !left))))))
   => ((quote tmconcat-structure-tabs) #:synopsis (quote ("Structure tabs in concatenation @l.")))
 => cons <> cur-props
   => cur-props => (((quote tmconcat-structure-tabs) #:synopsis (quote ("Structure tabs in concatenation @l."))))

  ((define-property which)  opt decl)
    <= ((#:type)  ((forall T (-> (list T) (list T)))) (tm-define-overloaded (tmconcat-structure-tabs l) (set! l (tmconcat-simplify-tabs l)) (with r (list-scatter l tab? #t) (if (null? (cdr r)) l (tmconcat-tabs-sub (car r) (cdr r) (quote !left))))))
   => ((quote tmconcat-structure-tabs) #:type (quote ((forall T (-> (list T) (list T))))))
 => cons <> cur-props
   => cur-props => (((quote tmconcat-structure-tabs) #:type (quote ((forall T (-> (list T) (list T)))))) ((quote tmconcat-structure-tabs) #:synopsis (quote ("Structure tabs in concatenation @l."))))

(property-set! var prop what conds*)
  <= (tmconcat-structure-tabs #:type ((forall T (-> (list T) (list T)))) ())

(property-set! var prop what conds*)
  <= (tmconcat-structure-tabs #:synopsis ("Structure tabs in concatenation @l.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Recursively group matching brackets in concatenation @l.") (tm-define-overloaded (tmconcat-structure-brackets l) (receive (r tail) (tmconcat-brackets-sub l) (if (null? tail) r (append r (tmconcat-structure-brackets tail))))))
   => ((quote tmconcat-structure-brackets) #:synopsis (quote ("Recursively group matching brackets in concatenation @l.")))
 => cons <> cur-props
   => cur-props => (((quote tmconcat-structure-brackets) #:synopsis (quote ("Recursively group matching brackets in concatenation @l."))))

  ((define-property which)  opt decl)
    <= ((#:type)  ((forall T (-> (list T) (list T)))) (tm-define-overloaded (tmconcat-structure-brackets l) (receive (r tail) (tmconcat-brackets-sub l) (if (null? tail) r (append r (tmconcat-structure-brackets tail))))))
   => ((quote tmconcat-structure-brackets) #:type (quote ((forall T (-> (list T) (list T))))))
 => cons <> cur-props
   => cur-props => (((quote tmconcat-structure-brackets) #:type (quote ((forall T (-> (list T) (list T)))))) ((quote tmconcat-structure-brackets) #:synopsis (quote ("Recursively group matching brackets in concatenation @l."))))

(property-set! var prop what conds*)
  <= (tmconcat-structure-brackets #:type ((forall T (-> (list T) (list T)))) ())

(property-set! var prop what conds*)
  <= (tmconcat-structure-brackets #:synopsis ("Recursively group matching brackets in concatenation @l.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Group scripts in @l.") (tm-define-overloaded (tmconcat-structure-scripts l) (tmconcat-structure-scripts-sub (tmconcat-simplify-scripts l))))
   => ((quote tmconcat-structure-scripts) #:synopsis (quote ("Group scripts in @l.")))
 => cons <> cur-props
   => cur-props => (((quote tmconcat-structure-scripts) #:synopsis (quote ("Group scripts in @l."))))

  ((define-property which)  opt decl)
    <= ((#:type)  ((forall T (-> (list T) (list T)))) (tm-define-overloaded (tmconcat-structure-scripts l) (tmconcat-structure-scripts-sub (tmconcat-simplify-scripts l))))
   => ((quote tmconcat-structure-scripts) #:type (quote ((forall T (-> (list T) (list T))))))
 => cons <> cur-props
   => cur-props => (((quote tmconcat-structure-scripts) #:type (quote ((forall T (-> (list T) (list T)))))) ((quote tmconcat-structure-scripts) #:synopsis (quote ("Group scripts in @l."))))

(property-set! var prop what conds*)
  <= (tmconcat-structure-scripts #:type ((forall T (-> (list T) (list T)))) ())

(property-set! var prop what conds*)
  <= (tmconcat-structure-scripts #:synopsis ("Group scripts in @l.") ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" script-keep-input?) (tm-define-overloaded (toggle-keep-input) (toggle! script-keep-input-flag?)))
    => ((quote toggle-keep-input) #:check-mark (list "v" script-keep-input?))
 => cons <> cur-props
    => cur-props => (((quote toggle-keep-input) #:check-mark (list "v" script-keep-input?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle whether we keep the input of evaluations.") (tm-define-overloaded (toggle-keep-input) (toggle! script-keep-input-flag?)))
   => ((quote toggle-keep-input) #:synopsis (quote ("Toggle whether we keep the input of evaluations.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-keep-input) #:synopsis (quote ("Toggle whether we keep the input of evaluations."))) ((quote toggle-keep-input) #:check-mark (list "v" script-keep-input?)))

(property-set! var prop what conds*)
  <= (toggle-keep-input #:synopsis ("Toggle whether we keep the input of evaluations.") ())

(property-set! var prop what conds*)
  <= (toggle-keep-input #:check-mark ("v" #<procedure script-keep-input? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" script-eval-math?) (tm-define-overloaded (toggle-eval-math) (toggle! script-eval-math-flag?)))
    => ((quote toggle-eval-math) #:check-mark (list "v" script-eval-math?))
 => cons <> cur-props
    => cur-props => (((quote toggle-eval-math) #:check-mark (list "v" script-eval-math?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle whether we evaluate the innermost non-selected formulas.") (tm-define-overloaded (toggle-eval-math) (toggle! script-eval-math-flag?)))
   => ((quote toggle-eval-math) #:synopsis (quote ("Toggle whether we evaluate the innermost non-selected formulas.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-eval-math) #:synopsis (quote ("Toggle whether we evaluate the innermost non-selected formulas."))) ((quote toggle-eval-math) #:check-mark (list "v" script-eval-math?)))

(property-set! var prop what conds*)
  <= (toggle-eval-math #:synopsis ("Toggle whether we evaluate the innermost non-selected formulas.") ())

(property-set! var prop what conds*)
  <= (toggle-eval-math #:check-mark ("v" #<procedure script-eval-math? ()>) ())

  (define-option-require opt decl)
    <= (((tree-is? t (quote script-input))) (tm-define-overloaded (search-tag-parameters t) (let* ((ch (tree-ref t 0)) (lan (if (tree-atomic? ch) (tree->string ch) "unknown")) (var (string-append lan "-script-input")) (gen "render-big-script")) (search-parameters (if (style-has? var) var gen)))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote script-input))) (tm-define-overloaded (search-tag-parameters t) (let* ((ch (tree-ref t 0)) (lan (if (tree-atomic? ch) (tree->string ch) "unknown")) (var (string-append lan "-script-input")) (gen "render-big-script")) (search-parameters (if (style-has? var) var gen)))))

  (define-option-require opt decl)
    <= (((and (tree-is? t (quote script-eval)) (xor (not forwards?) (tree-is? t 1 (quote document))))) (tm-define-overloaded (kbd-enter t forwards?) (script-modified-eval noop)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (and (tree-is? t (quote script-eval)) (xor (not forwards?) (tree-is? t 1 (quote document))))) (tm-define-overloaded (kbd-enter t forwards?) (script-modified-eval noop)))

  (define-option-require opt decl)
    <= (((tree-is? t (quote script-input))) (tm-define-overloaded (alternate-toggle t) (let* ((lan (tree->string (tree-ref t 0))) (session (tree->string (tree-ref t 1))) (in (tree->stree (tree-ref t 2))) (out (tree-ref t 3))) (script-eval-at out lan session in #:math-input #:simplify-output) (tree-assign-node! t (quote script-output)) (tree-go-to t 3 #:end))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote script-input))) (tm-define-overloaded (alternate-toggle t) (let* ((lan (tree->string (tree-ref t 0))) (session (tree->string (tree-ref t 1))) (in (tree->stree (tree-ref t 2))) (out (tree-ref t 3))) (script-eval-at out lan session in #:math-input #:simplify-output) (tree-assign-node! t (quote script-output)) (tree-go-to t 3 #:end))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote script-output))) (tm-define-overloaded (alternate-toggle t) (tree-assign-node! t (quote script-input)) (tree-go-to t 2 #:end)))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote script-output))) (tm-define-overloaded (alternate-toggle t) (tree-assign-node! t (quote script-input)) (tree-go-to t 2 #:end)))

  (define-option-require opt decl)
    <= (((or (tree-is? t (quote script-output)) (and (tree-is? t (quote script-input)) (not (tree-is? t #:up (quote inactive)))))) (tm-define-overloaded (kbd-enter t forwards?) (cond ((tree-is? t (quote script-output)) (alternate-toggle t)) ((xor (not forwards?) (tree-is? t 2 (quote document))) (alternate-toggle t)) (else (if (not (tree-is? t 2 (quote document))) (tree-set t 2 (quasiquote (document (unquote (tree-ref t 2)))))) (insert-return)))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (or (tree-is? t (quote script-output)) (and (tree-is? t (quote script-input)) (not (tree-is? t #:up (quote inactive)))))) (tm-define-overloaded (kbd-enter t forwards?) (cond ((tree-is? t (quote script-output)) (alternate-toggle t)) ((xor (not forwards?) (tree-is? t 2 (quote document))) (alternate-toggle t)) (else (if (not (tree-is? t 2 (quote document))) (tree-set t 2 (quasiquote (document (unquote (tree-ref t 2)))))) (insert-return)))))

  (define-option-require opt decl)
    <= (((plot-context? t)) (tm-define-overloaded (alternate-toggle t) (activate-plot t)))
    => (define-option-match opt decl) <= ((lambda (t) (plot-context? t)) (tm-define-overloaded (alternate-toggle t) (activate-plot t)))

  (define-option-require opt decl)
    <= (((tree-is? t (quote plot-output))) (tm-define-overloaded (alternate-toggle t) (tree-remove-node! t 0) (tree-go-to t 0 #:end)))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote plot-output))) (tm-define-overloaded (alternate-toggle t) (tree-remove-node! t 0) (tree-go-to t 0 #:end)))

  (define-option-require opt decl)
    <= (((plot-context? t)) (tm-define-overloaded (kbd-enter t forwards?) (if (= (tree-down-index t) (- (tree-arity t) 1)) (activate-plot t) (tree-go-to t (1+ (tree-down-index t)) #:end))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (plot-context? t)) (tm-define-overloaded (kbd-enter t forwards?) (if (= (tree-down-index t) (- (tree-arity t) 1)) (activate-plot t) (tree-go-to t (1+ (tree-down-index t)) #:end))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote plot-output))) (tm-define-overloaded (kbd-enter t forwards?) (alternate-toggle t)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (tree-is? t (quote plot-output))) (tm-define-overloaded (kbd-enter t forwards?) (alternate-toggle t)))

  (define-option-require opt decl)
    <= (((and (tree-is? t (quote converter-eval)) (xor (not forwards?) (tree-is? t 1 (quote document))))) (tm-define-overloaded (kbd-enter t forwards?) (let* ((format (string-append (tree->string (tree-ref t 0)) "-snippet")) (in (texmacs->code (tree-ref t 1)))) (tree-select t) (clipboard-cut "primary") (insert (convert in format "texmacs-tree")))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (and (tree-is? t (quote converter-eval)) (xor (not forwards?) (tree-is? t 1 (quote document))))) (tm-define-overloaded (kbd-enter t forwards?) (let* ((format (string-append (tree->string (tree-ref t 0)) "-snippet")) (in (texmacs->code (tree-ref t 1)))) (tree-select t) (clipboard-cut "primary") (insert (convert in format "texmacs-tree")))))

  (define-option-require opt decl)
    <= (((tree-is-buffer? t)) (tm-define-overloaded (kbd-control-enter t shift?) (script-eval)))
    => (define-option-match opt decl) <= ((lambda (t shift?) (tree-is-buffer? t)) (tm-define-overloaded (kbd-control-enter t shift?) (script-eval)))

  (define-option-require opt decl)
    <= (((tree-is-buffer? t)) (tm-define-overloaded (kbd-alternate-enter t shift?) (script-approx)))
    => (define-option-match opt decl) <= ((lambda (t shift?) (tree-is-buffer? t)) (tm-define-overloaded (kbd-alternate-enter t shift?) (script-approx)))

  (define-option-require opt decl)
    <= (((tree-is? t (quote converter-input))) (tm-define-overloaded (alternate-toggle t) (let* ((format (string-append (tree->string (tree-ref t 0)) "-snippet")) (in (texmacs->code (tree-ref t 1)))) (tree-set! t 2 (convert in format "texmacs-tree")) (tree-assign-node! t (quote converter-output)) (tree-go-to t 2 #:end))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote converter-input))) (tm-define-overloaded (alternate-toggle t) (let* ((format (string-append (tree->string (tree-ref t 0)) "-snippet")) (in (texmacs->code (tree-ref t 1)))) (tree-set! t 2 (convert in format "texmacs-tree")) (tree-assign-node! t (quote converter-output)) (tree-go-to t 2 #:end))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote converter-output))) (tm-define-overloaded (alternate-toggle t) (tree-assign-node! t (quote converter-input)) (tree-go-to t 1 #:end)))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote converter-output))) (tm-define-overloaded (alternate-toggle t) (tree-assign-node! t (quote converter-input)) (tree-go-to t 1 #:end)))

  (define-option-require opt decl)
    <= (((or (tree-is? t (quote converter-output)) (and (tree-is? t (quote converter-input)) (not (tree-is? t #:up (quote inactive)))))) (tm-define-overloaded (kbd-enter t forwards?) (cond ((tree-is? t (quote converter-output)) (alternate-toggle t)) ((xor (not forwards?) (tree-is? t 1 (quote document))) (alternate-toggle t)) (else (if (not (tree-is? t 1 (quote document))) (tree-set t 1 (quasiquote (document (unquote (tree-ref t 1)))))) (insert-return)))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (or (tree-is? t (quote converter-output)) (and (tree-is? t (quote converter-input)) (not (tree-is? t #:up (quote inactive)))))) (tm-define-overloaded (kbd-enter t forwards?) (cond ((tree-is? t (quote converter-output)) (alternate-toggle t)) ((xor (not forwards?) (tree-is? t 1 (quote document))) (alternate-toggle t)) (else (if (not (tree-is? t 1 (quote document))) (tree-set t 1 (quasiquote (document (unquote (tree-ref t 1)))))) (insert-return)))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Create a unique file or locus identifier") (tm-define-overloaded (create-unique-id) (set! texmacs-serial-id (+ texmacs-serial-id 1)) (string-append "+" (number->base62 texmacs-serial-id))))
   => ((quote create-unique-id) #:synopsis (quote ("Create a unique file or locus identifier")))
 => cons <> cur-props
   => cur-props => (((quote create-unique-id) #:synopsis (quote ("Create a unique file or locus identifier"))))

(property-set! var prop what conds*)
  <= (create-unique-id #:synopsis ("Create a unique file or locus identifier") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Return the unique identifier of the locus @t or #f.") (tm-define-overloaded (locus-id t) (and (tm-func? t (quote locus)) (>= (tm-length t) 2) (tm-func? (tm-ref t 0) (quote id) 1) (tree-atomic? (tm-ref t 0 0)) (tree->string (tm-ref t 0 0)))))
   => ((quote locus-id) #:synopsis (quote ("Return the unique identifier of the locus @t or #f.")))
 => cons <> cur-props
   => cur-props => (((quote locus-id) #:synopsis (quote ("Return the unique identifier of the locus @t or #f."))))

(property-set! var prop what conds*)
  <= (locus-id #:synopsis ("Return the unique identifier of the locus @t or #f.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Replace the contents of all loci with identifier @id by @t.") (tm-define-overloaded (locus-set id t) (for-each (lambda (l) (tree-assign! l t)) (id->trees id))))
   => ((quote locus-set) #:synopsis (quote ("Replace the contents of all loci with identifier @id by @t.")))
 => cons <> cur-props
   => cur-props => (((quote locus-set) #:synopsis (quote ("Replace the contents of all loci with identifier @id by @t."))))

(property-set! var prop what conds*)
  <= (locus-set #:synopsis ("Replace the contents of all loci with identifier @id by @t.") ())

  (define-option-require opt decl)
    <= (((== l "version-both")) (tm-define-overloaded (standard-parameters l) (append (search-parameters "version-old") (search-parameters "version-new"))))
    => (define-option-match opt decl) <= ((lambda (l) (== l "version-both")) (tm-define-overloaded (standard-parameters l) (append (search-parameters "version-old") (search-parameters "version-new"))))

  (define-option-require opt decl)
    <= (((in? p (list "framed-session" "ring-session" "large-formulas"))) (tm-define-overloaded (style-category p) #:session-theme))
    => (define-option-match opt decl) <= ((lambda (p) (in? p (list "framed-session" "ring-session" "large-formulas"))) (tm-define-overloaded (style-category p) #:session-theme))

  (define-option-require opt decl)
    <= (((and (== x #:session-theme) (in? y (map symbol->string (plugin-list))))) (tm-define-overloaded (style-category-precedes? x y) #t))
    => (define-option-match opt decl) <= ((lambda (x y) (and (== x #:session-theme) (in? y (map symbol->string (plugin-list))))) (tm-define-overloaded (style-category-precedes? x y) #t))

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" session-math-input?) (tm-define-overloaded (toggle-session-math-input) (ahash-set! session-math-input (session-key) (not (session-math-input?))) (with-innermost t field-context? (field-update-math t))))
    => ((quote toggle-session-math-input) #:check-mark (list "v" session-math-input?))
 => cons <> cur-props
    => cur-props => (((quote toggle-session-math-input) #:check-mark (list "v" session-math-input?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle mathematical input in sessions.") (tm-define-overloaded (toggle-session-math-input) (ahash-set! session-math-input (session-key) (not (session-math-input?))) (with-innermost t field-context? (field-update-math t))))
   => ((quote toggle-session-math-input) #:synopsis (quote ("Toggle mathematical input in sessions.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-session-math-input) #:synopsis (quote ("Toggle mathematical input in sessions."))) ((quote toggle-session-math-input) #:check-mark (list "v" session-math-input?)))

(property-set! var prop what conds*)
  <= (toggle-session-math-input #:synopsis ("Toggle mathematical input in sessions.") ())

(property-set! var prop what conds*)
  <= (toggle-session-math-input #:check-mark ("v" #<procedure session-math-input? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" session-multiline-input?) (tm-define-overloaded (toggle-session-multiline-input) (ahash-set! session-multiline-input (session-key) (not (session-multiline-input?)))))
    => ((quote toggle-session-multiline-input) #:check-mark (list "v" session-multiline-input?))
 => cons <> cur-props
    => cur-props => (((quote toggle-session-multiline-input) #:check-mark (list "v" session-multiline-input?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle multi-line input in sessions.") (tm-define-overloaded (toggle-session-multiline-input) (ahash-set! session-multiline-input (session-key) (not (session-multiline-input?)))))
   => ((quote toggle-session-multiline-input) #:synopsis (quote ("Toggle multi-line input in sessions.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-session-multiline-input) #:synopsis (quote ("Toggle multi-line input in sessions."))) ((quote toggle-session-multiline-input) #:check-mark (list "v" session-multiline-input?)))

(property-set! var prop what conds*)
  <= (toggle-session-multiline-input #:synopsis ("Toggle multi-line input in sessions.") ())

(property-set! var prop what conds*)
  <= (toggle-session-multiline-input #:check-mark ("v" #<procedure session-multiline-input? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" session-output-timings?) (tm-define-overloaded (toggle-session-output-timings) (ahash-set! session-output-timings (session-key) (not (session-output-timings?)))))
    => ((quote toggle-session-output-timings) #:check-mark (list "v" session-output-timings?))
 => cons <> cur-props
    => cur-props => (((quote toggle-session-output-timings) #:check-mark (list "v" session-output-timings?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle output of evaluation timings.") (tm-define-overloaded (toggle-session-output-timings) (ahash-set! session-output-timings (session-key) (not (session-output-timings?)))))
   => ((quote toggle-session-output-timings) #:synopsis (quote ("Toggle output of evaluation timings.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-session-output-timings) #:synopsis (quote ("Toggle output of evaluation timings."))) ((quote toggle-session-output-timings) #:check-mark (list "v" session-output-timings?)))

(property-set! var prop what conds*)
  <= (toggle-session-output-timings #:synopsis ("Toggle output of evaluation timings.") ())

(property-set! var prop what conds*)
  <= (toggle-session-output-timings #:check-mark ("v" #<procedure session-output-timings? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" session-scheme-trees?) (tm-define-overloaded (toggle-session-scheme-trees) (set! session-scheme-trees (not session-scheme-trees))))
    => ((quote toggle-session-scheme-trees) #:check-mark (list "v" session-scheme-trees?))
 => cons <> cur-props
    => cur-props => (((quote toggle-session-scheme-trees) #:check-mark (list "v" session-scheme-trees?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle pretty tree output in scheme sessions.") (tm-define-overloaded (toggle-session-scheme-trees) (set! session-scheme-trees (not session-scheme-trees))))
   => ((quote toggle-session-scheme-trees) #:synopsis (quote ("Toggle pretty tree output in scheme sessions.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-session-scheme-trees) #:synopsis (quote ("Toggle pretty tree output in scheme sessions."))) ((quote toggle-session-scheme-trees) #:check-mark (list "v" session-scheme-trees?)))

(property-set! var prop what conds*)
  <= (toggle-session-scheme-trees #:synopsis ("Toggle pretty tree output in scheme sessions.") ())

(property-set! var prop what conds*)
  <= (toggle-session-scheme-trees #:check-mark ("v" #<procedure session-scheme-trees? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" session-scheme-math?) (tm-define-overloaded (toggle-session-scheme-math) (set! session-scheme-math (not session-scheme-math))))
    => ((quote toggle-session-scheme-math) #:check-mark (list "v" session-scheme-math?))
 => cons <> cur-props
    => cur-props => (((quote toggle-session-scheme-math) #:check-mark (list "v" session-scheme-math?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle pretty math output in scheme sessions.") (tm-define-overloaded (toggle-session-scheme-math) (set! session-scheme-math (not session-scheme-math))))
   => ((quote toggle-session-scheme-math) #:synopsis (quote ("Toggle pretty math output in scheme sessions.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-session-scheme-math) #:synopsis (quote ("Toggle pretty math output in scheme sessions."))) ((quote toggle-session-scheme-math) #:check-mark (list "v" session-scheme-math?)))

(property-set! var prop what conds*)
  <= (toggle-session-scheme-math #:synopsis ("Toggle pretty math output in scheme sessions.") ())

(property-set! var prop what conds*)
  <= (toggle-session-scheme-math #:check-mark ("v" #<procedure session-scheme-math? ()>) ())

  (define-option-require opt decl)
    <= (((== l "session")) (tm-define-overloaded (standard-parameters l) (field-parameters "session")))
    => (define-option-match opt decl) <= ((lambda (l) (== l "session")) (tm-define-overloaded (standard-parameters l) (field-parameters "session")))

  (define-option-require opt decl)
    <= (((== l "input")) (tm-define-overloaded (standard-parameters l) (field-parameters "input")))
    => (define-option-match opt decl) <= ((lambda (l) (== l "input")) (tm-define-overloaded (standard-parameters l) (field-parameters "input")))

  (define-option-require opt decl)
    <= (((== l "output")) (tm-define-overloaded (standard-parameters l) (field-parameters "output")))
    => (define-option-match opt decl) <= ((lambda (l) (== l "output")) (tm-define-overloaded (standard-parameters l) (field-parameters "output")))

  (define-option-require opt decl)
    <= (((== l "errput")) (tm-define-overloaded (standard-parameters l) (field-parameters "errput")))
    => (define-option-match opt decl) <= ((lambda (l) (== l "errput")) (tm-define-overloaded (standard-parameters l) (field-parameters "errput")))

  (define-option-require opt decl)
    <= (((== l "textput")) (tm-define-overloaded (standard-parameters l) (field-parameters "textput")))
    => (define-option-match opt decl) <= ((lambda (l) (== l "textput")) (tm-define-overloaded (standard-parameters l) (field-parameters "textput")))

  (define-option-require opt decl)
    <= (((field-input-context? t)) (tm-define-overloaded (kbd-enter t shift?) (cond ((xor (session-multiline-input?) shift?) (insert-return)) ((session-supports-input-done?) (let* ((lan (get-env "prog-language")) (ses (get-env "prog-session")) (opts (input-options t)) (st (tree->stree (tree-ref t 1))) (pre (plugin-preprocess lan ses st opts)) (in (plugin-serialize lan pre)) (rew (if (string-ends? in "
") (string-drop-right in 1) in)) (cmd (string-append "(input-done? " (string-quote rew) ")")) (ret (lambda (done?) (kbd-enter-sub t done?)))) (plugin-command lan ses cmd ret (quote ())))) (else (session-evaluate)))))
    => (define-option-match opt decl) <= ((lambda (t shift?) (field-input-context? t)) (tm-define-overloaded (kbd-enter t shift?) (cond ((xor (session-multiline-input?) shift?) (insert-return)) ((session-supports-input-done?) (let* ((lan (get-env "prog-language")) (ses (get-env "prog-session")) (opts (input-options t)) (st (tree->stree (tree-ref t 1))) (pre (plugin-preprocess lan ses st opts)) (in (plugin-serialize lan pre)) (rew (if (string-ends? in "
") (string-drop-right in 1) in)) (cmd (string-append "(input-done? " (string-quote rew) ")")) (ret (lambda (done?) (kbd-enter-sub t done?)))) (plugin-command lan ses cmd ret (quote ())))) (else (session-evaluate)))))

  (define-option-require opt decl)
    <= (((field-context? t)) (tm-define-overloaded (kbd-horizontal t forwards?) (with move (if forwards? go-right go-left) (go-to-remain-inside move field-context? 1))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (field-context? t)) (tm-define-overloaded (kbd-horizontal t forwards?) (with move (if forwards? go-right go-left) (go-to-remain-inside move field-context? 1))))

  (define-option-require opt decl)
    <= (((field-context? t)) (tm-define-overloaded (kbd-extremal t forwards?) (with move (if forwards? go-end-line go-start-line) (go-to-remain-inside move field-context? 1))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (field-context? t)) (tm-define-overloaded (kbd-extremal t forwards?) (with move (if forwards? go-end-line go-start-line) (go-to-remain-inside move field-context? 1))))

  (define-option-require opt decl)
    <= (((field-context? t)) (tm-define-overloaded (kbd-vertical t downwards?) (if downwards? (field-go-down) (field-go-up))))
    => (define-option-match opt decl) <= ((lambda (t downwards?) (field-context? t)) (tm-define-overloaded (kbd-vertical t downwards?) (if downwards? (field-go-down) (field-go-up))))

  (define-option-require opt decl)
    <= (((field-context? t)) (tm-define-overloaded (kbd-incremental t downwards?) (for (n 0 5) (if downwards? (field-go-to-next) (field-go-to-previous)))))
    => (define-option-match opt decl) <= ((lambda (t downwards?) (field-context? t)) (tm-define-overloaded (kbd-incremental t downwards?) (for (n 0 5) (if downwards? (field-go-to-next) (field-go-to-previous)))))

  (define-option-require opt decl)
    <= (((field-input-context? t)) (tm-define-overloaded (kbd-remove t forwards?) (cond ((and (tree-cursor-at? t 1 #:start) (not forwards?)) (noop)) ((and (tree-cursor-at? t 1 #:end) forwards?) (noop)) (else (remove-text forwards?)))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (field-input-context? t)) (tm-define-overloaded (kbd-remove t forwards?) (cond ((and (tree-cursor-at? t 1 #:start) (not forwards?)) (noop)) ((and (tree-cursor-at? t 1 #:end) forwards?) (noop)) (else (remove-text forwards?)))))

  (define-option-require opt decl)
    <= (((and (field-input-context? t) (selection-active-any?))) (tm-define-overloaded (kbd-remove t forwards?) (clipboard-cut "nowhere") (clipboard-clear "nowhere")))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (and (field-input-context? t) (selection-active-any?))) (tm-define-overloaded (kbd-remove t forwards?) (clipboard-cut "nowhere") (clipboard-clear "nowhere")))

  (define-option-require opt decl)
    <= (((and (field-context? t) (session-supports-completions?))) (tm-define-overloaded (kbd-variant t forwards?) (let* ((lan (get-env "prog-language")) (ses (get-env "prog-session")) (cmd (session-complete-command t)) (ret (lambda (x) (when x (custom-complete (tm->tree x)))))) (when (!= cmd "") (plugin-command lan ses cmd ret (quote ()))))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (and (field-context? t) (session-supports-completions?))) (tm-define-overloaded (kbd-variant t forwards?) (let* ((lan (get-env "prog-language")) (ses (get-env "prog-session")) (cmd (session-complete-command t)) (ret (lambda (x) (when x (custom-complete (tm->tree x)))))) (when (!= cmd "") (plugin-command lan ses cmd ret (quote ()))))))

  (define-option-require opt decl)
    <= (((and (tree-is? t (quote document)) (field-input-context? (tree-ref t #:up)))) (tm-define-overloaded (document-context? t) #f))
    => (define-option-match opt decl) <= ((lambda (t) (and (tree-is? t (quote document)) (field-input-context? (tree-ref t #:up)))) (tm-define-overloaded (document-context? t) #f))

  (define-option-require opt decl)
    <= (((field-input-context? t)) (tm-define-overloaded (traverse-horizontal t forwards?) (with move (if forwards? go-to-next-word go-to-previous-word) (go-to-remain-inside move field-context? 1))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (field-input-context? t)) (tm-define-overloaded (traverse-horizontal t forwards?) (with move (if forwards? go-to-next-word go-to-previous-word) (go-to-remain-inside move field-context? 1))))

  (define-option-require opt decl)
    <= (((field-input-context? t)) (tm-define-overloaded (traverse-vertical t downwards?) (if downwards? (field-go-down) (field-go-up))))
    => (define-option-match opt decl) <= ((lambda (t downwards?) (field-input-context? t)) (tm-define-overloaded (traverse-vertical t downwards?) (if downwards? (field-go-down) (field-go-up))))

  (define-option-require opt decl)
    <= (((field-input-context? t)) (tm-define-overloaded (traverse-extremal t forwards?) (with move (if forwards? field-go-down field-go-up) (go-to-repeat move))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (field-input-context? t)) (tm-define-overloaded (traverse-extremal t forwards?) (with move (if forwards? field-go-down field-go-up) (go-to-repeat move))))

  (define-option-require opt decl)
    <= (((field-input-context? t)) (tm-define-overloaded (traverse-incremental t downwards?) (if downwards? (field-go-down) (field-go-up))))
    => (define-option-match opt decl) <= ((lambda (t downwards?) (field-input-context? t)) (tm-define-overloaded (traverse-incremental t downwards?) (if downwards? (field-go-down) (field-go-up))))

  (define-option-require opt decl)
    <= (((field-input-context? t)) (tm-define-overloaded (structured-horizontal t forwards?) (noop)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (field-input-context? t)) (tm-define-overloaded (structured-horizontal t forwards?) (noop)))

  (define-option-require opt decl)
    <= (((field-input-context? t)) (tm-define-overloaded (structured-vertical t downwards?) (with move (if downwards? field-go-down field-go-up) (go-to-remain-inside move (quote session)))))
    => (define-option-match opt decl) <= ((lambda (t downwards?) (field-input-context? t)) (tm-define-overloaded (structured-vertical t downwards?) (with move (if downwards? field-go-down field-go-up) (go-to-remain-inside move (quote session)))))

  (define-option-require opt decl)
    <= (((field-unfolded-context? t)) (tm-define-overloaded (alternate-toggle t) (with i (tree-down-index t) (variant-set t (ahash-ref alternate-table (tree-label t))) (if (== i 2) (tree-go-to t 1 #:end)))))
    => (define-option-match opt decl) <= ((lambda (t) (field-unfolded-context? t)) (tm-define-overloaded (alternate-toggle t) (with i (tree-down-index t) (variant-set t (ahash-ref alternate-table (tree-label t))) (if (== i 2) (tree-go-to t 1 #:end)))))

  (define-option-require opt decl)
    <= (((field-folded-context? t)) (tm-define-overloaded (alternate-toggle t) (variant-set t (ahash-ref alternate-table (tree-label t)))))
    => (define-option-match opt decl) <= ((lambda (t) (field-folded-context? t)) (tm-define-overloaded (alternate-toggle t) (variant-set t (ahash-ref alternate-table (tree-label t)))))

  (define-option-require opt decl)
    <= (((field-input-context? t)) (tm-define-overloaded (structured-insert-horizontal t forwards?) (if forwards? (field-insert-fold t))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (field-input-context? t)) (tm-define-overloaded (structured-insert-horizontal t forwards?) (if forwards? (field-insert-fold t))))

  (define-option-require opt decl)
    <= (((field-input-context? t)) (tm-define-overloaded (structured-insert-vertical t downwards?) (field-insert t downwards?)))
    => (define-option-match opt decl) <= ((lambda (t downwards?) (field-input-context? t)) (tm-define-overloaded (structured-insert-vertical t downwards?) (field-insert t downwards?)))

  (define-option-require opt decl)
    <= (((field-input-context? t)) (tm-define-overloaded (structured-remove-horizontal t forwards?) (field-remove t forwards?)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (field-input-context? t)) (tm-define-overloaded (structured-remove-horizontal t forwards?) (field-remove t forwards?)))

  (define-option-require opt decl)
    <= (((field-input-context? t)) (tm-define-overloaded (structured-remove-vertical t forwards?) (field-remove t forwards?)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (field-input-context? t)) (tm-define-overloaded (structured-remove-vertical t forwards?) (field-remove t forwards?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Return calc-table ancestor for @t or #f") (tm-define-overloaded (calc-table-search t) (or (and (tree-is? t (quote calc-table)) t) (and (tree-ref t #:up) (not (tree-is? t #:up (quote table))) (calc-table-search (tree-up t))))))
   => ((quote calc-table-search) #:synopsis (quote ("Return calc-table ancestor for @t or #f")))
 => cons <> cur-props
   => cur-props => (((quote calc-table-search) #:synopsis (quote ("Return calc-table ancestor for @t or #f"))))

(property-set! var prop what conds*)
  <= (calc-table-search #:synopsis ("Return calc-table ancestor for @t or #f") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Check whether @t is a table inside a calc-table") (tm-define-overloaded (calc-table-context? t) (and (tree-is? t (quote table)) (nnot (calc-table-search (tree-up t))))))
   => ((quote calc-table-context?) #:synopsis (quote ("Check whether @t is a table inside a calc-table")))
 => cons <> cur-props
   => cur-props => (((quote calc-table-context?) #:synopsis (quote ("Check whether @t is a table inside a calc-table"))))

(property-set! var prop what conds*)
  <= (calc-table-context? #:synopsis ("Check whether @t is a table inside a calc-table") ())

  (define-option-require opt decl)
    <= (((tree-in? t (quote (calc-output calc-generate calc-answer calc-check)))) (tm-define-overloaded (alternate-toggle t) (tree-assign-node! t (symbol-toggle-alternate (tree-label t))) (tree-go-to t 1 #:end)))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (calc-output calc-generate calc-answer calc-check)))) (tm-define-overloaded (alternate-toggle t) (tree-assign-node! t (symbol-toggle-alternate (tree-label t))) (tree-go-to t 1 #:end)))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (calc-input calc-generate-command calc-answer-command calc-check-predicate)))) (tm-define-overloaded (alternate-toggle t) (tree-assign-node! t (symbol-toggle-alternate (tree-label t))) (tree-go-to t 2 #:end) (calc)))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (calc-input calc-generate-command calc-answer-command calc-check-predicate)))) (tm-define-overloaded (alternate-toggle t) (tree-assign-node! t (symbol-toggle-alternate (tree-label t))) (tree-go-to t 2 #:end) (calc)))

  (define-option-require opt decl)
    <= (((calc-check-context? t)) (tm-define-overloaded (variant-circulate t forward?) (cond ((or (and (tree-is? t (quote calc-check-predicate)) forward?) (and (tree-is? t (quote calc-check)) (not forward?))) (tree-assign-node! t (quote calc-check-command)) (tree-go-to t 4 2 #:end)) ((or (and (tree-is? t (quote calc-check-command)) forward?) (and (tree-is? t (quote calc-check-predicate)) (not forward?))) (tree-assign-node! t (quote calc-check)) (tree-go-to t 2 #:end)) ((or (and (tree-is? t (quote calc-check)) forward?) (and (tree-is? t (quote calc-check-command)) (not forward?))) (tree-assign-node! t (quote calc-check-predicate)) (tree-go-to t 1 #:end)))))
    => (define-option-match opt decl) <= ((lambda (t forward?) (calc-check-context? t)) (tm-define-overloaded (variant-circulate t forward?) (cond ((or (and (tree-is? t (quote calc-check-predicate)) forward?) (and (tree-is? t (quote calc-check)) (not forward?))) (tree-assign-node! t (quote calc-check-command)) (tree-go-to t 4 2 #:end)) ((or (and (tree-is? t (quote calc-check-command)) forward?) (and (tree-is? t (quote calc-check-predicate)) (not forward?))) (tree-assign-node! t (quote calc-check)) (tree-go-to t 2 #:end)) ((or (and (tree-is? t (quote calc-check)) forward?) (and (tree-is? t (quote calc-check-command)) (not forward?))) (tree-assign-node! t (quote calc-check-predicate)) (tree-go-to t 1 #:end)))))

  (define-option-require opt decl)
    <= (((and (calc-inert-context? t) (not (tree-is? t #:up (quote inactive))))) (tm-define-overloaded (kbd-enter t forwards?) (calc)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (and (calc-inert-context? t) (not (tree-is? t #:up (quote inactive))))) (tm-define-overloaded (kbd-enter t forwards?) (calc)))

  (define-option-require opt decl)
    <= (((and (or (calc-toggle-context? t) (calc-generate-context? t) (calc-answer-context? t)) (not (tree-is? t #:up (quote inactive))))) (tm-define-overloaded (kbd-enter t forwards?) (alternate-toggle t)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (and (or (calc-toggle-context? t) (calc-generate-context? t) (calc-answer-context? t)) (not (tree-is? t #:up (quote inactive))))) (tm-define-overloaded (kbd-enter t forwards?) (alternate-toggle t)))

  (define-option-require opt decl)
    <= (((and (calc-check-context? t) (not (tree-is? t #:up (quote inactive))))) (tm-define-overloaded (kbd-enter t forwards?) (variant-circulate t #t)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (and (calc-check-context? t) (not (tree-is? t #:up (quote inactive))))) (tm-define-overloaded (kbd-enter t forwards?) (variant-circulate t #t)))

  (define-option-require opt decl)
    <= (((calc-table-context? t)) (tm-define-overloaded (table-resize-notify t) (calc-table-update-table (calc-table-search t))))
    => (define-option-match opt decl) <= ((lambda (t) (calc-table-context? t)) (tm-define-overloaded (table-resize-notify t) (calc-table-update-table (calc-table-search t))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (cell-input cell-output)))) (tm-define-overloaded (calc-get-input t) (cell-input-expand (cell-input-encode (remove-equal (tree-ref t 1))))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (cell-input cell-output)))) (tm-define-overloaded (calc-get-input t) (cell-input-expand (cell-input-encode (remove-equal (tree-ref t 1))))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote cell-output))) (tm-define-overloaded (alternate-toggle t) (tree-assign-node t (quote cell-input)) (tree-go-to t 1 #:end)))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote cell-output))) (tm-define-overloaded (alternate-toggle t) (tree-assign-node t (quote cell-input)) (tree-go-to t 1 #:end)))

  (define-option-require opt decl)
    <= (((tree-is? t (quote cell-input))) (tm-define-overloaded (alternate-toggle t) (if (starts-with-equal? t) (begin (tree-assign-node t (quote cell-output)) (tree-go-to t 2 #:end) (calc)) (begin (tree-assign-node! t (quote cell-inert)) (tree-remove! t 2 1) (calc)))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote cell-input))) (tm-define-overloaded (alternate-toggle t) (if (starts-with-equal? t) (begin (tree-assign-node t (quote cell-output)) (tree-go-to t 2 #:end) (calc)) (begin (tree-assign-node! t (quote cell-inert)) (tree-remove! t 2 1) (calc)))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote cell-inert))) (tm-define-overloaded (kbd-enter t forwards?) (if (starts-with-equal? t) (begin (tree-assign-node t (quote cell-output)) (tree-insert! t 2 (quote (""))) (tree-go-to t 2 #:end) (calc)) (begin (calc)))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (tree-is? t (quote cell-inert))) (tm-define-overloaded (kbd-enter t forwards?) (if (starts-with-equal? t) (begin (tree-assign-node t (quote cell-output)) (tree-insert! t 2 (quote (""))) (tree-go-to t 2 #:end) (calc)) (begin (calc)))))

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" in-link-mode?) (tm-define-overloaded (set-link-mode mode) (set! current-link-mode mode)))
    => ((quote set-link-mode) #:check-mark (list "v" in-link-mode?))
 => cons <> cur-props
    => cur-props => (((quote set-link-mode) #:check-mark (list "v" in-link-mode?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set the current linking mode to @mode") (tm-define-overloaded (set-link-mode mode) (set! current-link-mode mode)))
   => ((quote set-link-mode) #:synopsis (quote ("Set the current linking mode to @mode")))
 => cons <> cur-props
   => cur-props => (((quote set-link-mode) #:synopsis (quote ("Set the current linking mode to @mode"))) ((quote set-link-mode) #:check-mark (list "v" in-link-mode?)))

(property-set! var prop what conds*)
  <= (set-link-mode #:synopsis ("Set the current linking mode to @mode") ())

(property-set! var prop what conds*)
  <= (set-link-mode #:check-mark ("v" #<procedure in-link-mode? (mode)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("auto" link-on-locus?) (tm-define-overloaded (link-set-locus nr) (with-innermost t (quote locus) (ahash-set! link-participants nr (tree->tree-pointer t)))))
    => ((quote link-set-locus) #:check-mark (list "auto" link-on-locus?))
 => cons <> cur-props
    => cur-props => (((quote link-set-locus) #:check-mark (list "auto" link-on-locus?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set locus number @nr of a link.") (tm-define-overloaded (link-set-locus nr) (with-innermost t (quote locus) (ahash-set! link-participants nr (tree->tree-pointer t)))))
   => ((quote link-set-locus) #:synopsis (quote ("Set locus number @nr of a link.")))
 => cons <> cur-props
   => cur-props => (((quote link-set-locus) #:synopsis (quote ("Set locus number @nr of a link."))) ((quote link-set-locus) #:check-mark (list "auto" link-on-locus?)))

(property-set! var prop what conds*)
  <= (link-set-locus #:synopsis ("Set locus number @nr of a link.") ())

(property-set! var prop what conds*)
  <= (link-set-locus #:check-mark ("auto" #<procedure link-on-locus? (nr)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" link-component-is-url?) (tm-define-overloaded (link-set-url nr name) (ahash-set! link-participants nr (quasiquote (url (unquote name))))))
    => ((quote link-set-url) #:check-mark (list "o" link-component-is-url?))
 => cons <> cur-props
    => cur-props => (((quote link-set-url) #:check-mark (list "o" link-component-is-url?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set component @nr of a link to an url @name.") (tm-define-overloaded (link-set-url nr name) (ahash-set! link-participants nr (quasiquote (url (unquote name))))))
   => ((quote link-set-url) #:synopsis (quote ("Set component @nr of a link to an url @name.")))
 => cons <> cur-props
   => cur-props => (((quote link-set-url) #:synopsis (quote ("Set component @nr of a link to an url @name."))) ((quote link-set-url) #:check-mark (list "o" link-component-is-url?)))

(property-set! var prop what conds*)
  <= (link-set-url #:synopsis ("Set component @nr of a link to an url @name.") ())

(property-set! var prop what conds*)
  <= (link-set-url #:check-mark ("o" #<procedure link-component-is-url? (nr . args)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" link-target-is-url?) (tm-define-overloaded (link-set-target-url url) (ahash-set! link-participants 1 (quasiquote (url (unquote url))))))
    => ((quote link-set-target-url) #:check-mark (list "o" link-target-is-url?))
 => cons <> cur-props
    => cur-props => (((quote link-set-target-url) #:check-mark (list "o" link-target-is-url?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set target of link to an @url.") (tm-define-overloaded (link-set-target-url url) (ahash-set! link-participants 1 (quasiquote (url (unquote url))))))
   => ((quote link-set-target-url) #:synopsis (quote ("Set target of link to an @url.")))
 => cons <> cur-props
   => cur-props => (((quote link-set-target-url) #:synopsis (quote ("Set target of link to an @url."))) ((quote link-set-target-url) #:check-mark (list "o" link-target-is-url?)))

(property-set! var prop what conds*)
  <= (link-set-target-url #:synopsis ("Set target of link to an @url.") ())

(property-set! var prop what conds*)
  <= (link-set-target-url #:check-mark ("o" #<procedure link-target-is-url? args>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" link-component-is-script?) (tm-define-overloaded (link-set-script nr t) (ahash-set! link-participants nr (quasiquote (url (unquote name))))))
    => ((quote link-set-script) #:check-mark (list "o" link-component-is-script?))
 => cons <> cur-props
    => cur-props => (((quote link-set-script) #:check-mark (list "o" link-component-is-script?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set component @nr of a link to the script @t.") (tm-define-overloaded (link-set-script nr t) (ahash-set! link-participants nr (quasiquote (url (unquote name))))))
   => ((quote link-set-script) #:synopsis (quote ("Set component @nr of a link to the script @t.")))
 => cons <> cur-props
   => cur-props => (((quote link-set-script) #:synopsis (quote ("Set component @nr of a link to the script @t."))) ((quote link-set-script) #:check-mark (list "o" link-component-is-script?)))

(property-set! var prop what conds*)
  <= (link-set-script #:synopsis ("Set component @nr of a link to the script @t.") ())

(property-set! var prop what conds*)
  <= (link-set-script #:check-mark ("o" #<procedure link-component-is-script? (nr . args)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("o" link-target-is-script?) (tm-define-overloaded (link-set-target-script script) (ahash-set! link-participants 1 (quasiquote (script (unquote script))))))
    => ((quote link-set-target-script) #:check-mark (list "o" link-target-is-script?))
 => cons <> cur-props
    => cur-props => (((quote link-set-target-script) #:check-mark (list "o" link-target-is-script?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set target of link to a @script.") (tm-define-overloaded (link-set-target-script script) (ahash-set! link-participants 1 (quasiquote (script (unquote script))))))
   => ((quote link-set-target-script) #:synopsis (quote ("Set target of link to a @script.")))
 => cons <> cur-props
   => cur-props => (((quote link-set-target-script) #:synopsis (quote ("Set target of link to a @script."))) ((quote link-set-target-script) #:check-mark (list "o" link-target-is-script?)))

(property-set! var prop what conds*)
  <= (link-set-target-script #:synopsis ("Set target of link to a @script.") ())

(property-set! var prop what conds*)
  <= (link-set-target-script #:check-mark ("o" #<procedure link-target-is-script? args>) ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Did enter all necessary information for constructing a link?") (tm-define-overloaded (link-completed?) (and (ahash-ref link-participants 0) (ahash-ref link-participants 1) (cond ((== current-link-mode "simple") #t) ((== current-link-mode "bidirectional") #t) ((== current-link-mode "external") (inside? (quote locus))) (else #f)))))
   => ((quote link-completed?) #:synopsis (quote ("Did enter all necessary information for constructing a link?")))
 => cons <> cur-props
   => cur-props => (((quote link-completed?) #:synopsis (quote ("Did enter all necessary information for constructing a link?"))))

(property-set! var prop what conds*)
  <= (link-completed? #:synopsis ("Did enter all necessary information for constructing a link?") ())

  (define-option-argument opt decl)
    <= ((type "Link type") (tm-define-overloaded (make-link type) (when (link-completed?) (for-each link-build (string-tokenize-comma type)) (link-clean 0))))
    => cons <> cur-props <= ((quote make-link) #:arguments (quote (type)))
    => cons <> cur-props <= ((quote make-link) (quote (#:argument type)) (quote ("Link type")))
    => cur-props => (((quote make-link) (quote (#:argument type)) (quote ("Link type"))) ((quote make-link) #:arguments (quote (type))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make a link of type @type.") (tm-define-overloaded (make-link type) (when (link-completed?) (for-each link-build (string-tokenize-comma type)) (link-clean 0))))
   => ((quote make-link) #:synopsis (quote ("Make a link of type @type.")))
 => cons <> cur-props
   => cur-props => (((quote make-link) #:synopsis (quote ("Make a link of type @type."))) ((quote make-link) (quote (#:argument type)) (quote ("Link type"))) ((quote make-link) #:arguments (quote (type))))

(property-set! var prop what conds*)
  <= (make-link #:synopsis ("Make a link of type @type.") ())

(property-set! var prop what conds*)
  <= (make-link (#:argument type) ("Link type") ())

(property-set! var prop what conds*)
  <= (make-link #:arguments (type) ())

  (define-option-argument opt decl)
    <= ((check-mode? "Filter according to the current link mode?") (tm-define-overloaded (locus-link-types check-mode?) (if (not (inside? (quote locus))) (quote ()) (with-innermost t (quote locus) (let* ((l1 (cDr (tree-children t))) (l2 (list-filter l1 (cut locus-consider-link? <> check-mode?))) (l3 (filter-map link-type l2))) (list-remove-duplicates l3))))))
    => cons <> cur-props <= ((quote locus-link-types) #:arguments (quote (check-mode?)))
    => cons <> cur-props <= ((quote locus-link-types) (quote (#:argument check-mode?)) (quote ("Filter according to the current link mode?")))
    => cur-props => (((quote locus-link-types) (quote (#:argument check-mode?)) (quote ("Filter according to the current link mode?"))) ((quote locus-link-types) #:arguments (quote (check-mode?))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Get all link types occurring in the current locus.") (tm-define-overloaded (locus-link-types check-mode?) (if (not (inside? (quote locus))) (quote ()) (with-innermost t (quote locus) (let* ((l1 (cDr (tree-children t))) (l2 (list-filter l1 (cut locus-consider-link? <> check-mode?))) (l3 (filter-map link-type l2))) (list-remove-duplicates l3))))))
   => ((quote locus-link-types) #:synopsis (quote ("Get all link types occurring in the current locus.")))
 => cons <> cur-props
   => cur-props => (((quote locus-link-types) #:synopsis (quote ("Get all link types occurring in the current locus."))) ((quote locus-link-types) (quote (#:argument check-mode?)) (quote ("Filter according to the current link mode?"))) ((quote locus-link-types) #:arguments (quote (check-mode?))))

(property-set! var prop what conds*)
  <= (locus-link-types #:synopsis ("Get all link types occurring in the current locus.") ())

(property-set! var prop what conds*)
  <= (locus-link-types (#:argument check-mode?) ("Filter according to the current link mode?") ())

(property-set! var prop what conds*)
  <= (locus-link-types #:arguments (check-mode?) ())

  (define-option-proposals opt decl)
    <= ((type (locus-link-types #t)) (tm-define-overloaded (remove-link-of-types type) (for-each remove-link-of-type (string-tokenize-comma type))))
    => cons <> cur-props <= ((quote remove-link-of-types) (quote (#:proposals type)) (lambda () (locus-link-types #t)))
    => cur-props => (((quote remove-link-of-types) (quote (#:proposals type)) (lambda () (locus-link-types #t))))

  (define-option-argument opt decl)
    <= ((type "Link type") (tm-define-overloaded (remove-link-of-types type) (for-each remove-link-of-type (string-tokenize-comma type))))
    => cons <> cur-props <= ((quote remove-link-of-types) #:arguments (quote (type)))
    => cons <> cur-props <= ((quote remove-link-of-types) (quote (#:argument type)) (quote ("Link type")))
    => cur-props => (((quote remove-link-of-types) (quote (#:argument type)) (quote ("Link type"))) ((quote remove-link-of-types) #:arguments (quote (type))) ((quote remove-link-of-types) (quote (#:proposals type)) (lambda () (locus-link-types #t))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Remove all links of type @type.") (tm-define-overloaded (remove-link-of-types type) (for-each remove-link-of-type (string-tokenize-comma type))))
   => ((quote remove-link-of-types) #:synopsis (quote ("Remove all links of type @type.")))
 => cons <> cur-props
   => cur-props => (((quote remove-link-of-types) #:synopsis (quote ("Remove all links of type @type."))) ((quote remove-link-of-types) (quote (#:argument type)) (quote ("Link type"))) ((quote remove-link-of-types) #:arguments (quote (type))) ((quote remove-link-of-types) (quote (#:proposals type)) (lambda () (locus-link-types #t))))

(property-set! var prop what conds*)
  <= (remove-link-of-types #:synopsis ("Remove all links of type @type.") ())

(property-set! var prop what conds*)
  <= (remove-link-of-types (#:argument type) ("Link type") ())

(property-set! var prop what conds*)
  <= (remove-link-of-types #:arguments (type) ())

(property-set! var prop what conds*)
  <= (remove-link-of-types (#:proposals type) #<procedure #f ()> ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Remove all links from the current locus.") (tm-define-overloaded (remove-all-links) (for-each remove-link-of-type (locus-link-types #t))))
   => ((quote remove-all-links) #:synopsis (quote ("Remove all links from the current locus.")))
 => cons <> cur-props
   => cur-props => (((quote remove-all-links) #:synopsis (quote ("Remove all links from the current locus."))))

(property-set! var prop what conds*)
  <= (remove-all-links #:synopsis ("Remove all links from the current locus.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Return locations of extern loci accessible from @t at url @here") (tm-define-overloaded (get-link-locations here t) (with l1 (get-id-locations here t) (if (null? l1) (tm->tree (quote (collection))) (let* ((l2 (map (cut encode-file-name here <>) l1)) (ids (list-remove-duplicates (map cadadr l2))) (l3 (map (cut encode-file-correspondance here <>) ids))) (tm->tree (quasiquote (collection (id (unquote (registry-id (url->unix here)))) (unquote-splicing (map (cut cons (quote target) <>) l3)) (unquote-splicing (map (cut cons (quote locator) <>) l2))))))))))
   => ((quote get-link-locations) #:synopsis (quote ("Return locations of extern loci accessible from @t at url @here")))
 => cons <> cur-props
   => cur-props => (((quote get-link-locations) #:synopsis (quote ("Return locations of extern loci accessible from @t at url @here"))))

(property-set! var prop what conds*)
  <= (get-link-locations #:synopsis ("Return locations of extern loci accessible from @t at url @here") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Load file which contains locus with a given @id.") (tm-define-overloaded (resolve-id id) (let* ((not-loaded? (lambda (u) (not (ahash-ref already-loaded-table u)))) (l1 (id->locations id)) (l2 (list-filter l1 not-loaded?))) (resolve-id-sub id l2))))
   => ((quote resolve-id) #:synopsis (quote ("Load file which contains locus with a given @id.")))
 => cons <> cur-props
   => cur-props => (((quote resolve-id) #:synopsis (quote ("Load file which contains locus with a given @id."))))

(property-set! var prop what conds*)
  <= (resolve-id #:synopsis ("Load file which contains locus with a given @id.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Register extern loci listed in @t at url @here") (tm-define-overloaded (register-link-locations here t) (with l (cdr (tree->stree t)) (for-each (cut register-link-location here <>) l))))
   => ((quote register-link-locations) #:synopsis (quote ("Register extern loci listed in @t at url @here")))
 => cons <> cur-props
   => cur-props => (((quote register-link-locations) #:synopsis (quote ("Register extern loci listed in @t at url @here"))))

(property-set! var prop what conds*)
  <= (register-link-locations #:synopsis ("Register extern loci listed in @t at url @here") ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" navigation-bidirectional?) (tm-define-overloaded (navigation-toggle-bidirectional) (set-boolean-preference "bidirectional navigation" (not navigation-bidirectional-links?))))
    => ((quote navigation-toggle-bidirectional) #:check-mark (list "v" navigation-bidirectional?))
 => cons <> cur-props
    => cur-props => (((quote navigation-toggle-bidirectional) #:check-mark (list "v" navigation-bidirectional?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle whether we may follow links in both directions.") (tm-define-overloaded (navigation-toggle-bidirectional) (set-boolean-preference "bidirectional navigation" (not navigation-bidirectional-links?))))
   => ((quote navigation-toggle-bidirectional) #:synopsis (quote ("Toggle whether we may follow links in both directions.")))
 => cons <> cur-props
   => cur-props => (((quote navigation-toggle-bidirectional) #:synopsis (quote ("Toggle whether we may follow links in both directions."))) ((quote navigation-toggle-bidirectional) #:check-mark (list "v" navigation-bidirectional?)))

(property-set! var prop what conds*)
  <= (navigation-toggle-bidirectional #:synopsis ("Toggle whether we may follow links in both directions.") ())

(property-set! var prop what conds*)
  <= (navigation-toggle-bidirectional #:check-mark ("v" #<procedure navigation-bidirectional? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" navigation-external?) (tm-define-overloaded (navigation-toggle-external) (set-boolean-preference "external navigation" (not navigation-external-links?))))
    => ((quote navigation-toggle-external) #:check-mark (list "v" navigation-external?))
 => cons <> cur-props
    => cur-props => (((quote navigation-toggle-external) #:check-mark (list "v" navigation-external?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle whether we may follow links defined in other loci.") (tm-define-overloaded (navigation-toggle-external) (set-boolean-preference "external navigation" (not navigation-external-links?))))
   => ((quote navigation-toggle-external) #:synopsis (quote ("Toggle whether we may follow links defined in other loci.")))
 => cons <> cur-props
   => cur-props => (((quote navigation-toggle-external) #:synopsis (quote ("Toggle whether we may follow links defined in other loci."))) ((quote navigation-toggle-external) #:check-mark (list "v" navigation-external?)))

(property-set! var prop what conds*)
  <= (navigation-toggle-external #:synopsis ("Toggle whether we may follow links defined in other loci.") ())

(property-set! var prop what conds*)
  <= (navigation-toggle-external #:check-mark ("v" #<procedure navigation-external? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" navigation-build-link-pages?) (tm-define-overloaded (navigation-toggle-build-link-pages) (set-boolean-preference "link pages" (not navigation-link-pages?))))
    => ((quote navigation-toggle-build-link-pages) #:check-mark (list "v" navigation-build-link-pages?))
 => cons <> cur-props
    => cur-props => (((quote navigation-toggle-build-link-pages) #:check-mark (list "v" navigation-build-link-pages?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle whether we generate link pages.") (tm-define-overloaded (navigation-toggle-build-link-pages) (set-boolean-preference "link pages" (not navigation-link-pages?))))
   => ((quote navigation-toggle-build-link-pages) #:synopsis (quote ("Toggle whether we generate link pages.")))
 => cons <> cur-props
   => cur-props => (((quote navigation-toggle-build-link-pages) #:synopsis (quote ("Toggle whether we generate link pages."))) ((quote navigation-toggle-build-link-pages) #:check-mark (list "v" navigation-build-link-pages?)))

(property-set! var prop what conds*)
  <= (navigation-toggle-build-link-pages #:synopsis ("Toggle whether we generate link pages.") ())

(property-set! var prop what conds*)
  <= (navigation-toggle-build-link-pages #:check-mark ("v" #<procedure navigation-build-link-pages? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" navigation-allow-type?) (tm-define-overloaded (navigation-toggle-type type) (ahash-set! navigation-blocked-types type (not (ahash-ref navigation-blocked-types type)))))
    => ((quote navigation-toggle-type) #:check-mark (list "v" navigation-allow-type?))
 => cons <> cur-props
    => cur-props => (((quote navigation-toggle-type) #:check-mark (list "v" navigation-allow-type?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle whether we may follow links of a given @type.") (tm-define-overloaded (navigation-toggle-type type) (ahash-set! navigation-blocked-types type (not (ahash-ref navigation-blocked-types type)))))
   => ((quote navigation-toggle-type) #:synopsis (quote ("Toggle whether we may follow links of a given @type.")))
 => cons <> cur-props
   => cur-props => (((quote navigation-toggle-type) #:synopsis (quote ("Toggle whether we may follow links of a given @type."))) ((quote navigation-toggle-type) #:check-mark (list "v" navigation-allow-type?)))

(property-set! var prop what conds*)
  <= (navigation-toggle-type #:synopsis ("Toggle whether we may follow links of a given @type.") ())

(property-set! var prop what conds*)
  <= (navigation-toggle-type #:check-mark ("v" #<procedure navigation-allow-type? (type)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" navigation-allow-no-types?) (tm-define-overloaded (navigation-allow-no-types) (for-each (cut ahash-set! navigation-blocked-types <> #t) (current-link-types))))
    => ((quote navigation-allow-no-types) #:check-mark (list "v" navigation-allow-no-types?))
 => cons <> cur-props
    => cur-props => (((quote navigation-allow-no-types) #:check-mark (list "v" navigation-allow-no-types?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Disallow any link types from being followed.") (tm-define-overloaded (navigation-allow-no-types) (for-each (cut ahash-set! navigation-blocked-types <> #t) (current-link-types))))
   => ((quote navigation-allow-no-types) #:synopsis (quote ("Disallow any link types from being followed.")))
 => cons <> cur-props
   => cur-props => (((quote navigation-allow-no-types) #:synopsis (quote ("Disallow any link types from being followed."))) ((quote navigation-allow-no-types) #:check-mark (list "v" navigation-allow-no-types?)))

(property-set! var prop what conds*)
  <= (navigation-allow-no-types #:synopsis ("Disallow any link types from being followed.") ())

(property-set! var prop what conds*)
  <= (navigation-allow-no-types #:check-mark ("v" #<procedure navigation-allow-no-types? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" navigation-allow-all-types?) (tm-define-overloaded (navigation-allow-all-types) (set! navigation-blocked-types (make-ahash-table))))
    => ((quote navigation-allow-all-types) #:check-mark (list "v" navigation-allow-all-types?))
 => cons <> cur-props
    => cur-props => (((quote navigation-allow-all-types) #:check-mark (list "v" navigation-allow-all-types?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Allow all link types to be followed.") (tm-define-overloaded (navigation-allow-all-types) (set! navigation-blocked-types (make-ahash-table))))
   => ((quote navigation-allow-all-types) #:synopsis (quote ("Allow all link types to be followed.")))
 => cons <> cur-props
   => cur-props => (((quote navigation-allow-all-types) #:synopsis (quote ("Allow all link types to be followed."))) ((quote navigation-allow-all-types) #:check-mark (list "v" navigation-allow-all-types?)))

(property-set! var prop what conds*)
  <= (navigation-allow-all-types #:synopsis ("Allow all link types to be followed.") ())

(property-set! var prop what conds*)
  <= (navigation-allow-all-types #:check-mark ("v" #<procedure navigation-allow-all-types? ()>) ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Build link list for identifiers in @ids") (tm-define-overloaded (ids->link-list ids) (append-map id->link-list ids)))
   => ((quote ids->link-list) #:synopsis (quote ("Build link list for identifiers in @ids")))
 => cons <> cur-props
   => cur-props => (((quote ids->link-list) #:synopsis (quote ("Build link list for identifiers in @ids"))))

(property-set! var prop what conds*)
  <= (ids->link-list #:synopsis ("Build link list for identifiers in @ids") ())

  (define-option-argument opt decl)
    <= ((filter? "Filter on navigation mode?") (tm-define-overloaded (exact-link-list t filter?) (with l (if (and filter? (not (navigation-external?))) (exact-link-list-local t) (exact-link-list-global t)) (if filter? (filter-link-list l "click") l))))
    => cons <> cur-props <= ((quote exact-link-list) #:arguments (quote (t filter?)))
    => cons <> cur-props <= ((quote exact-link-list) (quote (#:argument filter?)) (quote ("Filter on navigation mode?")))
    => cur-props => (((quote exact-link-list) (quote (#:argument filter?)) (quote ("Filter on navigation mode?"))) ((quote exact-link-list) #:arguments (quote (t filter?))))

  (define-option-argument opt decl)
    <= ((t "Build link list for this tree") (tm-define-overloaded (exact-link-list t filter?) (with l (if (and filter? (not (navigation-external?))) (exact-link-list-local t) (exact-link-list-global t)) (if filter? (filter-link-list l "click") l))))
    => cons <> cur-props <= ((quote exact-link-list) #:arguments (quote (t filter?)))
    => cons <> cur-props <= ((quote exact-link-list) (quote (#:argument t)) (quote ("Build link list for this tree")))
    => cur-props => (((quote exact-link-list) (quote (#:argument t)) (quote ("Build link list for this tree"))) ((quote exact-link-list) #:arguments (quote (t filter?))) ((quote exact-link-list) (quote (#:argument filter?)) (quote ("Filter on navigation mode?"))) ((quote exact-link-list) #:arguments (quote (t filter?))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Build possibly filtered link list for the tree @t.") (tm-define-overloaded (exact-link-list t filter?) (with l (if (and filter? (not (navigation-external?))) (exact-link-list-local t) (exact-link-list-global t)) (if filter? (filter-link-list l "click") l))))
   => ((quote exact-link-list) #:synopsis (quote ("Build possibly filtered link list for the tree @t.")))
 => cons <> cur-props
   => cur-props => (((quote exact-link-list) #:synopsis (quote ("Build possibly filtered link list for the tree @t."))) ((quote exact-link-list) (quote (#:argument t)) (quote ("Build link list for this tree"))) ((quote exact-link-list) #:arguments (quote (t filter?))) ((quote exact-link-list) (quote (#:argument filter?)) (quote ("Filter on navigation mode?"))) ((quote exact-link-list) #:arguments (quote (t filter?))))

(property-set! var prop what conds*)
  <= (exact-link-list #:synopsis ("Build possibly filtered link list for the tree @t.") ())

(property-set! var prop what conds*)
  <= (exact-link-list (#:argument t) ("Build link list for this tree") ())

(property-set! var prop what conds*)
  <= (exact-link-list #:arguments (t filter?) ())

(property-set! var prop what conds*)
  <= (exact-link-list (#:argument filter?) ("Filter on navigation mode?") ())

(property-set! var prop what conds*)
  <= (exact-link-list #:arguments (t filter?) ())

  (define-option-argument opt decl)
    <= ((filter? "Filter on navigation mode?") (tm-define-overloaded (upward-link-list t filter?) (if (or (not t) (null? (tree->path t))) (quote ()) (with l (exact-link-list t filter?) (if (root? t) l (append l (upward-link-list (tree-up t) filter?)))))))
    => cons <> cur-props <= ((quote upward-link-list) #:arguments (quote (t filter?)))
    => cons <> cur-props <= ((quote upward-link-list) (quote (#:argument filter?)) (quote ("Filter on navigation mode?")))
    => cur-props => (((quote upward-link-list) (quote (#:argument filter?)) (quote ("Filter on navigation mode?"))) ((quote upward-link-list) #:arguments (quote (t filter?))))

  (define-option-argument opt decl)
    <= ((t "Build link list for this tree and its ancestors") (tm-define-overloaded (upward-link-list t filter?) (if (or (not t) (null? (tree->path t))) (quote ()) (with l (exact-link-list t filter?) (if (root? t) l (append l (upward-link-list (tree-up t) filter?)))))))
    => cons <> cur-props <= ((quote upward-link-list) #:arguments (quote (t filter?)))
    => cons <> cur-props <= ((quote upward-link-list) (quote (#:argument t)) (quote ("Build link list for this tree and its ancestors")))
    => cur-props => (((quote upward-link-list) (quote (#:argument t)) (quote ("Build link list for this tree and its ancestors"))) ((quote upward-link-list) #:arguments (quote (t filter?))) ((quote upward-link-list) (quote (#:argument filter?)) (quote ("Filter on navigation mode?"))) ((quote upward-link-list) #:arguments (quote (t filter?))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Build possibly filtered link list for @t and its ancestors.") (tm-define-overloaded (upward-link-list t filter?) (if (or (not t) (null? (tree->path t))) (quote ()) (with l (exact-link-list t filter?) (if (root? t) l (append l (upward-link-list (tree-up t) filter?)))))))
   => ((quote upward-link-list) #:synopsis (quote ("Build possibly filtered link list for @t and its ancestors.")))
 => cons <> cur-props
   => cur-props => (((quote upward-link-list) #:synopsis (quote ("Build possibly filtered link list for @t and its ancestors."))) ((quote upward-link-list) (quote (#:argument t)) (quote ("Build link list for this tree and its ancestors"))) ((quote upward-link-list) #:arguments (quote (t filter?))) ((quote upward-link-list) (quote (#:argument filter?)) (quote ("Filter on navigation mode?"))) ((quote upward-link-list) #:arguments (quote (t filter?))))

(property-set! var prop what conds*)
  <= (upward-link-list #:synopsis ("Build possibly filtered link list for @t and its ancestors.") ())

(property-set! var prop what conds*)
  <= (upward-link-list (#:argument t) ("Build link list for this tree and its ancestors") ())

(property-set! var prop what conds*)
  <= (upward-link-list #:arguments (t filter?) ())

(property-set! var prop what conds*)
  <= (upward-link-list (#:argument filter?) ("Filter on navigation mode?") ())

(property-set! var prop what conds*)
  <= (upward-link-list #:arguments (t filter?) ())

  (define-option-argument opt decl)
    <= ((filter? "Filter on navigation mode?") (tm-define-overloaded (complete-link-list t filter?) (with l (exact-link-list t filter?) (if (tree-atomic? t) l (with ls (map (cut complete-link-list <> filter?) (tree-children t)) (apply append (cons l ls)))))))
    => cons <> cur-props <= ((quote complete-link-list) #:arguments (quote (t filter?)))
    => cons <> cur-props <= ((quote complete-link-list) (quote (#:argument filter?)) (quote ("Filter on navigation mode?")))
    => cur-props => (((quote complete-link-list) (quote (#:argument filter?)) (quote ("Filter on navigation mode?"))) ((quote complete-link-list) #:arguments (quote (t filter?))))

  (define-option-argument opt decl)
    <= ((t "Build link list for this tree and its descendants") (tm-define-overloaded (complete-link-list t filter?) (with l (exact-link-list t filter?) (if (tree-atomic? t) l (with ls (map (cut complete-link-list <> filter?) (tree-children t)) (apply append (cons l ls)))))))
    => cons <> cur-props <= ((quote complete-link-list) #:arguments (quote (t filter?)))
    => cons <> cur-props <= ((quote complete-link-list) (quote (#:argument t)) (quote ("Build link list for this tree and its descendants")))
    => cur-props => (((quote complete-link-list) (quote (#:argument t)) (quote ("Build link list for this tree and its descendants"))) ((quote complete-link-list) #:arguments (quote (t filter?))) ((quote complete-link-list) (quote (#:argument filter?)) (quote ("Filter on navigation mode?"))) ((quote complete-link-list) #:arguments (quote (t filter?))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Build possibly filtered link list for @t and its descendants.") (tm-define-overloaded (complete-link-list t filter?) (with l (exact-link-list t filter?) (if (tree-atomic? t) l (with ls (map (cut complete-link-list <> filter?) (tree-children t)) (apply append (cons l ls)))))))
   => ((quote complete-link-list) #:synopsis (quote ("Build possibly filtered link list for @t and its descendants.")))
 => cons <> cur-props
   => cur-props => (((quote complete-link-list) #:synopsis (quote ("Build possibly filtered link list for @t and its descendants."))) ((quote complete-link-list) (quote (#:argument t)) (quote ("Build link list for this tree and its descendants"))) ((quote complete-link-list) #:arguments (quote (t filter?))) ((quote complete-link-list) (quote (#:argument filter?)) (quote ("Filter on navigation mode?"))) ((quote complete-link-list) #:arguments (quote (t filter?))))

(property-set! var prop what conds*)
  <= (complete-link-list #:synopsis ("Build possibly filtered link list for @t and its descendants.") ())

(property-set! var prop what conds*)
  <= (complete-link-list (#:argument t) ("Build link list for this tree and its descendants") ())

(property-set! var prop what conds*)
  <= (complete-link-list #:arguments (t filter?) ())

(property-set! var prop what conds*)
  <= (complete-link-list (#:argument filter?) ("Filter on navigation mode?") ())

(property-set! var prop what conds*)
  <= (complete-link-list #:arguments (t filter?) ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Does @t contain an active link?") (tm-define-overloaded (link-may-follow? t) (nnull? (upward-navigation-list t))))
   => ((quote link-may-follow?) #:synopsis (quote ("Does @t contain an active link?")))
 => cons <> cur-props
   => cur-props => (((quote link-may-follow?) #:synopsis (quote ("Does @t contain an active link?"))))

(property-set! var prop what conds*)
  <= (link-may-follow? #:synopsis ("Does @t contain an active link?") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Return active ancestor trees for the tree @t.") (tm-define-overloaded (link-active-upwards t) (with l (upward-link-list t #t) (link-active-upwards-sub t (map link-item-id l)))))
   => ((quote link-active-upwards) #:synopsis (quote ("Return active ancestor trees for the tree @t.")))
 => cons <> cur-props
   => cur-props => (((quote link-active-upwards) #:synopsis (quote ("Return active ancestor trees for the tree @t."))))

(property-set! var prop what conds*)
  <= (link-active-upwards #:synopsis ("Return active ancestor trees for the tree @t.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Return list of identifiers in @l which admit an active link.") (tm-define-overloaded (link-active-ids l) (with r (filter-link-list (ids->link-list l) "click") (list-remove-duplicates (map link-item-id r)))))
   => ((quote link-active-ids) #:synopsis (quote ("Return list of identifiers in @l which admit an active link.")))
 => cons <> cur-props
   => cur-props => (((quote link-active-ids) #:synopsis (quote ("Return list of identifiers in @l which admit an active link."))))

(property-set! var prop what conds*)
  <= (link-active-ids #:synopsis ("Return list of identifiers in @l which admit an active link.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Transforms the link list @t into a navigation list") (tm-define-overloaded (link-list->navigation-list l) (if (null? l) l (let* ((item (car l)) (source (link-item-id item)) (type (link-item-type item)) (attrs (link-item-attributes item)) (vertices (link-item-vertices item)) (h (navigation-list-sub type attrs 0 source vertices)) (r (link-list->navigation-list (cdr l))) (nl (navigation-list-simplify (append h r)))) nl))))
   => ((quote link-list->navigation-list) #:synopsis (quote ("Transforms the link list @t into a navigation list")))
 => cons <> cur-props
   => cur-props => (((quote link-list->navigation-list) #:synopsis (quote ("Transforms the link list @t into a navigation list"))))

(property-set! var prop what conds*)
  <= (link-list->navigation-list #:synopsis ("Transforms the link list @t into a navigation list") ())

  (define-option-argument opt decl)
    <= ((opt-from "Optional path for the cursor history") (tm-define-overloaded (go-to-id id . opt-from) (with l (id->trees id) (if (nnull? l) (begin (if (nnull? opt-from) (cursor-history-add (car opt-from))) (tree-go-to (car l) #:end) (if (nnull? opt-from) (cursor-history-add (cursor-path)))) (and (resolve-id id) (delayed (#:idle 25) (apply go-to-id (cons id opt-from))))))))
    => cons <> cur-props <= ((quote go-to-id) #:arguments (quote (id . opt-from)))
    => cons <> cur-props <= ((quote go-to-id) (quote (#:argument opt-from)) (quote ("Optional path for the cursor history")))
    => cur-props => (((quote go-to-id) (quote (#:argument opt-from)) (quote ("Optional path for the cursor history"))) ((quote go-to-id) #:arguments (quote (id . opt-from))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Jump to the first locus with a given identifier @id.") (tm-define-overloaded (go-to-id id . opt-from) (with l (id->trees id) (if (nnull? l) (begin (if (nnull? opt-from) (cursor-history-add (car opt-from))) (tree-go-to (car l) #:end) (if (nnull? opt-from) (cursor-history-add (cursor-path)))) (and (resolve-id id) (delayed (#:idle 25) (apply go-to-id (cons id opt-from))))))))
   => ((quote go-to-id) #:synopsis (quote ("Jump to the first locus with a given identifier @id.")))
 => cons <> cur-props
   => cur-props => (((quote go-to-id) #:synopsis (quote ("Jump to the first locus with a given identifier @id."))) ((quote go-to-id) (quote (#:argument opt-from)) (quote ("Optional path for the cursor history"))) ((quote go-to-id) #:arguments (quote (id . opt-from))))

(property-set! var prop what conds*)
  <= (go-to-id #:synopsis ("Jump to the first locus with a given identifier @id.") ())

(property-set! var prop what conds*)
  <= (go-to-id (#:argument opt-from) ("Optional path for the cursor history") ())

(property-set! var prop what conds*)
  <= (go-to-id #:arguments (id . opt-from) ())

  (define-option-argument opt decl)
    <= ((opt-from "Optional path for the cursor history") (tm-define-overloaded (go-to-url u . opt-from) (if (nnull? opt-from) (cursor-history-add (car opt-from))) (if (string? u) (set! u (system->url u))) (with (action post) (url-handlers u) (action u) (post u)) (if (nnull? opt-from) (cursor-history-add (cursor-path)))))
    => cons <> cur-props <= ((quote go-to-url) #:arguments (quote (u . opt-from)))
    => cons <> cur-props <= ((quote go-to-url) (quote (#:argument opt-from)) (quote ("Optional path for the cursor history")))
    => cur-props => (((quote go-to-url) (quote (#:argument opt-from)) (quote ("Optional path for the cursor history"))) ((quote go-to-url) #:arguments (quote (u . opt-from))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Jump to the url @u") (tm-define-overloaded (go-to-url u . opt-from) (if (nnull? opt-from) (cursor-history-add (car opt-from))) (if (string? u) (set! u (system->url u))) (with (action post) (url-handlers u) (action u) (post u)) (if (nnull? opt-from) (cursor-history-add (cursor-path)))))
   => ((quote go-to-url) #:synopsis (quote ("Jump to the url @u")))
 => cons <> cur-props
   => cur-props => (((quote go-to-url) #:synopsis (quote ("Jump to the url @u"))) ((quote go-to-url) (quote (#:argument opt-from)) (quote ("Optional path for the cursor history"))) ((quote go-to-url) #:arguments (quote (u . opt-from))))

(property-set! var prop what conds*)
  <= (go-to-url #:synopsis ("Jump to the url @u") ())

(property-set! var prop what conds*)
  <= (go-to-url (#:argument opt-from) ("Optional path for the cursor history") ())

(property-set! var prop what conds*)
  <= (go-to-url #:arguments (u . opt-from) ())

  (define-option-proposals opt decl)
    <= ((xtype (navigation-list-xtypes the-navigation-list)) (tm-define-overloaded (navigation-list-follow-xtyped xtype) (and-with hit (navigation-list-first-xtype the-navigation-list xtype) (set! the-navigation-list #f) (navigation-item-follow hit))))
    => cons <> cur-props <= ((quote navigation-list-follow-xtyped) (quote (#:proposals xtype)) (lambda () (navigation-list-xtypes the-navigation-list)))
    => cur-props => (((quote navigation-list-follow-xtyped) (quote (#:proposals xtype)) (lambda () (navigation-list-xtypes the-navigation-list))))

  (define-option-argument opt decl)
    <= ((xtype "Link type") (tm-define-overloaded (navigation-list-follow-xtyped xtype) (and-with hit (navigation-list-first-xtype the-navigation-list xtype) (set! the-navigation-list #f) (navigation-item-follow hit))))
    => cons <> cur-props <= ((quote navigation-list-follow-xtyped) #:arguments (quote (xtype)))
    => cons <> cur-props <= ((quote navigation-list-follow-xtyped) (quote (#:argument xtype)) (quote ("Link type")))
    => cur-props => (((quote navigation-list-follow-xtyped) (quote (#:argument xtype)) (quote ("Link type"))) ((quote navigation-list-follow-xtyped) #:arguments (quote (xtype))) ((quote navigation-list-follow-xtyped) (quote (#:proposals xtype)) (lambda () (navigation-list-xtypes the-navigation-list))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Follow the first link with given @type in @the-navigation-list.") (tm-define-overloaded (navigation-list-follow-xtyped xtype) (and-with hit (navigation-list-first-xtype the-navigation-list xtype) (set! the-navigation-list #f) (navigation-item-follow hit))))
   => ((quote navigation-list-follow-xtyped) #:synopsis (quote ("Follow the first link with given @type in @the-navigation-list.")))
 => cons <> cur-props
   => cur-props => (((quote navigation-list-follow-xtyped) #:synopsis (quote ("Follow the first link with given @type in @the-navigation-list."))) ((quote navigation-list-follow-xtyped) (quote (#:argument xtype)) (quote ("Link type"))) ((quote navigation-list-follow-xtyped) #:arguments (quote (xtype))) ((quote navigation-list-follow-xtyped) (quote (#:proposals xtype)) (lambda () (navigation-list-xtypes the-navigation-list))))

(property-set! var prop what conds*)
  <= (navigation-list-follow-xtyped #:synopsis ("Follow the first link with given @type in @the-navigation-list.") ())

(property-set! var prop what conds*)
  <= (navigation-list-follow-xtyped (#:argument xtype) ("Link type") ())

(property-set! var prop what conds*)
  <= (navigation-list-follow-xtyped #:arguments (xtype) ())

(property-set! var prop what conds*)
  <= (navigation-list-follow-xtyped (#:proposals xtype) #<procedure #f ()> ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Follow one of the links in the navigation list @nl.") (tm-define-overloaded (navigation-list-follow nl) (with types (navigation-list-types nl) (if (and (>= (length types) 2) (in? "automatic" types)) (with auto-nl (navigation-list-filter nl "automatic" #t #f) (set! nl (list-difference nl auto-nl)))) (with xtypes (navigation-list-xtypes nl) (cond ((null? xtypes) (noop)) ((and (navigation-build-link-pages?) (>= (length nl) 2)) (id-set-visited (navigation-source (car nl))) (build-navigation-page nl)) ((null? (cdr xtypes)) (navigation-item-follow (car nl))) (else (set! the-navigation-list nl) (interactive navigation-list-follow-xtyped)))))))
   => ((quote navigation-list-follow) #:synopsis (quote ("Follow one of the links in the navigation list @nl.")))
 => cons <> cur-props
   => cur-props => (((quote navigation-list-follow) #:synopsis (quote ("Follow one of the links in the navigation list @nl."))))

(property-set! var prop what conds*)
  <= (navigation-list-follow #:synopsis ("Follow one of the links in the navigation list @nl.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Follow one of the links for identifiers in @ids.") (tm-define-overloaded (link-follow-ids ids event) (navigation-list-follow (link-list->navigation-list (filter-link-list (ids->link-list ids) event)))))
   => ((quote link-follow-ids) #:synopsis (quote ("Follow one of the links for identifiers in @ids.")))
 => cons <> cur-props
   => cur-props => (((quote link-follow-ids) #:synopsis (quote ("Follow one of the links for identifiers in @ids."))))

(property-set! var prop what conds*)
  <= (link-follow-ids #:synopsis ("Follow one of the links for identifiers in @ids.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Follow one of the links in the current locus.") (tm-define-overloaded (locus-link-follow) (let* ((ts (link-active-upwards (cursor-tree))) (ids (append-map tree->ids ts))) (link-follow-ids ids "click"))))
   => ((quote locus-link-follow) #:synopsis (quote ("Follow one of the links in the current locus.")))
 => cons <> cur-props
   => cur-props => (((quote locus-link-follow) #:synopsis (quote ("Follow one of the links in the current locus."))))

(property-set! var prop what conds*)
  <= (locus-link-follow #:synopsis ("Follow one of the links in the current locus.") ())

  (define-option-argument opt decl)
    <= ((env "Environment") (tm-define-overloaded (build-environment-page env) (let* ((env-l (map string->symbol (string-tokenize-comma env))) (pred-l (map (lambda (tag) (cut tm-func? <> tag)) env-l)) (l (append-map (cut tree-search (buffer-tree) <>) pred-l))) (with cont (lambda () (let* ((name (string-append (buffer-get-title (current-buffer)) " - " env)) (style (quasiquote (tuple (unquote-splicing (get-style-list))))) (r (filter-map environment->locus l))) (delayed (#:pause 25) (build-locus-page-sub name style r #f)))) (if (locified? l) (cont) (user-confirm "Locify environments?" #f (lambda (answ) (if answ (locify l)) (cont))))))))
    => cons <> cur-props <= ((quote build-environment-page) #:arguments (quote (env)))
    => cons <> cur-props <= ((quote build-environment-page) (quote (#:argument env)) (quote ("Environment")))
    => cur-props => (((quote build-environment-page) (quote (#:argument env)) (quote ("Environment"))) ((quote build-environment-page) #:arguments (quote (env))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Build page with environments of type @env in current buffer.") (tm-define-overloaded (build-environment-page env) (let* ((env-l (map string->symbol (string-tokenize-comma env))) (pred-l (map (lambda (tag) (cut tm-func? <> tag)) env-l)) (l (append-map (cut tree-search (buffer-tree) <>) pred-l))) (with cont (lambda () (let* ((name (string-append (buffer-get-title (current-buffer)) " - " env)) (style (quasiquote (tuple (unquote-splicing (get-style-list))))) (r (filter-map environment->locus l))) (delayed (#:pause 25) (build-locus-page-sub name style r #f)))) (if (locified? l) (cont) (user-confirm "Locify environments?" #f (lambda (answ) (if answ (locify l)) (cont))))))))
   => ((quote build-environment-page) #:synopsis (quote ("Build page with environments of type @env in current buffer.")))
 => cons <> cur-props
   => cur-props => (((quote build-environment-page) #:synopsis (quote ("Build page with environments of type @env in current buffer."))) ((quote build-environment-page) (quote (#:argument env)) (quote ("Environment"))) ((quote build-environment-page) #:arguments (quote (env))))

(property-set! var prop what conds*)
  <= (build-environment-page #:synopsis ("Build page with environments of type @env in current buffer.") ())

(property-set! var prop what conds*)
  <= (build-environment-page (#:argument env) ("Environment") ())

(property-set! var prop what conds*)
  <= (build-environment-page #:arguments (env) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" version-test-grain?) (tm-define-overloaded (version-set-grain w) (set-preference "versioning grain" w) (reactualize-differences)))
    => ((quote version-set-grain) #:check-mark (list "*" version-test-grain?))
 => cons <> cur-props
    => cur-props => (((quote version-set-grain) #:check-mark (list "*" version-test-grain?)))

  (define-option-argument opt decl)
    <= ((w "detailed") (tm-define-overloaded (version-set-grain w) (set-preference "versioning grain" w) (reactualize-differences)))
    => cons <> cur-props <= ((quote version-set-grain) #:arguments (quote (w)))
    => cons <> cur-props <= ((quote version-set-grain) (quote (#:argument w)) (quote ("detailed")))
    => cur-props => (((quote version-set-grain) (quote (#:argument w)) (quote ("detailed"))) ((quote version-set-grain) #:arguments (quote (w))) ((quote version-set-grain) #:check-mark (list "*" version-test-grain?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set versioning grain.") (tm-define-overloaded (version-set-grain w) (set-preference "versioning grain" w) (reactualize-differences)))
   => ((quote version-set-grain) #:synopsis (quote ("Set versioning grain.")))
 => cons <> cur-props
   => cur-props => (((quote version-set-grain) #:synopsis (quote ("Set versioning grain."))) ((quote version-set-grain) (quote (#:argument w)) (quote ("detailed"))) ((quote version-set-grain) #:arguments (quote (w))) ((quote version-set-grain) #:check-mark (list "*" version-test-grain?)))

(property-set! var prop what conds*)
  <= (version-set-grain #:synopsis ("Set versioning grain.") ())

(property-set! var prop what conds*)
  <= (version-set-grain (#:argument w) ("detailed") ())

(property-set! var prop what conds*)
  <= (version-set-grain #:arguments (w) ())

(property-set! var prop what conds*)
  <= (version-set-grain #:check-mark ("*" #<procedure version-test-grain? (w)>) ())

  (define-option-require opt decl)
    <= (((and (tree-is-buffer? t) (in-versioning?))) (tm-define-overloaded (kbd-control-enter t shift?) (version-retain (quote current))))
    => (define-option-match opt decl) <= ((lambda (t shift?) (and (tree-is-buffer? t) (in-versioning?))) (tm-define-overloaded (kbd-control-enter t shift?) (version-retain (quote current))))

(property var prop)
  <= (interactive-print-buffer #:check-mark) => #f

(property var prop)
  <= (interactive-print-buffer #:interactive) => (#t)

(property var prop)
  <= (open-preferences #:check-mark) => #f

(property var prop)
  <= (open-preferences #:interactive) => #f

(property var prop)
  <= (clipboard-cut #:check-mark) => #f

(property var prop)
  <= (clipboard-cut #:interactive) => #f

(property var prop)
  <= (clipboard-copy #:check-mark) => #f

(property var prop)
  <= (clipboard-copy #:interactive) => #f

(property var prop)
  <= (clipboard-paste #:check-mark) => #f

(property var prop)
  <= (clipboard-paste #:interactive) => #f

(property var prop)
  <= (interactive-search #:check-mark) => #f

(property var prop)
  <= (interactive-search #:interactive) => #f

(property var prop)
  <= (interactive-replace #:check-mark) => #f

(property var prop)
  <= (interactive-replace #:interactive) => #f

(property var prop)
  <= (spell-start #:check-mark) => #f

(property var prop)
  <= (spell-start #:interactive) => #f

(property var prop)
  <= (undo #:check-mark) => #f

(property var prop)
  <= (undo #:interactive) => #f

(property var prop)
  <= (redo #:check-mark) => #f

(property var prop)
  <= (redo #:interactive) => #f

(property var prop)
  <= (cursor-history-backward #:check-mark) => #f

(property var prop)
  <= (cursor-history-backward #:interactive) => #f

(property var prop)
  <= (revert-buffer #:check-mark) => #f

(property var prop)
  <= (revert-buffer #:interactive) => #f

(property var prop)
  <= (cursor-history-forward #:check-mark) => #f

(property var prop)
  <= (cursor-history-forward #:interactive) => #f

(property var prop)
  <= (dynamic-operate-on-buffer #:check-mark) => #f

(property var prop)
  <= (dynamic-operate-on-buffer #:interactive) => #f

(property var prop)
  <= (dynamic-traverse-buffer #:check-mark) => #f

(property var prop)
  <= (dynamic-traverse-buffer #:interactive) => #f

(property var prop)
  <= (dynamic-traverse-buffer #:check-mark) => #f

(property var prop)
  <= (dynamic-traverse-buffer #:interactive) => #f

(property var prop)
  <= (dynamic-operate-on-buffer #:check-mark) => #f

(property var prop)
  <= (dynamic-operate-on-buffer #:interactive) => #f

  (define-option-require opt decl)
    <= (((marginal-note-context? t)) (tm-define-overloaded (focus-float-menu t) (menu-dynamic --- (link position-marginal-note-menu) ---)))
    => (define-option-match opt decl) <= ((lambda (t) (marginal-note-context? t)) (tm-define-overloaded (focus-float-menu t) (menu-dynamic --- (link position-marginal-note-menu) ---)))

  (define-option-require opt decl)
    <= (((float-context? t)) (tm-define-overloaded (focus-float-menu t) (menu-dynamic (-> "Allowed positions" (link float-menu)) (if (cursor-at-anchor?) ("Go to float" (go-to-float))) (if (not (cursor-at-anchor?)) ("Go to anchor" (go-to-anchor))))))
    => (define-option-match opt decl) <= ((lambda (t) (float-context? t)) (tm-define-overloaded (focus-float-menu t) (menu-dynamic (-> "Allowed positions" (link float-menu)) (if (cursor-at-anchor?) ("Go to float" (go-to-float))) (if (not (cursor-at-anchor?)) ("Go to anchor" (go-to-anchor))))))

  (define-option-require opt decl)
    <= (((phantom-float-context? t)) (tm-define-overloaded (focus-float-menu t) (menu-dynamic (-> "Allowed positions" (link float-menu)))))
    => (define-option-match opt decl) <= ((lambda (t) (phantom-float-context? t)) (tm-define-overloaded (focus-float-menu t) (menu-dynamic (-> "Allowed positions" (link float-menu)))))

  (define-option-require opt decl)
    <= (((floatable-context? t)) (tm-define-overloaded (focus-float-menu t) (menu-dynamic ("Make floating" (turn-floating t)))))
    => (define-option-match opt decl) <= ((lambda (t) (floatable-context? t)) (tm-define-overloaded (focus-float-menu t) (menu-dynamic ("Make floating" (turn-floating t)))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote footnote))) (tm-define-overloaded (focus-float-menu t) (menu-dynamic (if (cursor-at-anchor?) ("Go to footnote" (go-to-float))) (if (not (cursor-at-anchor?)) ("Go to anchor" (go-to-anchor))))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote footnote))) (tm-define-overloaded (focus-float-menu t) (menu-dynamic (if (cursor-at-anchor?) ("Go to footnote" (go-to-float))) (if (not (cursor-at-anchor?)) ("Go to anchor" (go-to-anchor))))))

  (define-option-require opt decl)
    <= (((balloon-context? t)) (tm-define-overloaded (focus-float-menu t) (menu-dynamic --- (link position-balloon-menu) ---)))
    => (define-option-match opt decl) <= ((lambda (t) (balloon-context? t)) (tm-define-overloaded (focus-float-menu t) (menu-dynamic --- (link position-balloon-menu) ---)))

  (define-option-require opt decl)
    <= (((document-propose-title?)) (tm-define-overloaded (focus-document-extra-menu t) (menu-dynamic ("Title" (make-doc-data)))))
    => (define-option-match opt decl) <= ((lambda (t) (document-propose-title?)) (tm-define-overloaded (focus-document-extra-menu t) (menu-dynamic ("Title" (make-doc-data)))))

  (define-option-require opt decl)
    <= (((document-propose-title?)) (tm-define-overloaded (focus-document-extra-icons t) (menu-dynamic (minibar ((balloon "Title" "Insert title") (make-doc-data))))))
    => (define-option-match opt decl) <= ((lambda (t) (document-propose-title?)) (tm-define-overloaded (focus-document-extra-icons t) (menu-dynamic (minibar ((balloon "Title" "Insert title") (make-doc-data))))))

  (define-option-require opt decl)
    <= (((document-propose-abstract?)) (tm-define-overloaded (focus-document-extra-menu t) (menu-dynamic ("Abstract" (make-abstract-data)))))
    => (define-option-match opt decl) <= ((lambda (t) (document-propose-abstract?)) (tm-define-overloaded (focus-document-extra-menu t) (menu-dynamic ("Abstract" (make-abstract-data)))))

  (define-option-require opt decl)
    <= (((document-propose-abstract?)) (tm-define-overloaded (focus-document-extra-icons t) (menu-dynamic (minibar ((balloon "Abstract" "Insert abstract") (make-abstract-data))))))
    => (define-option-match opt decl) <= ((lambda (t) (document-propose-abstract?)) (tm-define-overloaded (focus-document-extra-icons t) (menu-dynamic (minibar ((balloon "Abstract" "Insert abstract") (make-abstract-data))))))

  (define-option-require opt decl)
    <= (((doc-title-context? t)) (tm-define-overloaded (focus-can-move? t) #f))
    => (define-option-match opt decl) <= ((lambda (t) (doc-title-context? t)) (tm-define-overloaded (focus-can-move? t) #f))

  (define-option-require opt decl)
    <= (((doc-title-context? t)) (tm-define-overloaded (focus-ancestor-menu t) (menu-dynamic (group "Title") (link focus-title-menu) --- (group "Hidden") (link focus-title-hidden-menu) ---)))
    => (define-option-match opt decl) <= ((lambda (t) (doc-title-context? t)) (tm-define-overloaded (focus-ancestor-menu t) (menu-dynamic (group "Title") (link focus-title-menu) --- (group "Hidden") (link focus-title-hidden-menu) ---)))

  (define-option-require opt decl)
    <= (((doc-title-context? t)) (tm-define-overloaded (focus-ancestor-icons t) (menu-dynamic (minibar (dynamic (focus-title-icons))) //)))
    => (define-option-match opt decl) <= ((lambda (t) (doc-title-context? t)) (tm-define-overloaded (focus-ancestor-icons t) (menu-dynamic (minibar (dynamic (focus-title-icons))) //)))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (doc-note author-note)))) (tm-define-overloaded (focus-has-preferences? t) #f))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (doc-note author-note)))) (tm-define-overloaded (focus-has-preferences? t) #f))

  (define-option-require opt decl)
    <= (((and (in? l (quote (author-email author-homepage author-misc))) (or (test-doc-title-clustering? "cluster-all") (test-doc-title-clustering? "cluster-by-affiliation")))) (tm-define-overloaded (focus-tag-edit-menu l) (menu-dynamic (with l* (symbol-append l (quote -note)) (dynamic (focus-tag-edit-menu l*))))))
    => (define-option-match opt decl) <= ((lambda (l) (and (in? l (quote (author-email author-homepage author-misc))) (or (test-doc-title-clustering? "cluster-all") (test-doc-title-clustering? "cluster-by-affiliation")))) (tm-define-overloaded (focus-tag-edit-menu l) (menu-dynamic (with l* (symbol-append l (quote -note)) (dynamic (focus-tag-edit-menu l*))))))

  (define-option-require opt decl)
    <= (((doc-author-context? t)) (tm-define-overloaded (focus-can-move? t) #f))
    => (define-option-match opt decl) <= ((lambda (t) (doc-author-context? t)) (tm-define-overloaded (focus-can-move? t) #f))

  (define-option-require opt decl)
    <= (((doc-author-context? t)) (tm-define-overloaded (focus-ancestor-menu t) (menu-dynamic (group "Title") (link focus-title-menu) --- (group "Hidden") (link focus-title-hidden-menu) --- (group "Author") (link focus-author-menu) ---)))
    => (define-option-match opt decl) <= ((lambda (t) (doc-author-context? t)) (tm-define-overloaded (focus-ancestor-menu t) (menu-dynamic (group "Title") (link focus-title-menu) --- (group "Hidden") (link focus-title-hidden-menu) --- (group "Author") (link focus-author-menu) ---)))

  (define-option-require opt decl)
    <= (((doc-author-context? t)) (tm-define-overloaded (focus-ancestor-icons t) (menu-dynamic (minibar (dynamic (focus-title-icons))) // (minibar (dynamic (focus-author-icons))) //)))
    => (define-option-match opt decl) <= ((lambda (t) (doc-author-context? t)) (tm-define-overloaded (focus-ancestor-icons t) (menu-dynamic (minibar (dynamic (focus-title-icons))) // (minibar (dynamic (focus-author-icons))) //)))

  (define-option-require opt decl)
    <= (((abstract-data-context? t)) (tm-define-overloaded (focus-can-move? t) #f))
    => (define-option-match opt decl) <= ((lambda (t) (abstract-data-context? t)) (tm-define-overloaded (focus-can-move? t) #f))

  (define-option-require opt decl)
    <= (((== l (quote abstract))) (tm-define-overloaded (focus-tag-name l) "Abstract text"))
    => (define-option-match opt decl) <= ((lambda (l) (== l (quote abstract))) (tm-define-overloaded (focus-tag-name l) "Abstract text"))

  (define-option-require opt decl)
    <= (((abstract-data-context? t)) (tm-define-overloaded (focus-ancestor-menu t) (menu-dynamic (group "Abstract") (link focus-abstract-menu) ---)))
    => (define-option-match opt decl) <= ((lambda (t) (abstract-data-context? t)) (tm-define-overloaded (focus-ancestor-menu t) (menu-dynamic (group "Abstract") (link focus-abstract-menu) ---)))

  (define-option-require opt decl)
    <= (((abstract-data-context? t)) (tm-define-overloaded (focus-ancestor-icons t) (menu-dynamic (minibar (dynamic (focus-abstract-icons))) //)))
    => (define-option-match opt decl) <= ((lambda (t) (abstract-data-context? t)) (tm-define-overloaded (focus-ancestor-icons t) (menu-dynamic (minibar (dynamic (focus-abstract-icons))) //)))

  (define-option-require opt decl)
    <= (((and (string-ends? l "-numbered") (in? (string->symbol (string-drop-right l 9)) (section-tag-list)))) (tm-define-overloaded (parameter-show-in-menu? l) #f))
    => (define-option-match opt decl) <= ((lambda (l) (and (string-ends? l "-numbered") (in? (string->symbol (string-drop-right l 9)) (section-tag-list)))) (tm-define-overloaded (parameter-show-in-menu? l) #f))

  (define-option-require opt decl)
    <= (((== l "appendix-prefix")) (tm-define-overloaded (parameter-show-in-menu? l) #f))
    => (define-option-match opt decl) <= ((lambda (l) (== l "appendix-prefix")) (tm-define-overloaded (parameter-show-in-menu? l) #f))

  (define-option-require opt decl)
    <= (((previous-section)) (tm-define-overloaded (focus-document-extra-menu t) (menu-dynamic (-> "Sections" (link focus-section-menu)))))
    => (define-option-match opt decl) <= ((lambda (t) (previous-section)) (tm-define-overloaded (focus-document-extra-menu t) (menu-dynamic (-> "Sections" (link focus-section-menu)))))

  (define-option-require opt decl)
    <= (((previous-section)) (tm-define-overloaded (focus-document-extra-icons t) (menu-dynamic (mini #t (=> (eval (tm/section-get-title-string (previous-section))) (link focus-section-menu))))))
    => (define-option-match opt decl) <= ((lambda (t) (previous-section)) (tm-define-overloaded (focus-document-extra-icons t) (menu-dynamic (mini #t (=> (eval (tm/section-get-title-string (previous-section))) (link focus-section-menu))))))

  (define-option-require opt decl)
    <= (((section-context? t)) (tm-define-overloaded (focus-extra-menu t) (menu-dynamic --- (-> "Go to section" (link focus-section-menu)))))
    => (define-option-match opt decl) <= ((lambda (t) (section-context? t)) (tm-define-overloaded (focus-extra-menu t) (menu-dynamic --- (-> "Go to section" (link focus-section-menu)))))

  (define-option-require opt decl)
    <= (((section-context? t)) (tm-define-overloaded (focus-extra-icons t) (menu-dynamic (mini #t (=> (eval (tm/section-get-title-string t)) (link focus-section-menu))))))
    => (define-option-match opt decl) <= ((lambda (t) (section-context? t)) (tm-define-overloaded (focus-extra-icons t) (menu-dynamic (mini #t (=> (eval (tm/section-get-title-string t)) (link focus-section-menu))))))

  (define-option-require opt decl)
    <= (((and (tree-in? t (quote (bibliography bibliography*))) (== i 1))) (tm-define-overloaded (child-proposals t i) (bib-standard-styles)))
    => (define-option-match opt decl) <= ((lambda (t i) (and (tree-in? t (quote (bibliography bibliography*))) (== i 1))) (tm-define-overloaded (child-proposals t i) (bib-standard-styles)))

  (define-option-require opt decl)
    <= (((in? l (list-tag-list))) (tm-define-overloaded (standard-options l) (list "compact-list")))
    => (define-option-match opt decl) <= ((lambda (l) (in? l (list-tag-list))) (tm-define-overloaded (standard-options l) (list "compact-list")))

  (define-option-require opt decl)
    <= (((or (in? l (enunciation-tag-list)) (in? l (render-enunciation-tag-list)) (in? l (quote (proof render-proof))))) (tm-define-overloaded (standard-options l) (list "number-europe" "number-long-article" "framed-theorems" "hanging-theorems")))
    => (define-option-match opt decl) <= ((lambda (l) (or (in? l (enunciation-tag-list)) (in? l (render-enunciation-tag-list)) (in? l (quote (proof render-proof))))) (tm-define-overloaded (standard-options l) (list "number-europe" "number-long-article" "framed-theorems" "hanging-theorems")))

  (define-option-require opt decl)
    <= (((dueto-supporting-context? t)) (tm-define-overloaded (focus-extra-menu t) (menu-dynamic --- (when (not (dueto-added? t)) ("Due to" (dueto-add t))))))
    => (define-option-match opt decl) <= ((lambda (t) (dueto-supporting-context? t)) (tm-define-overloaded (focus-extra-menu t) (menu-dynamic --- (when (not (dueto-added? t)) ("Due to" (dueto-add t))))))

  (define-option-require opt decl)
    <= (((dueto-supporting-context? t)) (tm-define-overloaded (focus-extra-icons t) (menu-dynamic // (when (not (dueto-added? t)) ("Due to" (dueto-add t))))))
    => (define-option-match opt decl) <= ((lambda (t) (dueto-supporting-context? t)) (tm-define-overloaded (focus-extra-icons t) (menu-dynamic // (when (not (dueto-added? t)) ("Due to" (dueto-add t))))))

  (define-option-require opt decl)
    <= (((in? l (algorithm-tag-list))) (tm-define-overloaded (focus-tag-name l) (with r (algorithm-root l) (with s (upcase-first (tree-name (tree r))) (string-replace s "-" " ")))))
    => (define-option-match opt decl) <= ((lambda (l) (in? l (algorithm-tag-list))) (tm-define-overloaded (focus-tag-name l) (with r (algorithm-root l) (with s (upcase-first (tree-name (tree r))) (string-replace s "-" " ")))))

  (define-option-require opt decl)
    <= (((algorithm-context? t)) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic (when (not (algorithm-named? (focus-tree))) ((check "Numbered" "v" (algorithm-numbered? (focus-tree))) (algorithm-toggle-number (focus-tree)))) ((check "Named" "v" (algorithm-named? (focus-tree))) (algorithm-toggle-name t)) ((check "Specified" "v" (algorithm-specified? (focus-tree))) (algorithm-toggle-specification t)))))
    => (define-option-match opt decl) <= ((lambda (t) (algorithm-context? t)) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic (when (not (algorithm-named? (focus-tree))) ((check "Numbered" "v" (algorithm-numbered? (focus-tree))) (algorithm-toggle-number (focus-tree)))) ((check "Named" "v" (algorithm-named? (focus-tree))) (algorithm-toggle-name t)) ((check "Specified" "v" (algorithm-specified? (focus-tree))) (algorithm-toggle-specification t)))))

  (define-option-require opt decl)
    <= (((algorithm-context? t)) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic (when (not (algorithm-named? (focus-tree))) ((check (balloon (icon "tm_numbered.xpm") "Toggle numbering") "v" (algorithm-numbered? (focus-tree))) (algorithm-toggle-number (focus-tree)))) ((check (balloon (icon "tm_small_textual.xpm") "Toggle name") "v" (algorithm-named? (focus-tree))) (algorithm-toggle-name t)) ((check (balloon (icon "tm_specified.xpm") "Toggle specification") "v" (algorithm-specified? (focus-tree))) (algorithm-toggle-specification t)))))
    => (define-option-match opt decl) <= ((lambda (t) (algorithm-context? t)) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic (when (not (algorithm-named? (focus-tree))) ((check (balloon (icon "tm_numbered.xpm") "Toggle numbering") "v" (algorithm-numbered? (focus-tree))) (algorithm-toggle-number (focus-tree)))) ((check (balloon (icon "tm_small_textual.xpm") "Toggle name") "v" (algorithm-named? (focus-tree))) (algorithm-toggle-name t)) ((check (balloon (icon "tm_specified.xpm") "Toggle specification") "v" (algorithm-specified? (focus-tree))) (algorithm-toggle-specification t)))))

  (define-option-require opt decl)
    <= (((in? l (algorithm-tag-list))) (tm-define-overloaded (standard-options l) (list "centered-program" "framed-program")))
    => (define-option-match opt decl) <= ((lambda (l) (in? l (algorithm-tag-list))) (tm-define-overloaded (standard-options l) (list "centered-program" "framed-program")))

  (define-option-require opt decl)
    <= (((marginal-note-context? t)) (tm-define-overloaded (focus-float-icons t) (menu-dynamic (=> (balloon (icon "tm_position_float.xpm") "Position of marginal note") (link position-marginal-note-menu)))))
    => (define-option-match opt decl) <= ((lambda (t) (marginal-note-context? t)) (tm-define-overloaded (focus-float-icons t) (menu-dynamic (=> (balloon (icon "tm_position_float.xpm") "Position of marginal note") (link position-marginal-note-menu)))))

  (define-option-require opt decl)
    <= (((float-context? t)) (tm-define-overloaded (focus-float-icons t) (menu-dynamic (=> (balloon (icon "tm_position_float.xpm") "Allowed positions of floating object") (link float-menu)) ((balloon (icon "tm_anchor.xpm") "Go to anchor or float") (cursor-toggle-anchor)))))
    => (define-option-match opt decl) <= ((lambda (t) (float-context? t)) (tm-define-overloaded (focus-float-icons t) (menu-dynamic (=> (balloon (icon "tm_position_float.xpm") "Allowed positions of floating object") (link float-menu)) ((balloon (icon "tm_anchor.xpm") "Go to anchor or float") (cursor-toggle-anchor)))))

  (define-option-require opt decl)
    <= (((phantom-float-context? t)) (tm-define-overloaded (focus-float-icons t) (menu-dynamic (=> (balloon (icon "tm_position_float.xpm") "Allowed positions of floating object") (link float-menu)))))
    => (define-option-match opt decl) <= ((lambda (t) (phantom-float-context? t)) (tm-define-overloaded (focus-float-icons t) (menu-dynamic (=> (balloon (icon "tm_position_float.xpm") "Allowed positions of floating object") (link float-menu)))))

  (define-option-require opt decl)
    <= (((floatable-context? t)) (tm-define-overloaded (focus-float-icons t) (menu-dynamic ((balloon (icon "tm_position_float.xpm") "Let the environment float") (turn-floating (tree-innermost floatable-context?))))))
    => (define-option-match opt decl) <= ((lambda (t) (floatable-context? t)) (tm-define-overloaded (focus-float-icons t) (menu-dynamic ((balloon (icon "tm_position_float.xpm") "Let the environment float") (turn-floating (tree-innermost floatable-context?))))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote footnote))) (tm-define-overloaded (focus-float-icons t) (menu-dynamic ((balloon (icon "tm_anchor.xpm") "Go to anchor or footnote") (cursor-toggle-anchor)))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote footnote))) (tm-define-overloaded (focus-float-icons t) (menu-dynamic ((balloon (icon "tm_anchor.xpm") "Go to anchor or footnote") (cursor-toggle-anchor)))))

  (define-option-require opt decl)
    <= (((balloon-context? t)) (tm-define-overloaded (focus-float-icons t) (menu-dynamic (=> (balloon (icon "tm_position_float.xpm") "Alignment of balloon") (link position-balloon-menu)))))
    => (define-option-match opt decl) <= ((lambda (t) (balloon-context? t)) (tm-define-overloaded (focus-float-icons t) (menu-dynamic (=> (balloon (icon "tm_position_float.xpm") "Alignment of balloon") (link position-balloon-menu)))))

  (define-option-require opt decl)
    <= (((in? l (numbered-unnumbered-append (append (small-figure-tag-list) (big-figure-tag-list))))) (tm-define-overloaded (standard-options l) (list "captions-above")))
    => (define-option-match opt decl) <= ((lambda (l) (in? l (numbered-unnumbered-append (append (small-figure-tag-list) (big-figure-tag-list))))) (tm-define-overloaded (standard-options l) (list "captions-above")))

  (define-option-require opt decl)
    <= (((titled-context? t)) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic ((check "Named" "v" (titled-named? (focus-tree))) (titled-toggle-name t)) (dynamic (former t)))))
    => (define-option-match opt decl) <= ((lambda (t) (titled-context? t)) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic ((check "Named" "v" (titled-named? (focus-tree))) (titled-toggle-name t)) (dynamic (former t)))))

  (define-option-require opt decl)
    <= (((titled-context? t)) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic ((check (balloon (icon "tm_small_textual.xpm") "Toggle name") "v" (titled-named? (focus-tree))) (titled-toggle-name t)) (dynamic (former t)))))
    => (define-option-match opt decl) <= ((lambda (t) (titled-context? t)) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic ((check (balloon (icon "tm_small_textual.xpm") "Toggle name") "v" (titled-named? (focus-tree))) (titled-toggle-name t)) (dynamic (former t)))))

  (define-option-require opt decl)
    <= (((or (frame-context? t) (frame-titled-context? t))) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic ((check "Named" "v" (frame-titled? (focus-tree))) (frame-toggle-title t)) (dynamic (former t)))))
    => (define-option-match opt decl) <= ((lambda (t) (or (frame-context? t) (frame-titled-context? t))) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic ((check "Named" "v" (frame-titled? (focus-tree))) (frame-toggle-title t)) (dynamic (former t)))))

  (define-option-require opt decl)
    <= (((or (frame-context? t) (frame-titled-context? t))) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic ((check (balloon (icon "tm_small_textual.xpm") "Toggle name") "v" (frame-titled? (focus-tree))) (frame-toggle-title t)) (dynamic (former t)))))
    => (define-option-match opt decl) <= ((lambda (t) (or (frame-context? t) (frame-titled-context? t))) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic ((check (balloon (icon "tm_small_textual.xpm") "Toggle name") "v" (frame-titled? (focus-tree))) (frame-toggle-title t)) (dynamic (former t)))))

  (define-option-require opt decl)
    <= (((automatic-section-context? t)) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic (dynamic (former t)) ("Rename" (interactive automatic-section-rename)))))
    => (define-option-match opt decl) <= ((lambda (t) (automatic-section-context? t)) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic (dynamic (former t)) ("Rename" (interactive automatic-section-rename)))))

  (define-option-require opt decl)
    <= (((automatic-section-context? t)) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic (dynamic (former t)) ((balloon (icon "tm_small_textual.xpm") "Rename section") (interactive automatic-section-rename)))))
    => (define-option-match opt decl) <= ((lambda (t) (automatic-section-context? t)) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic (dynamic (former t)) ((balloon (icon "tm_small_textual.xpm") "Rename section") (interactive automatic-section-rename)))))

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (focus-help #:check-mark) => #f

(property var prop)
  <= (focus-help #:interactive) => #f

(property var prop)
  <= (make-doc-data #:check-mark) => #f

(property var prop)
  <= (make-doc-data #:interactive) => #f

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" test-bottom-bar?) (tm-define-overloaded (toggle-bottom-bar which) (set-bottom-bar which (not (test-bottom-bar? which)))))
    => ((quote toggle-bottom-bar) #:check-mark (list "*" test-bottom-bar?))
 => cons <> cur-props
    => cur-props => (((quote toggle-bottom-bar) #:check-mark (list "*" test-bottom-bar?)))

(property-set! var prop what conds*)
  <= (toggle-bottom-bar #:check-mark ("*" #<procedure #f (which)>) ())

  (define-option-require opt decl)
    <= (((== tag (quote point))) (tm-define-overloaded (graphics-attributes tag) (append (graphics-common-attributes) (quote ("fill-color" "point-style" "point-size" "point-border")))))
    => (define-option-match opt decl) <= ((lambda (tag) (== tag (quote point))) (tm-define-overloaded (graphics-attributes tag) (append (graphics-common-attributes) (quote ("fill-color" "point-style" "point-size" "point-border")))))

  (define-option-require opt decl)
    <= (((or (graphical-curve-tag? tag) (graphical-user-tag? tag))) (tm-define-overloaded (graphics-attributes tag) (append (graphics-common-attributes) (quote ("fill-color" "line-width" "line-join" "line-caps" "line-effects" "line-portion" "dash-style" "dash-style-unit" "arrow-begin" "arrow-end" "arrow-length" "arrow-height")))))
    => (define-option-match opt decl) <= ((lambda (tag) (or (graphical-curve-tag? tag) (graphical-user-tag? tag))) (tm-define-overloaded (graphics-attributes tag) (append (graphics-common-attributes) (quote ("fill-color" "line-width" "line-join" "line-caps" "line-effects" "line-portion" "dash-style" "dash-style-unit" "arrow-begin" "arrow-end" "arrow-length" "arrow-height")))))

  (define-option-require opt decl)
    <= (((graphical-text-tag? tag)) (tm-define-overloaded (graphics-attributes tag) (append (graphics-common-attributes) (quote ("text-at-halign" "text-at-valign" "text-at-margin")))))
    => (define-option-match opt decl) <= ((lambda (tag) (graphical-text-tag? tag)) (tm-define-overloaded (graphics-attributes tag) (append (graphics-common-attributes) (quote ("text-at-halign" "text-at-valign" "text-at-margin")))))

  (define-option-require opt decl)
    <= (((graphical-long-text-tag? tag)) (tm-define-overloaded (graphics-attributes tag) (append (graphics-common-attributes) (quote ("text-at-halign" "doc-at-valign" "text-at-margin" "fill-color" "doc-at-width" "doc-at-hmode" "doc-at-ppsep" "doc-at-border" "doc-at-padding")))))
    => (define-option-match opt decl) <= ((lambda (tag) (graphical-long-text-tag? tag)) (tm-define-overloaded (graphics-attributes tag) (append (graphics-common-attributes) (quote ("text-at-halign" "doc-at-valign" "text-at-margin" "fill-color" "doc-at-width" "doc-at-hmode" "doc-at-ppsep" "doc-at-border" "doc-at-padding")))))

  (define-option-require opt decl)
    <= (((graphical-group-tag? tag)) (tm-define-overloaded (graphics-attributes tag) (graphics-all-attributes)))
    => (define-option-match opt decl) <= ((lambda (tag) (graphical-group-tag? tag)) (tm-define-overloaded (graphics-attributes tag) (graphics-all-attributes)))

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" graphics-test-anim-type?) (tm-define-overloaded (graphics-set-anim-type val) (noop)))
    => ((quote graphics-set-anim-type) #:check-mark (list "*" graphics-test-anim-type?))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-anim-type) #:check-mark (list "*" graphics-test-anim-type?)))

(property-set! var prop what conds*)
  <= (graphics-set-anim-type #:check-mark ("*" #<procedure graphics-test-anim-type? (val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" inside-draw-over?) (tm-define-overloaded (graphics-toggle-over-under) (with-innermost t graphical-over-under-context? (cond ((tree-is? t (quote draw-over)) (tree-assign-node! t (quote draw-under)) (tree-go-to t 0 #:end)) ((tree-is? t (quote draw-under)) (tree-assign-node! t (quote draw-over)) (if (tree-is? (tree-ref t 1) (quote with)) (tree-go-to t 1 (- (tree-arity (tree-ref t 1)) 1) #:end) (tree-go-to t 1 #:end)))))))
    => ((quote graphics-toggle-over-under) #:check-mark (list "*" inside-draw-over?))
 => cons <> cur-props
    => cur-props => (((quote graphics-toggle-over-under) #:check-mark (list "*" inside-draw-over?)))

(property-set! var prop what conds*)
  <= (graphics-toggle-over-under #:check-mark ("*" #<procedure inside-draw-over? ()>) ())

  (define-option-argument opt decl)
    <= ((w "Width of overlapping border") (tm-define-overloaded (graphics-set-overlap w) (when (inside-graphical-over-under?) (with-innermost t graphical-over-under-context? (tree-set t 2 w)))))
    => cons <> cur-props <= ((quote graphics-set-overlap) #:arguments (quote (w)))
    => cons <> cur-props <= ((quote graphics-set-overlap) (quote (#:argument w)) (quote ("Width of overlapping border")))
    => cur-props => (((quote graphics-set-overlap) (quote (#:argument w)) (quote ("Width of overlapping border"))) ((quote graphics-set-overlap) #:arguments (quote (w))))

(property-set! var prop what conds*)
  <= (graphics-set-overlap (#:argument w) ("Width of overlapping border") ())

(property-set! var prop what conds*)
  <= (graphics-set-overlap #:arguments (w) ())

  (define-option-argument opt decl)
    <= ((w "Width of the graphics") (tm-define-overloaded (graphics-set-width w) (let* ((geo (graphics-geometry)) (align (if (>= (length geo) 5) (cAr geo) "center")) (new-geo (quasiquote (tuple "geometry" (unquote w) (unquote (cadddr geo)) (unquote align))))) (graphics-set-property "gr-geometry" new-geo))))
    => cons <> cur-props <= ((quote graphics-set-width) #:arguments (quote (w)))
    => cons <> cur-props <= ((quote graphics-set-width) (quote (#:argument w)) (quote ("Width of the graphics")))
    => cur-props => (((quote graphics-set-width) (quote (#:argument w)) (quote ("Width of the graphics"))) ((quote graphics-set-width) #:arguments (quote (w))))

(property-set! var prop what conds*)
  <= (graphics-set-width (#:argument w) ("Width of the graphics") ())

(property-set! var prop what conds*)
  <= (graphics-set-width #:arguments (w) ())

  (define-option-argument opt decl)
    <= ((h "Height of the graphics") (tm-define-overloaded (graphics-set-height h) (let* ((geo (graphics-geometry)) (align (if (>= (length geo) 5) (cAr geo) "center")) (new-geo (quasiquote (tuple "geometry" (unquote (caddr geo)) (unquote h) (unquote align))))) (graphics-set-property "gr-geometry" new-geo))))
    => cons <> cur-props <= ((quote graphics-set-height) #:arguments (quote (h)))
    => cons <> cur-props <= ((quote graphics-set-height) (quote (#:argument h)) (quote ("Height of the graphics")))
    => cur-props => (((quote graphics-set-height) (quote (#:argument h)) (quote ("Height of the graphics"))) ((quote graphics-set-height) #:arguments (quote (h))))

(property-set! var prop what conds*)
  <= (graphics-set-height (#:argument h) ("Height of the graphics") ())

(property-set! var prop what conds*)
  <= (graphics-set-height #:arguments (h) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" geo-valign-has-value?) (tm-define-overloaded (graphics-set-geo-valign a) (let* ((geo (graphics-geometry)) (new-geo (quasiquote (tuple "geometry" (unquote (caddr geo)) (unquote (cadddr geo)) (unquote a))))) (graphics-set-property "gr-geometry" new-geo))))
    => ((quote graphics-set-geo-valign) #:check-mark (list "*" geo-valign-has-value?))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-geo-valign) #:check-mark (list "*" geo-valign-has-value?)))

  (define-option-argument opt decl)
    <= ((a "Alignment of the graphics") (tm-define-overloaded (graphics-set-geo-valign a) (let* ((geo (graphics-geometry)) (new-geo (quasiquote (tuple "geometry" (unquote (caddr geo)) (unquote (cadddr geo)) (unquote a))))) (graphics-set-property "gr-geometry" new-geo))))
    => cons <> cur-props <= ((quote graphics-set-geo-valign) #:arguments (quote (a)))
    => cons <> cur-props <= ((quote graphics-set-geo-valign) (quote (#:argument a)) (quote ("Alignment of the graphics")))
    => cur-props => (((quote graphics-set-geo-valign) (quote (#:argument a)) (quote ("Alignment of the graphics"))) ((quote graphics-set-geo-valign) #:arguments (quote (a))) ((quote graphics-set-geo-valign) #:check-mark (list "*" geo-valign-has-value?)))

(property-set! var prop what conds*)
  <= (graphics-set-geo-valign (#:argument a) ("Alignment of the graphics") ())

(property-set! var prop what conds*)
  <= (graphics-set-geo-valign #:arguments (a) ())

(property-set! var prop what conds*)
  <= (graphics-set-geo-valign #:check-mark ("*" #<procedure geo-valign-has-value? (val)>) ())

  (define-option-argument opt decl)
    <= ((h "Height of the graphics") (tm-define-overloaded (graphics-set-extents w h) (let* ((geo (graphics-geometry)) (align (if (>= (length geo) 5) (cAr geo) "center")) (new-geo (quasiquote (tuple "geometry" (unquote w) (unquote h) (unquote align))))) (graphics-set-property "gr-geometry" new-geo))))
    => cons <> cur-props <= ((quote graphics-set-extents) #:arguments (quote (w h)))
    => cons <> cur-props <= ((quote graphics-set-extents) (quote (#:argument h)) (quote ("Height of the graphics")))
    => cur-props => (((quote graphics-set-extents) (quote (#:argument h)) (quote ("Height of the graphics"))) ((quote graphics-set-extents) #:arguments (quote (w h))))

  (define-option-argument opt decl)
    <= ((w "Width of the graphics") (tm-define-overloaded (graphics-set-extents w h) (let* ((geo (graphics-geometry)) (align (if (>= (length geo) 5) (cAr geo) "center")) (new-geo (quasiquote (tuple "geometry" (unquote w) (unquote h) (unquote align))))) (graphics-set-property "gr-geometry" new-geo))))
    => cons <> cur-props <= ((quote graphics-set-extents) #:arguments (quote (w h)))
    => cons <> cur-props <= ((quote graphics-set-extents) (quote (#:argument w)) (quote ("Width of the graphics")))
    => cur-props => (((quote graphics-set-extents) (quote (#:argument w)) (quote ("Width of the graphics"))) ((quote graphics-set-extents) #:arguments (quote (w h))) ((quote graphics-set-extents) (quote (#:argument h)) (quote ("Height of the graphics"))) ((quote graphics-set-extents) #:arguments (quote (w h))))

(property-set! var prop what conds*)
  <= (graphics-set-extents (#:argument w) ("Width of the graphics") ())

(property-set! var prop what conds*)
  <= (graphics-set-extents #:arguments (w h) ())

(property-set! var prop what conds*)
  <= (graphics-set-extents (#:argument h) ("Height of the graphics") ())

(property-set! var prop what conds*)
  <= (graphics-set-extents #:arguments (w h) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" graphics-unit-has-value?) (tm-define-overloaded (graphics-set-unit u) (with frame (graphics-cartesian-frame) (with new-frame (quasiquote (tuple "scale" (unquote u) (unquote (cAr frame)))) (graphics-set-property "gr-frame" new-frame)))))
    => ((quote graphics-set-unit) #:check-mark (list "*" graphics-unit-has-value?))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-unit) #:check-mark (list "*" graphics-unit-has-value?)))

  (define-option-argument opt decl)
    <= ((u "Graphical unit") (tm-define-overloaded (graphics-set-unit u) (with frame (graphics-cartesian-frame) (with new-frame (quasiquote (tuple "scale" (unquote u) (unquote (cAr frame)))) (graphics-set-property "gr-frame" new-frame)))))
    => cons <> cur-props <= ((quote graphics-set-unit) #:arguments (quote (u)))
    => cons <> cur-props <= ((quote graphics-set-unit) (quote (#:argument u)) (quote ("Graphical unit")))
    => cur-props => (((quote graphics-set-unit) (quote (#:argument u)) (quote ("Graphical unit"))) ((quote graphics-set-unit) #:arguments (quote (u))) ((quote graphics-set-unit) #:check-mark (list "*" graphics-unit-has-value?)))

(property-set! var prop what conds*)
  <= (graphics-set-unit (#:argument u) ("Graphical unit") ())

(property-set! var prop what conds*)
  <= (graphics-set-unit #:arguments (u) ())

(property-set! var prop what conds*)
  <= (graphics-set-unit #:check-mark ("*" #<procedure graphics-unit-has-value? (val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" graphics-origin-has-value?) (tm-define-overloaded (graphics-set-origin x y) (with frame (graphics-cartesian-frame) (with new-frame (append (cDr frame) (quasiquote ((tuple (unquote x) (unquote y))))) (graphics-set-property "gr-frame" new-frame)))))
    => ((quote graphics-set-origin) #:check-mark (list "*" graphics-origin-has-value?))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-origin) #:check-mark (list "*" graphics-origin-has-value?)))

  (define-option-argument opt decl)
    <= ((y "Origin's y-coordinate") (tm-define-overloaded (graphics-set-origin x y) (with frame (graphics-cartesian-frame) (with new-frame (append (cDr frame) (quasiquote ((tuple (unquote x) (unquote y))))) (graphics-set-property "gr-frame" new-frame)))))
    => cons <> cur-props <= ((quote graphics-set-origin) #:arguments (quote (x y)))
    => cons <> cur-props <= ((quote graphics-set-origin) (quote (#:argument y)) (quote ("Origin's y-coordinate")))
    => cur-props => (((quote graphics-set-origin) (quote (#:argument y)) (quote ("Origin's y-coordinate"))) ((quote graphics-set-origin) #:arguments (quote (x y))) ((quote graphics-set-origin) #:check-mark (list "*" graphics-origin-has-value?)))

  (define-option-argument opt decl)
    <= ((x "Origin's x-coordinate") (tm-define-overloaded (graphics-set-origin x y) (with frame (graphics-cartesian-frame) (with new-frame (append (cDr frame) (quasiquote ((tuple (unquote x) (unquote y))))) (graphics-set-property "gr-frame" new-frame)))))
    => cons <> cur-props <= ((quote graphics-set-origin) #:arguments (quote (x y)))
    => cons <> cur-props <= ((quote graphics-set-origin) (quote (#:argument x)) (quote ("Origin's x-coordinate")))
    => cur-props => (((quote graphics-set-origin) (quote (#:argument x)) (quote ("Origin's x-coordinate"))) ((quote graphics-set-origin) #:arguments (quote (x y))) ((quote graphics-set-origin) (quote (#:argument y)) (quote ("Origin's y-coordinate"))) ((quote graphics-set-origin) #:arguments (quote (x y))) ((quote graphics-set-origin) #:check-mark (list "*" graphics-origin-has-value?)))

(property-set! var prop what conds*)
  <= (graphics-set-origin (#:argument x) ("Origin's x-coordinate") ())

(property-set! var prop what conds*)
  <= (graphics-set-origin #:arguments (x y) ())

(property-set! var prop what conds*)
  <= (graphics-set-origin (#:argument y) ("Origin's y-coordinate") ())

(property-set! var prop what conds*)
  <= (graphics-set-origin #:arguments (x y) ())

(property-set! var prop what conds*)
  <= (graphics-set-origin #:check-mark ("*" #<procedure graphics-origin-has-value? (x y)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" graphics-auto-crop?) (tm-define-overloaded (graphics-toggle-auto-crop) (with new (if (graphics-auto-crop?) "false" "true") (graphics-set-property "gr-auto-crop" new))))
    => ((quote graphics-toggle-auto-crop) #:check-mark (list "v" graphics-auto-crop?))
 => cons <> cur-props
    => cur-props => (((quote graphics-toggle-auto-crop) #:check-mark (list "v" graphics-auto-crop?)))

(property-set! var prop what conds*)
  <= (graphics-toggle-auto-crop #:check-mark ("v" #<procedure graphics-auto-crop? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" graphics-has-crop-padding?) (tm-define-overloaded (graphics-set-crop-padding val) (graphics-set-property "gr-crop-padding" val)))
    => ((quote graphics-set-crop-padding) #:check-mark (list "*" graphics-has-crop-padding?))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-crop-padding) #:check-mark (list "*" graphics-has-crop-padding?)))

  (define-option-argument opt decl)
    <= ((val "Padding around cropped graphics") (tm-define-overloaded (graphics-set-crop-padding val) (graphics-set-property "gr-crop-padding" val)))
    => cons <> cur-props <= ((quote graphics-set-crop-padding) #:arguments (quote (val)))
    => cons <> cur-props <= ((quote graphics-set-crop-padding) (quote (#:argument val)) (quote ("Padding around cropped graphics")))
    => cur-props => (((quote graphics-set-crop-padding) (quote (#:argument val)) (quote ("Padding around cropped graphics"))) ((quote graphics-set-crop-padding) #:arguments (quote (val))) ((quote graphics-set-crop-padding) #:check-mark (list "*" graphics-has-crop-padding?)))

(property-set! var prop what conds*)
  <= (graphics-set-crop-padding (#:argument val) ("Padding around cropped graphics") ())

(property-set! var prop what conds*)
  <= (graphics-set-crop-padding #:arguments (val) ())

(property-set! var prop what conds*)
  <= (graphics-set-crop-padding #:check-mark ("*" #<procedure graphics-has-crop-padding? (val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" grids-defaulted?) (tm-define-overloaded (graphics-reset-grids) (graphics-remove-property "gr-grid") (graphics-remove-property "gr-grid-old") (if (grid-as-visual-grid?) (begin (graphics-remove-property "gr-edit-grid") (graphics-remove-property "gr-edit-grid-old") (graphics-remove-property "gr-edit-grid-aspect") (graphics-remove-property "gr-grid-aspect") (graphics-remove-property "gr-grid-aspect-props")))))
    => ((quote graphics-reset-grids) #:check-mark (list "*" grids-defaulted?))
 => cons <> cur-props
    => cur-props => (((quote graphics-reset-grids) #:check-mark (list "*" grids-defaulted?)))

(property-set! var prop what conds*)
  <= (graphics-reset-grids #:check-mark ("*" #<procedure grids-defaulted? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" visual-type-has-value?) (tm-define-overloaded (graphics-set-visual-grid type) (graphics-fetch-grid-vars type #t) (with new-polar? #f (if (and (== type (quote polar)) (!= type (string->symbol graphics-current-type))) (let* ((aspect (graphics-grid-aspect #t)) (nsubds (aspect-ref aspect 3))) (if nsubds (set! nsubds (cadr nsubds))) (set! new-polar? #t) (graphics-set-grid-aspect (quote detailed) nsubds #t) (set! graphics-current-astep (f2s default-polar-astep)))) (set! graphics-current-type (symbol->string type)) (graphics-set-grid #t) (graphics-fetch-grid-vars type #t) (if new-polar? (begin (set! graphics-current-type (symbol->string type)) (set! graphics-current-astep (f2s default-polar-astep)) (update-edit-grid (quote grid-change)))))))
    => ((quote graphics-set-visual-grid) #:check-mark (list "*" visual-type-has-value?))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-visual-grid) #:check-mark (list "*" visual-type-has-value?)))

(property-set! var prop what conds*)
  <= (graphics-set-visual-grid #:check-mark ("*" #<procedure visual-type-has-value? (type)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" edit-type-has-value?) (tm-define-overloaded (graphics-set-edit-grid type) (cond ((or (== type (quote default)) (== type (quote grid-change))) (let* ((aspect (graphics-grid-aspect-props)) (nsubds0 (cadr (list-ref aspect (- (length aspect) 1)))) (nsubds (if (number? nsubds0) nsubds0 (if (string? nsubds0) (string->number nsubds0) #f)))) (if (or (== nsubds #f) (not (grid-aspect-show-subunits?))) (set! nsubds 1)) (if (== type (quote default)) (graphics-fetch-grid-vars (quote cartesian) #t)) (if (!= graphics-current-type "logarithmic") (graphics-set-grid-aspect (quote update) nsubds #f)) (graphics-set-grid #f))) (else (grid-as-visual-grid! #f) (graphics-fetch-grid-vars type #f) (set! graphics-current-type (symbol->string type)) (graphics-set-grid #f)))))
    => ((quote graphics-set-edit-grid) #:check-mark (list "*" edit-type-has-value?))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-edit-grid) #:check-mark (list "*" edit-type-has-value?)))

(property-set! var prop what conds*)
  <= (graphics-set-edit-grid #:check-mark ("*" #<procedure edit-type-has-value? (type)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" grid-step-has-value?) (tm-define-overloaded (graphics-set-grid-step val visual?) (if (not visual?) (grid-as-visual-grid! #f)) (graphics-fetch-grid-vars #f visual?) (set! graphics-current-step val) (graphics-set-grid visual?)))
    => ((quote graphics-set-grid-step) #:check-mark (list "*" grid-step-has-value?))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-grid-step) #:check-mark (list "*" grid-step-has-value?)))

(property-set! var prop what conds*)
  <= (graphics-set-grid-step #:check-mark ("*" #<procedure grid-step-has-value? (val visual?)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" grid-astep-has-value?) (tm-define-overloaded (graphics-set-grid-astep val visual?) (if (not visual?) (grid-as-visual-grid! #f)) (graphics-fetch-grid-vars #f visual?) (set! graphics-current-astep val) (graphics-set-grid visual?)))
    => ((quote graphics-set-grid-astep) #:check-mark (list "*" grid-astep-has-value?))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-grid-astep) #:check-mark (list "*" grid-astep-has-value?)))

(property-set! var prop what conds*)
  <= (graphics-set-grid-astep #:check-mark ("*" #<procedure grid-astep-has-value? (val visual?)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" grid-base-has-value?) (tm-define-overloaded (graphics-set-grid-base val visual?) (if (not visual?) (grid-as-visual-grid! #f)) (graphics-fetch-grid-vars #f visual?) (set! graphics-current-base val) (graphics-set-grid visual?)))
    => ((quote graphics-set-grid-base) #:check-mark (list "*" grid-base-has-value?))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-grid-base) #:check-mark (list "*" grid-base-has-value?)))

(property-set! var prop what conds*)
  <= (graphics-set-grid-base #:check-mark ("*" #<procedure grid-base-has-value? (val visual?)>) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (graphics-interactive-set-grid-center visual?) (interactive (lambda (x y) (graphics-set-grid-center x y visual?)) "Center's x-coordinate" "Center's y-coordinate")))
    => ((quote graphics-interactive-set-grid-center) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote graphics-interactive-set-grid-center) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (graphics-interactive-set-grid-center #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (graphics-interactive-set-grid-step visual?) (interactive (lambda (x) (graphics-set-grid-step x visual?)) "Unit length")))
    => ((quote graphics-interactive-set-grid-step) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote graphics-interactive-set-grid-step) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (graphics-interactive-set-grid-step #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (graphics-interactive-set-grid-astep visual?) (interactive (lambda (x) (graphics-set-grid-astep x visual?)) "Number of angular steps")))
    => ((quote graphics-interactive-set-grid-astep) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote graphics-interactive-set-grid-astep) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (graphics-interactive-set-grid-astep #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (graphics-interactive-set-grid-base visual?) (interactive (lambda (x) (graphics-set-grid-base x visual?)) "Logarithmic base")))
    => ((quote graphics-interactive-set-grid-base) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote graphics-interactive-set-grid-base) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (graphics-interactive-set-grid-base #:interactive (#t) ())

  (define-option-argument opt decl)
    <= ((c2 "Color subdivisions") (tm-define-overloaded (graphics-set-grid-aspect-properties c0 c1 s2 c2) (with aspect (quasiquote (tuple (tuple "axes" (unquote c0)) (tuple "1" (unquote c1)) (tuple (unquote s2) (unquote c2)))) (graphics-set-property "gr-grid-aspect" aspect) (graphics-set-property "gr-grid-aspect-props" aspect)) (update-edit-grid (quote default))))
    => cons <> cur-props <= ((quote graphics-set-grid-aspect-properties) #:arguments (quote (c0 c1 s2 c2)))
    => cons <> cur-props <= ((quote graphics-set-grid-aspect-properties) (quote (#:argument c2)) (quote ("Color subdivisions")))
    => cur-props => (((quote graphics-set-grid-aspect-properties) (quote (#:argument c2)) (quote ("Color subdivisions"))) ((quote graphics-set-grid-aspect-properties) #:arguments (quote (c0 c1 s2 c2))))

  (define-option-argument opt decl)
    <= ((s2 "Subdivisions per unit") (tm-define-overloaded (graphics-set-grid-aspect-properties c0 c1 s2 c2) (with aspect (quasiquote (tuple (tuple "axes" (unquote c0)) (tuple "1" (unquote c1)) (tuple (unquote s2) (unquote c2)))) (graphics-set-property "gr-grid-aspect" aspect) (graphics-set-property "gr-grid-aspect-props" aspect)) (update-edit-grid (quote default))))
    => cons <> cur-props <= ((quote graphics-set-grid-aspect-properties) #:arguments (quote (c0 c1 s2 c2)))
    => cons <> cur-props <= ((quote graphics-set-grid-aspect-properties) (quote (#:argument s2)) (quote ("Subdivisions per unit")))
    => cur-props => (((quote graphics-set-grid-aspect-properties) (quote (#:argument s2)) (quote ("Subdivisions per unit"))) ((quote graphics-set-grid-aspect-properties) #:arguments (quote (c0 c1 s2 c2))) ((quote graphics-set-grid-aspect-properties) (quote (#:argument c2)) (quote ("Color subdivisions"))) ((quote graphics-set-grid-aspect-properties) #:arguments (quote (c0 c1 s2 c2))))

  (define-option-argument opt decl)
    <= ((c1 "Color units") (tm-define-overloaded (graphics-set-grid-aspect-properties c0 c1 s2 c2) (with aspect (quasiquote (tuple (tuple "axes" (unquote c0)) (tuple "1" (unquote c1)) (tuple (unquote s2) (unquote c2)))) (graphics-set-property "gr-grid-aspect" aspect) (graphics-set-property "gr-grid-aspect-props" aspect)) (update-edit-grid (quote default))))
    => cons <> cur-props <= ((quote graphics-set-grid-aspect-properties) #:arguments (quote (c0 c1 s2 c2)))
    => cons <> cur-props <= ((quote graphics-set-grid-aspect-properties) (quote (#:argument c1)) (quote ("Color units")))
    => cur-props => (((quote graphics-set-grid-aspect-properties) (quote (#:argument c1)) (quote ("Color units"))) ((quote graphics-set-grid-aspect-properties) #:arguments (quote (c0 c1 s2 c2))) ((quote graphics-set-grid-aspect-properties) (quote (#:argument s2)) (quote ("Subdivisions per unit"))) ((quote graphics-set-grid-aspect-properties) #:arguments (quote (c0 c1 s2 c2))) ((quote graphics-set-grid-aspect-properties) (quote (#:argument c2)) (quote ("Color subdivisions"))) ((quote graphics-set-grid-aspect-properties) #:arguments (quote (c0 c1 s2 c2))))

  (define-option-argument opt decl)
    <= ((c0 "Color axes") (tm-define-overloaded (graphics-set-grid-aspect-properties c0 c1 s2 c2) (with aspect (quasiquote (tuple (tuple "axes" (unquote c0)) (tuple "1" (unquote c1)) (tuple (unquote s2) (unquote c2)))) (graphics-set-property "gr-grid-aspect" aspect) (graphics-set-property "gr-grid-aspect-props" aspect)) (update-edit-grid (quote default))))
    => cons <> cur-props <= ((quote graphics-set-grid-aspect-properties) #:arguments (quote (c0 c1 s2 c2)))
    => cons <> cur-props <= ((quote graphics-set-grid-aspect-properties) (quote (#:argument c0)) (quote ("Color axes")))
    => cur-props => (((quote graphics-set-grid-aspect-properties) (quote (#:argument c0)) (quote ("Color axes"))) ((quote graphics-set-grid-aspect-properties) #:arguments (quote (c0 c1 s2 c2))) ((quote graphics-set-grid-aspect-properties) (quote (#:argument c1)) (quote ("Color units"))) ((quote graphics-set-grid-aspect-properties) #:arguments (quote (c0 c1 s2 c2))) ((quote graphics-set-grid-aspect-properties) (quote (#:argument s2)) (quote ("Subdivisions per unit"))) ((quote graphics-set-grid-aspect-properties) #:arguments (quote (c0 c1 s2 c2))) ((quote graphics-set-grid-aspect-properties) (quote (#:argument c2)) (quote ("Color subdivisions"))) ((quote graphics-set-grid-aspect-properties) #:arguments (quote (c0 c1 s2 c2))))

(property-set! var prop what conds*)
  <= (graphics-set-grid-aspect-properties (#:argument c0) ("Color axes") ())

(property-set! var prop what conds*)
  <= (graphics-set-grid-aspect-properties #:arguments (c0 c1 s2 c2) ())

(property-set! var prop what conds*)
  <= (graphics-set-grid-aspect-properties (#:argument c1) ("Color units") ())

(property-set! var prop what conds*)
  <= (graphics-set-grid-aspect-properties #:arguments (c0 c1 s2 c2) ())

(property-set! var prop what conds*)
  <= (graphics-set-grid-aspect-properties (#:argument s2) ("Subdivisions per unit") ())

(property-set! var prop what conds*)
  <= (graphics-set-grid-aspect-properties #:arguments (c0 c1 s2 c2) ())

(property-set! var prop what conds*)
  <= (graphics-set-grid-aspect-properties (#:argument c2) ("Color subdivisions") ())

(property-set! var prop what conds*)
  <= (graphics-set-grid-aspect-properties #:arguments (c0 c1 s2 c2) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" nsubd-has-value?) (tm-define-overloaded (graphics-set-grid-aspect type nsubd visual?) (if visual? (with aspect (graphics-grid-aspect-props) (cond ((== type (quote units-only)) (graphics-set-property "gr-grid-aspect-props" aspect) (set-cdr! (cddr aspect) (quote ())) (graphics-set-property "gr-grid-aspect" aspect)) ((== type (quote detailed)) (if nsubd (set-car! (cdr (list-ref aspect 3)) (or (and (string? nsubd) nsubd) (number->string nsubd))) (set-car! (cdr (list-ref aspect 3)) (cadr (list-ref (get-default-val "gr-grid-aspect") 3)))) (graphics-set-property "gr-grid-aspect" aspect) (graphics-set-property "gr-grid-aspect-props" aspect))) (update-edit-grid (quote default))) (with aspect (quasiquote (tuple (tuple "axes" "none") (tuple "1" "none") (tuple (unquote (number->string nsubd)) "none"))) (if (not nsubd) (set-car! (cdr (list-ref aspect 3)) (cadr (list-ref (get-default-val "gr-edit-grid-aspect") 3)))) (graphics-set-property "gr-edit-grid-aspect" aspect) (if (!= type (quote update)) (grid-as-visual-grid! #f))))))
    => ((quote graphics-set-grid-aspect) #:check-mark (list "*" nsubd-has-value?))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-grid-aspect) #:check-mark (list "*" nsubd-has-value?)))

(property-set! var prop what conds*)
  <= (graphics-set-grid-aspect #:check-mark ("*" #<procedure nsubd-has-value? (type nsubd visual?)>) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (graphics-interactive-set-grid-nsubds visual?) (interactive (lambda (x) (graphics-set-grid-aspect (quote detailed) (string->number x) visual?)) "Number of subunit steps")))
    => ((quote graphics-interactive-set-grid-nsubds) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote graphics-interactive-set-grid-nsubds) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (graphics-interactive-set-grid-nsubds #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" grid-color-has-value?) (tm-define-overloaded (graphics-set-grid-color where color) (define i 0) (let* ((i (grid-aspect-ofs where)) (aspect (graphics-grid-aspect #t)) (aspect-props (graphics-grid-aspect-props))) (if i (begin (if (== color "default") (let* ((aspect (get-default-val "gr-grid-aspect")) (ref2 (aspect-ref aspect i))) (set! color (caddr ref2)))) (set-car! (cddr (list-ref aspect-props i)) color) (graphics-set-property "gr-grid-aspect-props" aspect-props) (if (and (pair? aspect) (> (length aspect) 3)) (begin (set-car! (cddr (list-ref aspect i)) color) (graphics-set-property "gr-grid-aspect" aspect))))))))
    => ((quote graphics-set-grid-color) #:check-mark (list "*" grid-color-has-value?))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-grid-color) #:check-mark (list "*" grid-color-has-value?)))

(property-set! var prop what conds*)
  <= (graphics-set-grid-color #:check-mark ("*" #<procedure grid-color-has-value? (where color)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" grid-as-visual-grid?) (tm-define-overloaded (grid-toggle-as-visual-grid) (grid-as-visual-grid! (not (grid-as-visual-grid?))) (update-edit-grid (quote default))))
    => ((quote grid-toggle-as-visual-grid) #:check-mark (list "v" grid-as-visual-grid?))
 => cons <> cur-props
    => cur-props => (((quote grid-toggle-as-visual-grid) #:check-mark (list "v" grid-as-visual-grid?)))

(property-set! var prop what conds*)
  <= (grid-toggle-as-visual-grid #:check-mark ("v" #<procedure grid-as-visual-grid? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" grid-show-subunits?) (tm-define-overloaded (grid-toggle-show-subunits) (if (grid-show-subunits?) (graphics-set-grid-aspect (quote units-only) #f #t) (graphics-set-grid-aspect (quote detailed) #f #t))))
    => ((quote grid-toggle-show-subunits) #:check-mark (list "v" grid-show-subunits?))
 => cons <> cur-props
    => cur-props => (((quote grid-toggle-show-subunits) #:check-mark (list "v" grid-show-subunits?)))

(property-set! var prop what conds*)
  <= (grid-toggle-show-subunits #:check-mark ("v" #<procedure grid-show-subunits? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" graphics-mode-has-value?) (tm-define-overloaded (graphics-set-mode val) (graphics-group-start) (graphics-enter-mode (graphics-mode) val) (graphics-set-property "gr-mode" (quasiquote (tuple (unquote-splicing (map symbol->string val)))))))
    => ((quote graphics-set-mode) #:check-mark (list "v" graphics-mode-has-value?))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-mode) #:check-mark (list "v" graphics-mode-has-value?)))

(property-set! var prop what conds*)
  <= (graphics-set-mode #:check-mark ("v" #<procedure graphics-mode-has-value? (mode)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" graphics-test-proviso?) (tm-define-overloaded (graphics-set-proviso val) (graphics-set-property "gr-proviso" val)))
    => ((quote graphics-set-proviso) #:check-mark (list "*" graphics-test-proviso?))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-proviso) #:check-mark (list "*" graphics-test-proviso?)))

  (define-option-argument opt decl)
    <= ((val "Proviso") (tm-define-overloaded (graphics-set-proviso val) (graphics-set-property "gr-proviso" val)))
    => cons <> cur-props <= ((quote graphics-set-proviso) #:arguments (quote (val)))
    => cons <> cur-props <= ((quote graphics-set-proviso) (quote (#:argument val)) (quote ("Proviso")))
    => cur-props => (((quote graphics-set-proviso) (quote (#:argument val)) (quote ("Proviso"))) ((quote graphics-set-proviso) #:arguments (quote (val))) ((quote graphics-set-proviso) #:check-mark (list "*" graphics-test-proviso?)))

(property-set! var prop what conds*)
  <= (graphics-set-proviso (#:argument val) ("Proviso") ())

(property-set! var prop what conds*)
  <= (graphics-set-proviso #:arguments (val) ())

(property-set! var prop what conds*)
  <= (graphics-set-proviso #:check-mark ("*" #<procedure graphics-test-proviso? (val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" (graphics-test-property? "gr-opacity")) (tm-define-overloaded (graphics-set-opacity val) (graphics-set-property "gr-opacity" val)))
    => ((quote graphics-set-opacity) #:check-mark (list "*" (graphics-test-property? "gr-opacity")))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-opacity) #:check-mark (list "*" (graphics-test-property? "gr-opacity"))))

  (define-option-argument opt decl)
    <= ((val "Opacity") (tm-define-overloaded (graphics-set-opacity val) (graphics-set-property "gr-opacity" val)))
    => cons <> cur-props <= ((quote graphics-set-opacity) #:arguments (quote (val)))
    => cons <> cur-props <= ((quote graphics-set-opacity) (quote (#:argument val)) (quote ("Opacity")))
    => cur-props => (((quote graphics-set-opacity) (quote (#:argument val)) (quote ("Opacity"))) ((quote graphics-set-opacity) #:arguments (quote (val))) ((quote graphics-set-opacity) #:check-mark (list "*" (graphics-test-property? "gr-opacity"))))

(property-set! var prop what conds*)
  <= (graphics-set-opacity (#:argument val) ("Opacity") ())

(property-set! var prop what conds*)
  <= (graphics-set-opacity #:arguments (val) ())

(property-set! var prop what conds*)
  <= (graphics-set-opacity #:check-mark ("*" #<procedure #f (val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" (graphics-test-property? "gr-color")) (tm-define-overloaded (graphics-set-color val) (graphics-set-property "gr-color" val)))
    => ((quote graphics-set-color) #:check-mark (list "*" (graphics-test-property? "gr-color")))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-color) #:check-mark (list "*" (graphics-test-property? "gr-color"))))

  (define-option-argument opt decl)
    <= ((val "Color") (tm-define-overloaded (graphics-set-color val) (graphics-set-property "gr-color" val)))
    => cons <> cur-props <= ((quote graphics-set-color) #:arguments (quote (val)))
    => cons <> cur-props <= ((quote graphics-set-color) (quote (#:argument val)) (quote ("Color")))
    => cur-props => (((quote graphics-set-color) (quote (#:argument val)) (quote ("Color"))) ((quote graphics-set-color) #:arguments (quote (val))) ((quote graphics-set-color) #:check-mark (list "*" (graphics-test-property? "gr-color"))))

(property-set! var prop what conds*)
  <= (graphics-set-color (#:argument val) ("Color") ())

(property-set! var prop what conds*)
  <= (graphics-set-color #:arguments (val) ())

(property-set! var prop what conds*)
  <= (graphics-set-color #:check-mark ("*" #<procedure #f (val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" (graphics-test-property? "gr-point-style")) (tm-define-overloaded (graphics-set-point-style val) (graphics-set-property "gr-point-style" val)))
    => ((quote graphics-set-point-style) #:check-mark (list "*" (graphics-test-property? "gr-point-style")))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-point-style) #:check-mark (list "*" (graphics-test-property? "gr-point-style"))))

  (define-option-argument opt decl)
    <= ((val "Point style") (tm-define-overloaded (graphics-set-point-style val) (graphics-set-property "gr-point-style" val)))
    => cons <> cur-props <= ((quote graphics-set-point-style) #:arguments (quote (val)))
    => cons <> cur-props <= ((quote graphics-set-point-style) (quote (#:argument val)) (quote ("Point style")))
    => cur-props => (((quote graphics-set-point-style) (quote (#:argument val)) (quote ("Point style"))) ((quote graphics-set-point-style) #:arguments (quote (val))) ((quote graphics-set-point-style) #:check-mark (list "*" (graphics-test-property? "gr-point-style"))))

(property-set! var prop what conds*)
  <= (graphics-set-point-style (#:argument val) ("Point style") ())

(property-set! var prop what conds*)
  <= (graphics-set-point-style #:arguments (val) ())

(property-set! var prop what conds*)
  <= (graphics-set-point-style #:check-mark ("*" #<procedure #f (val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" (graphics-test-property? "gr-point-size")) (tm-define-overloaded (graphics-set-point-size val) (graphics-set-property "gr-point-size" val)))
    => ((quote graphics-set-point-size) #:check-mark (list "*" (graphics-test-property? "gr-point-size")))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-point-size) #:check-mark (list "*" (graphics-test-property? "gr-point-size"))))

  (define-option-argument opt decl)
    <= ((val "Point size") (tm-define-overloaded (graphics-set-point-size val) (graphics-set-property "gr-point-size" val)))
    => cons <> cur-props <= ((quote graphics-set-point-size) #:arguments (quote (val)))
    => cons <> cur-props <= ((quote graphics-set-point-size) (quote (#:argument val)) (quote ("Point size")))
    => cur-props => (((quote graphics-set-point-size) (quote (#:argument val)) (quote ("Point size"))) ((quote graphics-set-point-size) #:arguments (quote (val))) ((quote graphics-set-point-size) #:check-mark (list "*" (graphics-test-property? "gr-point-size"))))

(property-set! var prop what conds*)
  <= (graphics-set-point-size (#:argument val) ("Point size") ())

(property-set! var prop what conds*)
  <= (graphics-set-point-size #:arguments (val) ())

(property-set! var prop what conds*)
  <= (graphics-set-point-size #:check-mark ("*" #<procedure #f (val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" (graphics-test-property? "gr-point-border")) (tm-define-overloaded (graphics-set-point-border val) (graphics-set-property "gr-point-border" val)))
    => ((quote graphics-set-point-border) #:check-mark (list "*" (graphics-test-property? "gr-point-border")))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-point-border) #:check-mark (list "*" (graphics-test-property? "gr-point-border"))))

  (define-option-argument opt decl)
    <= ((val "Point border") (tm-define-overloaded (graphics-set-point-border val) (graphics-set-property "gr-point-border" val)))
    => cons <> cur-props <= ((quote graphics-set-point-border) #:arguments (quote (val)))
    => cons <> cur-props <= ((quote graphics-set-point-border) (quote (#:argument val)) (quote ("Point border")))
    => cur-props => (((quote graphics-set-point-border) (quote (#:argument val)) (quote ("Point border"))) ((quote graphics-set-point-border) #:arguments (quote (val))) ((quote graphics-set-point-border) #:check-mark (list "*" (graphics-test-property? "gr-point-border"))))

(property-set! var prop what conds*)
  <= (graphics-set-point-border (#:argument val) ("Point border") ())

(property-set! var prop what conds*)
  <= (graphics-set-point-border #:arguments (val) ())

(property-set! var prop what conds*)
  <= (graphics-set-point-border #:check-mark ("*" #<procedure #f (val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" (graphics-test-property? "gr-line-width")) (tm-define-overloaded (graphics-set-line-width val) (graphics-set-property "gr-line-width" val)))
    => ((quote graphics-set-line-width) #:check-mark (list "*" (graphics-test-property? "gr-line-width")))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-line-width) #:check-mark (list "*" (graphics-test-property? "gr-line-width"))))

  (define-option-argument opt decl)
    <= ((val "Line width") (tm-define-overloaded (graphics-set-line-width val) (graphics-set-property "gr-line-width" val)))
    => cons <> cur-props <= ((quote graphics-set-line-width) #:arguments (quote (val)))
    => cons <> cur-props <= ((quote graphics-set-line-width) (quote (#:argument val)) (quote ("Line width")))
    => cur-props => (((quote graphics-set-line-width) (quote (#:argument val)) (quote ("Line width"))) ((quote graphics-set-line-width) #:arguments (quote (val))) ((quote graphics-set-line-width) #:check-mark (list "*" (graphics-test-property? "gr-line-width"))))

(property-set! var prop what conds*)
  <= (graphics-set-line-width (#:argument val) ("Line width") ())

(property-set! var prop what conds*)
  <= (graphics-set-line-width #:arguments (val) ())

(property-set! var prop what conds*)
  <= (graphics-set-line-width #:check-mark ("*" #<procedure #f (val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" (graphics-test-property? "gr-dash-style")) (tm-define-overloaded (graphics-set-dash-style val) (graphics-set-property "gr-dash-style" val)))
    => ((quote graphics-set-dash-style) #:check-mark (list "*" (graphics-test-property? "gr-dash-style")))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-dash-style) #:check-mark (list "*" (graphics-test-property? "gr-dash-style"))))

  (define-option-argument opt decl)
    <= ((val "Dash style") (tm-define-overloaded (graphics-set-dash-style val) (graphics-set-property "gr-dash-style" val)))
    => cons <> cur-props <= ((quote graphics-set-dash-style) #:arguments (quote (val)))
    => cons <> cur-props <= ((quote graphics-set-dash-style) (quote (#:argument val)) (quote ("Dash style")))
    => cur-props => (((quote graphics-set-dash-style) (quote (#:argument val)) (quote ("Dash style"))) ((quote graphics-set-dash-style) #:arguments (quote (val))) ((quote graphics-set-dash-style) #:check-mark (list "*" (graphics-test-property? "gr-dash-style"))))

(property-set! var prop what conds*)
  <= (graphics-set-dash-style (#:argument val) ("Dash style") ())

(property-set! var prop what conds*)
  <= (graphics-set-dash-style #:arguments (val) ())

(property-set! var prop what conds*)
  <= (graphics-set-dash-style #:check-mark ("*" #<procedure #f (val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" (graphics-test-property? "gr-dash-style-unit")) (tm-define-overloaded (graphics-set-dash-style-unit val) (graphics-set-property "gr-dash-style-unit" val)))
    => ((quote graphics-set-dash-style-unit) #:check-mark (list "*" (graphics-test-property? "gr-dash-style-unit")))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-dash-style-unit) #:check-mark (list "*" (graphics-test-property? "gr-dash-style-unit"))))

  (define-option-argument opt decl)
    <= ((val "Dash style unit") (tm-define-overloaded (graphics-set-dash-style-unit val) (graphics-set-property "gr-dash-style-unit" val)))
    => cons <> cur-props <= ((quote graphics-set-dash-style-unit) #:arguments (quote (val)))
    => cons <> cur-props <= ((quote graphics-set-dash-style-unit) (quote (#:argument val)) (quote ("Dash style unit")))
    => cur-props => (((quote graphics-set-dash-style-unit) (quote (#:argument val)) (quote ("Dash style unit"))) ((quote graphics-set-dash-style-unit) #:arguments (quote (val))) ((quote graphics-set-dash-style-unit) #:check-mark (list "*" (graphics-test-property? "gr-dash-style-unit"))))

(property-set! var prop what conds*)
  <= (graphics-set-dash-style-unit (#:argument val) ("Dash style unit") ())

(property-set! var prop what conds*)
  <= (graphics-set-dash-style-unit #:arguments (val) ())

(property-set! var prop what conds*)
  <= (graphics-set-dash-style-unit #:check-mark ("*" #<procedure #f (val)>) ())

  (define-option-argument opt decl)
    <= ((vu "Vertical dash style unit") (tm-define-overloaded (graphics-set-dash-style-unit* hu vu) (graphics-set-property "gr-dash-style-unit" (quasiquote (tuple (unquote hu) (unquote vu))))))
    => cons <> cur-props <= ((quote graphics-set-dash-style-unit*) #:arguments (quote (hu vu)))
    => cons <> cur-props <= ((quote graphics-set-dash-style-unit*) (quote (#:argument vu)) (quote ("Vertical dash style unit")))
    => cur-props => (((quote graphics-set-dash-style-unit*) (quote (#:argument vu)) (quote ("Vertical dash style unit"))) ((quote graphics-set-dash-style-unit*) #:arguments (quote (hu vu))))

  (define-option-argument opt decl)
    <= ((hu "Horizontal dash style unit") (tm-define-overloaded (graphics-set-dash-style-unit* hu vu) (graphics-set-property "gr-dash-style-unit" (quasiquote (tuple (unquote hu) (unquote vu))))))
    => cons <> cur-props <= ((quote graphics-set-dash-style-unit*) #:arguments (quote (hu vu)))
    => cons <> cur-props <= ((quote graphics-set-dash-style-unit*) (quote (#:argument hu)) (quote ("Horizontal dash style unit")))
    => cur-props => (((quote graphics-set-dash-style-unit*) (quote (#:argument hu)) (quote ("Horizontal dash style unit"))) ((quote graphics-set-dash-style-unit*) #:arguments (quote (hu vu))) ((quote graphics-set-dash-style-unit*) (quote (#:argument vu)) (quote ("Vertical dash style unit"))) ((quote graphics-set-dash-style-unit*) #:arguments (quote (hu vu))))

(property-set! var prop what conds*)
  <= (graphics-set-dash-style-unit* (#:argument hu) ("Horizontal dash style unit") ())

(property-set! var prop what conds*)
  <= (graphics-set-dash-style-unit* #:arguments (hu vu) ())

(property-set! var prop what conds*)
  <= (graphics-set-dash-style-unit* (#:argument vu) ("Vertical dash style unit") ())

(property-set! var prop what conds*)
  <= (graphics-set-dash-style-unit* #:arguments (hu vu) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" (graphics-test-property? "gr-line-portion")) (tm-define-overloaded (graphics-set-line-portion val) (graphics-set-property "gr-line-portion" val)))
    => ((quote graphics-set-line-portion) #:check-mark (list "*" (graphics-test-property? "gr-line-portion")))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-line-portion) #:check-mark (list "*" (graphics-test-property? "gr-line-portion"))))

  (define-option-argument opt decl)
    <= ((val "Line portion") (tm-define-overloaded (graphics-set-line-portion val) (graphics-set-property "gr-line-portion" val)))
    => cons <> cur-props <= ((quote graphics-set-line-portion) #:arguments (quote (val)))
    => cons <> cur-props <= ((quote graphics-set-line-portion) (quote (#:argument val)) (quote ("Line portion")))
    => cur-props => (((quote graphics-set-line-portion) (quote (#:argument val)) (quote ("Line portion"))) ((quote graphics-set-line-portion) #:arguments (quote (val))) ((quote graphics-set-line-portion) #:check-mark (list "*" (graphics-test-property? "gr-line-portion"))))

(property-set! var prop what conds*)
  <= (graphics-set-line-portion (#:argument val) ("Line portion") ())

(property-set! var prop what conds*)
  <= (graphics-set-line-portion #:arguments (val) ())

(property-set! var prop what conds*)
  <= (graphics-set-line-portion #:check-mark ("*" #<procedure #f (val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" (graphics-test-property? "gr-fill-color")) (tm-define-overloaded (graphics-set-fill-color val) (graphics-set-property "gr-fill-color" val)))
    => ((quote graphics-set-fill-color) #:check-mark (list "*" (graphics-test-property? "gr-fill-color")))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-fill-color) #:check-mark (list "*" (graphics-test-property? "gr-fill-color"))))

  (define-option-argument opt decl)
    <= ((val "Fill color") (tm-define-overloaded (graphics-set-fill-color val) (graphics-set-property "gr-fill-color" val)))
    => cons <> cur-props <= ((quote graphics-set-fill-color) #:arguments (quote (val)))
    => cons <> cur-props <= ((quote graphics-set-fill-color) (quote (#:argument val)) (quote ("Fill color")))
    => cur-props => (((quote graphics-set-fill-color) (quote (#:argument val)) (quote ("Fill color"))) ((quote graphics-set-fill-color) #:arguments (quote (val))) ((quote graphics-set-fill-color) #:check-mark (list "*" (graphics-test-property? "gr-fill-color"))))

(property-set! var prop what conds*)
  <= (graphics-set-fill-color (#:argument val) ("Fill color") ())

(property-set! var prop what conds*)
  <= (graphics-set-fill-color #:arguments (val) ())

(property-set! var prop what conds*)
  <= (graphics-set-fill-color #:check-mark ("*" #<procedure #f (val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" (graphics-test-property? "gr-arrow-begin")) (tm-define-overloaded (graphics-set-arrow-begin val) (graphics-set-property "gr-arrow-begin" val)))
    => ((quote graphics-set-arrow-begin) #:check-mark (list "*" (graphics-test-property? "gr-arrow-begin")))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-arrow-begin) #:check-mark (list "*" (graphics-test-property? "gr-arrow-begin"))))

  (define-option-argument opt decl)
    <= ((val "Left arrow") (tm-define-overloaded (graphics-set-arrow-begin val) (graphics-set-property "gr-arrow-begin" val)))
    => cons <> cur-props <= ((quote graphics-set-arrow-begin) #:arguments (quote (val)))
    => cons <> cur-props <= ((quote graphics-set-arrow-begin) (quote (#:argument val)) (quote ("Left arrow")))
    => cur-props => (((quote graphics-set-arrow-begin) (quote (#:argument val)) (quote ("Left arrow"))) ((quote graphics-set-arrow-begin) #:arguments (quote (val))) ((quote graphics-set-arrow-begin) #:check-mark (list "*" (graphics-test-property? "gr-arrow-begin"))))

(property-set! var prop what conds*)
  <= (graphics-set-arrow-begin (#:argument val) ("Left arrow") ())

(property-set! var prop what conds*)
  <= (graphics-set-arrow-begin #:arguments (val) ())

(property-set! var prop what conds*)
  <= (graphics-set-arrow-begin #:check-mark ("*" #<procedure #f (val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" (graphics-test-property? "gr-arrow-end")) (tm-define-overloaded (graphics-set-arrow-end val) (graphics-set-property "gr-arrow-end" val)))
    => ((quote graphics-set-arrow-end) #:check-mark (list "*" (graphics-test-property? "gr-arrow-end")))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-arrow-end) #:check-mark (list "*" (graphics-test-property? "gr-arrow-end"))))

  (define-option-argument opt decl)
    <= ((val "Right arrow") (tm-define-overloaded (graphics-set-arrow-end val) (graphics-set-property "gr-arrow-end" val)))
    => cons <> cur-props <= ((quote graphics-set-arrow-end) #:arguments (quote (val)))
    => cons <> cur-props <= ((quote graphics-set-arrow-end) (quote (#:argument val)) (quote ("Right arrow")))
    => cur-props => (((quote graphics-set-arrow-end) (quote (#:argument val)) (quote ("Right arrow"))) ((quote graphics-set-arrow-end) #:arguments (quote (val))) ((quote graphics-set-arrow-end) #:check-mark (list "*" (graphics-test-property? "gr-arrow-end"))))

(property-set! var prop what conds*)
  <= (graphics-set-arrow-end (#:argument val) ("Right arrow") ())

(property-set! var prop what conds*)
  <= (graphics-set-arrow-end #:arguments (val) ())

(property-set! var prop what conds*)
  <= (graphics-set-arrow-end #:check-mark ("*" #<procedure #f (val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" (graphics-test-property? "gr-text-at-halign")) (tm-define-overloaded (graphics-set-text-at-halign val) (graphics-set-property "gr-text-at-halign" val)))
    => ((quote graphics-set-text-at-halign) #:check-mark (list "*" (graphics-test-property? "gr-text-at-halign")))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-text-at-halign) #:check-mark (list "*" (graphics-test-property? "gr-text-at-halign"))))

  (define-option-argument opt decl)
    <= ((val "Text-at horizontal alignment") (tm-define-overloaded (graphics-set-text-at-halign val) (graphics-set-property "gr-text-at-halign" val)))
    => cons <> cur-props <= ((quote graphics-set-text-at-halign) #:arguments (quote (val)))
    => cons <> cur-props <= ((quote graphics-set-text-at-halign) (quote (#:argument val)) (quote ("Text-at horizontal alignment")))
    => cur-props => (((quote graphics-set-text-at-halign) (quote (#:argument val)) (quote ("Text-at horizontal alignment"))) ((quote graphics-set-text-at-halign) #:arguments (quote (val))) ((quote graphics-set-text-at-halign) #:check-mark (list "*" (graphics-test-property? "gr-text-at-halign"))))

(property-set! var prop what conds*)
  <= (graphics-set-text-at-halign (#:argument val) ("Text-at horizontal alignment") ())

(property-set! var prop what conds*)
  <= (graphics-set-text-at-halign #:arguments (val) ())

(property-set! var prop what conds*)
  <= (graphics-set-text-at-halign #:check-mark ("*" #<procedure #f (val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" (graphics-test-property? "gr-text-at-valign")) (tm-define-overloaded (graphics-set-text-at-valign val) (graphics-set-property "gr-text-at-valign" val)))
    => ((quote graphics-set-text-at-valign) #:check-mark (list "*" (graphics-test-property? "gr-text-at-valign")))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-text-at-valign) #:check-mark (list "*" (graphics-test-property? "gr-text-at-valign"))))

  (define-option-argument opt decl)
    <= ((val "Text-at vertical alignment") (tm-define-overloaded (graphics-set-text-at-valign val) (graphics-set-property "gr-text-at-valign" val)))
    => cons <> cur-props <= ((quote graphics-set-text-at-valign) #:arguments (quote (val)))
    => cons <> cur-props <= ((quote graphics-set-text-at-valign) (quote (#:argument val)) (quote ("Text-at vertical alignment")))
    => cur-props => (((quote graphics-set-text-at-valign) (quote (#:argument val)) (quote ("Text-at vertical alignment"))) ((quote graphics-set-text-at-valign) #:arguments (quote (val))) ((quote graphics-set-text-at-valign) #:check-mark (list "*" (graphics-test-property? "gr-text-at-valign"))))

(property-set! var prop what conds*)
  <= (graphics-set-text-at-valign (#:argument val) ("Text-at vertical alignment") ())

(property-set! var prop what conds*)
  <= (graphics-set-text-at-valign #:arguments (val) ())

(property-set! var prop what conds*)
  <= (graphics-set-text-at-valign #:check-mark ("*" #<procedure #f (val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" (graphics-test-property? "gr-doc-at-valign")) (tm-define-overloaded (graphics-set-doc-at-valign val) (graphics-set-property "gr-doc-at-valign" val)))
    => ((quote graphics-set-doc-at-valign) #:check-mark (list "*" (graphics-test-property? "gr-doc-at-valign")))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-doc-at-valign) #:check-mark (list "*" (graphics-test-property? "gr-doc-at-valign"))))

  (define-option-argument opt decl)
    <= ((val "Document-at vertical alignment") (tm-define-overloaded (graphics-set-doc-at-valign val) (graphics-set-property "gr-doc-at-valign" val)))
    => cons <> cur-props <= ((quote graphics-set-doc-at-valign) #:arguments (quote (val)))
    => cons <> cur-props <= ((quote graphics-set-doc-at-valign) (quote (#:argument val)) (quote ("Document-at vertical alignment")))
    => cur-props => (((quote graphics-set-doc-at-valign) (quote (#:argument val)) (quote ("Document-at vertical alignment"))) ((quote graphics-set-doc-at-valign) #:arguments (quote (val))) ((quote graphics-set-doc-at-valign) #:check-mark (list "*" (graphics-test-property? "gr-doc-at-valign"))))

(property-set! var prop what conds*)
  <= (graphics-set-doc-at-valign (#:argument val) ("Document-at vertical alignment") ())

(property-set! var prop what conds*)
  <= (graphics-set-doc-at-valign #:arguments (val) ())

(property-set! var prop what conds*)
  <= (graphics-set-doc-at-valign #:check-mark ("*" #<procedure #f (val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" graphics-check-width?) (tm-define-overloaded (graphics-set-doc-at-width val) (graphics-set-property "gr-doc-at-width" val) (graphics-set-property "gr-doc-at-hmode" "exact") (graphics-set-property "gr-doc-at-ppsep" "")))
    => ((quote graphics-set-doc-at-width) #:check-mark (list "*" graphics-check-width?))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-doc-at-width) #:check-mark (list "*" graphics-check-width?)))

  (define-option-argument opt decl)
    <= ((val "Document-at width") (tm-define-overloaded (graphics-set-doc-at-width val) (graphics-set-property "gr-doc-at-width" val) (graphics-set-property "gr-doc-at-hmode" "exact") (graphics-set-property "gr-doc-at-ppsep" "")))
    => cons <> cur-props <= ((quote graphics-set-doc-at-width) #:arguments (quote (val)))
    => cons <> cur-props <= ((quote graphics-set-doc-at-width) (quote (#:argument val)) (quote ("Document-at width")))
    => cur-props => (((quote graphics-set-doc-at-width) (quote (#:argument val)) (quote ("Document-at width"))) ((quote graphics-set-doc-at-width) #:arguments (quote (val))) ((quote graphics-set-doc-at-width) #:check-mark (list "*" graphics-check-width?)))

(property-set! var prop what conds*)
  <= (graphics-set-doc-at-width (#:argument val) ("Document-at width") ())

(property-set! var prop what conds*)
  <= (graphics-set-doc-at-width #:arguments (val) ())

(property-set! var prop what conds*)
  <= (graphics-set-doc-at-width #:check-mark ("*" #<procedure graphics-check-width? (val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" graphics-check-compact?) (tm-define-overloaded (graphics-set-doc-at-compact) (graphics-set-property "gr-doc-at-width" "default") (graphics-set-property "gr-doc-at-hmode" "default") (graphics-set-property "gr-doc-at-ppsep" "default")))
    => ((quote graphics-set-doc-at-compact) #:check-mark (list "*" graphics-check-compact?))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-doc-at-compact) #:check-mark (list "*" graphics-check-compact?)))

(property-set! var prop what conds*)
  <= (graphics-set-doc-at-compact #:check-mark ("*" #<procedure graphics-check-compact? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" (graphics-toggled-property? "gr-doc-at-border")) (tm-define-overloaded (graphics-toggle-doc-at-border) (if (== (graphics-get-property "gr-doc-at-border") "default") (begin (graphics-set-property "gr-doc-at-border" "1ln") (graphics-set-property "gr-doc-at-padding" "1spc")) (begin (graphics-set-property "gr-doc-at-border" "default") (graphics-set-property "gr-doc-at-padding" "default")))))
    => ((quote graphics-toggle-doc-at-border) #:check-mark (list "*" (graphics-toggled-property? "gr-doc-at-border")))
 => cons <> cur-props
    => cur-props => (((quote graphics-toggle-doc-at-border) #:check-mark (list "*" (graphics-toggled-property? "gr-doc-at-border"))))

(property-set! var prop what conds*)
  <= (graphics-toggle-doc-at-border #:check-mark ("*" #<procedure #f ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" (graphics-toggled-property? "gr-doc-at-padding")) (tm-define-overloaded (graphics-toggle-doc-at-padded) (if (== (graphics-get-property "gr-doc-at-padding") "default") (graphics-set-property "gr-doc-at-padding" "1spc") (graphics-set-property "gr-doc-at-padding" "default"))))
    => ((quote graphics-toggle-doc-at-padded) #:check-mark (list "*" (graphics-toggled-property? "gr-doc-at-padding")))
 => cons <> cur-props
    => cur-props => (((quote graphics-toggle-doc-at-padded) #:check-mark (list "*" (graphics-toggled-property? "gr-doc-at-padding"))))

(property-set! var prop what conds*)
  <= (graphics-toggle-doc-at-padded #:check-mark ("*" #<procedure #f ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" graphics-test-snap?) (tm-define-overloaded (graphics-set-snap type) (cond ((== type "none") (set-snap (list))) ((== type "all") (set-snap (list "all"))) ((nin? type (get-snap)) (set-snap (cons type (get-snap)))))))
    => ((quote graphics-set-snap) #:check-mark (list "*" graphics-test-snap?))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-snap) #:check-mark (list "*" graphics-test-snap?)))

(property-set! var prop what conds*)
  <= (graphics-set-snap #:check-mark ("*" #<procedure graphics-test-snap? (type)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" graphics-test-snap?) (tm-define-overloaded (graphics-toggle-snap type) (if (graphics-get-snap type) (graphics-reset-snap type) (graphics-set-snap type))))
    => ((quote graphics-toggle-snap) #:check-mark (list "*" graphics-test-snap?))
 => cons <> cur-props
    => cur-props => (((quote graphics-toggle-snap) #:check-mark (list "*" graphics-test-snap?)))

(property-set! var prop what conds*)
  <= (graphics-toggle-snap #:check-mark ("*" #<procedure graphics-test-snap? (type)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" (graphics-test-property? "gr-snap-distance")) (tm-define-overloaded (graphics-set-snap-distance val) (graphics-set-property "gr-snap-distance" val)))
    => ((quote graphics-set-snap-distance) #:check-mark (list "*" (graphics-test-property? "gr-snap-distance")))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-snap-distance) #:check-mark (list "*" (graphics-test-property? "gr-snap-distance"))))

  (define-option-argument opt decl)
    <= ((val "Snap distance") (tm-define-overloaded (graphics-set-snap-distance val) (graphics-set-property "gr-snap-distance" val)))
    => cons <> cur-props <= ((quote graphics-set-snap-distance) #:arguments (quote (val)))
    => cons <> cur-props <= ((quote graphics-set-snap-distance) (quote (#:argument val)) (quote ("Snap distance")))
    => cur-props => (((quote graphics-set-snap-distance) (quote (#:argument val)) (quote ("Snap distance"))) ((quote graphics-set-snap-distance) #:arguments (quote (val))) ((quote graphics-set-snap-distance) #:check-mark (list "*" (graphics-test-property? "gr-snap-distance"))))

(property-set! var prop what conds*)
  <= (graphics-set-snap-distance (#:argument val) ("Snap distance") ())

(property-set! var prop what conds*)
  <= (graphics-set-snap-distance #:arguments (val) ())

(property-set! var prop what conds*)
  <= (graphics-set-snap-distance #:check-mark ("*" #<procedure #f (val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" (graphics-test-property? "gr-text-at-margin")) (tm-define-overloaded (graphics-set-snap-text-padding val) (graphics-set-property "gr-text-at-margin" val)))
    => ((quote graphics-set-snap-text-padding) #:check-mark (list "*" (graphics-test-property? "gr-text-at-margin")))
 => cons <> cur-props
    => cur-props => (((quote graphics-set-snap-text-padding) #:check-mark (list "*" (graphics-test-property? "gr-text-at-margin"))))

  (define-option-argument opt decl)
    <= ((val "Text padding for snapping") (tm-define-overloaded (graphics-set-snap-text-padding val) (graphics-set-property "gr-text-at-margin" val)))
    => cons <> cur-props <= ((quote graphics-set-snap-text-padding) #:arguments (quote (val)))
    => cons <> cur-props <= ((quote graphics-set-snap-text-padding) (quote (#:argument val)) (quote ("Text padding for snapping")))
    => cur-props => (((quote graphics-set-snap-text-padding) (quote (#:argument val)) (quote ("Text padding for snapping"))) ((quote graphics-set-snap-text-padding) #:arguments (quote (val))) ((quote graphics-set-snap-text-padding) #:check-mark (list "*" (graphics-test-property? "gr-text-at-margin"))))

(property-set! var prop what conds*)
  <= (graphics-set-snap-text-padding (#:argument val) ("Text padding for snapping") ())

(property-set! var prop what conds*)
  <= (graphics-set-snap-text-padding #:arguments (val) ())

(property-set! var prop what conds*)
  <= (graphics-set-snap-text-padding #:check-mark ("*" #<procedure #f (val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" (object-test-property? "fill-color")) (tm-define-overloaded (object-set-fill-color val) (object-set-property "fill-color" val)))
    => ((quote object-set-fill-color) #:check-mark (list "*" (object-test-property? "fill-color")))
 => cons <> cur-props
    => cur-props => (((quote object-set-fill-color) #:check-mark (list "*" (object-test-property? "fill-color"))))

  (define-option-argument opt decl)
    <= ((val "Fill color") (tm-define-overloaded (object-set-fill-color val) (object-set-property "fill-color" val)))
    => cons <> cur-props <= ((quote object-set-fill-color) #:arguments (quote (val)))
    => cons <> cur-props <= ((quote object-set-fill-color) (quote (#:argument val)) (quote ("Fill color")))
    => cur-props => (((quote object-set-fill-color) (quote (#:argument val)) (quote ("Fill color"))) ((quote object-set-fill-color) #:arguments (quote (val))) ((quote object-set-fill-color) #:check-mark (list "*" (object-test-property? "fill-color"))))

(property-set! var prop what conds*)
  <= (object-set-fill-color (#:argument val) ("Fill color") ())

(property-set! var prop what conds*)
  <= (object-set-fill-color #:arguments (val) ())

(property-set! var prop what conds*)
  <= (object-set-fill-color #:check-mark ("*" #<procedure #f (val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" (object-test-property? "text-at-halign")) (tm-define-overloaded (object-set-text-at-halign val) (object-set-property "text-at-halign" val)))
    => ((quote object-set-text-at-halign) #:check-mark (list "*" (object-test-property? "text-at-halign")))
 => cons <> cur-props
    => cur-props => (((quote object-set-text-at-halign) #:check-mark (list "*" (object-test-property? "text-at-halign"))))

  (define-option-argument opt decl)
    <= ((val "Horizontal alignment") (tm-define-overloaded (object-set-text-at-halign val) (object-set-property "text-at-halign" val)))
    => cons <> cur-props <= ((quote object-set-text-at-halign) #:arguments (quote (val)))
    => cons <> cur-props <= ((quote object-set-text-at-halign) (quote (#:argument val)) (quote ("Horizontal alignment")))
    => cur-props => (((quote object-set-text-at-halign) (quote (#:argument val)) (quote ("Horizontal alignment"))) ((quote object-set-text-at-halign) #:arguments (quote (val))) ((quote object-set-text-at-halign) #:check-mark (list "*" (object-test-property? "text-at-halign"))))

(property-set! var prop what conds*)
  <= (object-set-text-at-halign (#:argument val) ("Horizontal alignment") ())

(property-set! var prop what conds*)
  <= (object-set-text-at-halign #:arguments (val) ())

(property-set! var prop what conds*)
  <= (object-set-text-at-halign #:check-mark ("*" #<procedure #f (val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" (object-test-property? "text-at-valign")) (tm-define-overloaded (object-set-text-at-valign val) (object-set-property "text-at-valign" val)))
    => ((quote object-set-text-at-valign) #:check-mark (list "*" (object-test-property? "text-at-valign")))
 => cons <> cur-props
    => cur-props => (((quote object-set-text-at-valign) #:check-mark (list "*" (object-test-property? "text-at-valign"))))

  (define-option-argument opt decl)
    <= ((val "Vertical alignment") (tm-define-overloaded (object-set-text-at-valign val) (object-set-property "text-at-valign" val)))
    => cons <> cur-props <= ((quote object-set-text-at-valign) #:arguments (quote (val)))
    => cons <> cur-props <= ((quote object-set-text-at-valign) (quote (#:argument val)) (quote ("Vertical alignment")))
    => cur-props => (((quote object-set-text-at-valign) (quote (#:argument val)) (quote ("Vertical alignment"))) ((quote object-set-text-at-valign) #:arguments (quote (val))) ((quote object-set-text-at-valign) #:check-mark (list "*" (object-test-property? "text-at-valign"))))

(property-set! var prop what conds*)
  <= (object-set-text-at-valign (#:argument val) ("Vertical alignment") ())

(property-set! var prop what conds*)
  <= (object-set-text-at-valign #:arguments (val) ())

(property-set! var prop what conds*)
  <= (object-set-text-at-valign #:check-mark ("*" #<procedure #f (val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" (object-test-property? "doc-at-valign")) (tm-define-overloaded (object-set-doc-at-valign val) (object-set-property "doc-at-valign" val)))
    => ((quote object-set-doc-at-valign) #:check-mark (list "*" (object-test-property? "doc-at-valign")))
 => cons <> cur-props
    => cur-props => (((quote object-set-doc-at-valign) #:check-mark (list "*" (object-test-property? "doc-at-valign"))))

  (define-option-argument opt decl)
    <= ((val "Vertical alignment") (tm-define-overloaded (object-set-doc-at-valign val) (object-set-property "doc-at-valign" val)))
    => cons <> cur-props <= ((quote object-set-doc-at-valign) #:arguments (quote (val)))
    => cons <> cur-props <= ((quote object-set-doc-at-valign) (quote (#:argument val)) (quote ("Vertical alignment")))
    => cur-props => (((quote object-set-doc-at-valign) (quote (#:argument val)) (quote ("Vertical alignment"))) ((quote object-set-doc-at-valign) #:arguments (quote (val))) ((quote object-set-doc-at-valign) #:check-mark (list "*" (object-test-property? "doc-at-valign"))))

(property-set! var prop what conds*)
  <= (object-set-doc-at-valign (#:argument val) ("Vertical alignment") ())

(property-set! var prop what conds*)
  <= (object-set-doc-at-valign #:arguments (val) ())

(property-set! var prop what conds*)
  <= (object-set-doc-at-valign #:check-mark ("*" #<procedure #f (val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" object-check-width?) (tm-define-overloaded (object-set-doc-at-width val) (if (== val "1par") (set! val "default")) (object-set-property "doc-at-width" val) (object-set-property "doc-at-hmode" "exact") (object-set-property "doc-at-ppsep" "")))
    => ((quote object-set-doc-at-width) #:check-mark (list "*" object-check-width?))
 => cons <> cur-props
    => cur-props => (((quote object-set-doc-at-width) #:check-mark (list "*" object-check-width?)))

  (define-option-argument opt decl)
    <= ((val "Document-at width") (tm-define-overloaded (object-set-doc-at-width val) (if (== val "1par") (set! val "default")) (object-set-property "doc-at-width" val) (object-set-property "doc-at-hmode" "exact") (object-set-property "doc-at-ppsep" "")))
    => cons <> cur-props <= ((quote object-set-doc-at-width) #:arguments (quote (val)))
    => cons <> cur-props <= ((quote object-set-doc-at-width) (quote (#:argument val)) (quote ("Document-at width")))
    => cur-props => (((quote object-set-doc-at-width) (quote (#:argument val)) (quote ("Document-at width"))) ((quote object-set-doc-at-width) #:arguments (quote (val))) ((quote object-set-doc-at-width) #:check-mark (list "*" object-check-width?)))

(property-set! var prop what conds*)
  <= (object-set-doc-at-width (#:argument val) ("Document-at width") ())

(property-set! var prop what conds*)
  <= (object-set-doc-at-width #:arguments (val) ())

(property-set! var prop what conds*)
  <= (object-set-doc-at-width #:check-mark ("*" #<procedure object-check-width? (val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" object-check-compact?) (tm-define-overloaded (object-set-doc-at-compact) (object-set-property "doc-at-width" "default") (object-set-property "doc-at-hmode" "default") (object-set-property "doc-at-ppsep" "default")))
    => ((quote object-set-doc-at-compact) #:check-mark (list "*" object-check-compact?))
 => cons <> cur-props
    => cur-props => (((quote object-set-doc-at-compact) #:check-mark (list "*" object-check-compact?)))

(property-set! var prop what conds*)
  <= (object-set-doc-at-compact #:check-mark ("*" #<procedure object-check-compact? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" (object-toggled-property? "doc-at-border")) (tm-define-overloaded (object-toggle-doc-at-border) (if (== (object-get-property "doc-at-border") "0ln") (begin (object-set-property "doc-at-border" "1ln") (object-set-property "doc-at-padding" "1spc")) (begin (object-set-property "doc-at-border" "default") (object-set-property "doc-at-padding" "default")))))
    => ((quote object-toggle-doc-at-border) #:check-mark (list "*" (object-toggled-property? "doc-at-border")))
 => cons <> cur-props
    => cur-props => (((quote object-toggle-doc-at-border) #:check-mark (list "*" (object-toggled-property? "doc-at-border"))))

(property-set! var prop what conds*)
  <= (object-toggle-doc-at-border #:check-mark ("*" #<procedure #f ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" (object-toggled-property? "doc-at-padding")) (tm-define-overloaded (object-toggle-doc-at-padded) (if (== (object-get-property "doc-at-padding") "0spc") (object-set-property "doc-at-padding" "1spc") (object-set-property "doc-at-padding" "default"))))
    => ((quote object-toggle-doc-at-padded) #:check-mark (list "*" (object-toggled-property? "doc-at-padding")))
 => cons <> cur-props
    => cur-props => (((quote object-toggle-doc-at-padded) #:check-mark (list "*" (object-toggled-property? "doc-at-padding"))))

(property-set! var prop what conds*)
  <= (object-toggle-doc-at-padded #:check-mark ("*" #<procedure #f ()>) ())

  (define-option-require opt decl)
    <= (((== tag (quote point))) (tm-define-overloaded (object_create tag x y) (object-set! (quasiquote (point (unquote x) (unquote y))) (quote new))))
    => (define-option-match opt decl) <= ((lambda (tag x y) (== tag (quote point))) (tm-define-overloaded (object_create tag x y) (object-set! (quasiquote (point (unquote x) (unquote y))) (quote new))))

  (define-option-require opt decl)
    <= (((or (in? tag gr-tags-curves) (in? tag gr-tags-user))) (tm-define-overloaded (object_create tag x y) (with o (graphics-enrich (quasiquote ((unquote tag) (point (unquote x) (unquote y)) (point (unquote x) (unquote y))))) (graphics-store-state (quote start-create)) (set! current-point-no 1) (object-set! o (quote checkout)) (graphics-store-state #f))))
    => (define-option-match opt decl) <= ((lambda (tag x y) (or (in? tag gr-tags-curves) (in? tag gr-tags-user))) (tm-define-overloaded (object_create tag x y) (with o (graphics-enrich (quasiquote ((unquote tag) (point (unquote x) (unquote y)) (point (unquote x) (unquote y))))) (graphics-store-state (quote start-create)) (set! current-point-no 1) (object-set! o (quote checkout)) (graphics-store-state #f))))

  (define-option-require opt decl)
    <= (((graphical-text-tag? tag)) (tm-define-overloaded (object_create tag x y) (with long? (graphical-long-text-tag? tag) (object-set! (quasiquote ((unquote tag) (unquote (if long? (quasiquote (document "")) "")) (point (unquote x) (unquote y)))) (quote new)) (and-with d (path->tree (cDr (cursor-path))) (when (tree-func? d (quote document)) (tree-go-to d 0 #:start))))))
    => (define-option-match opt decl) <= ((lambda (tag x y) (graphical-text-tag? tag)) (tm-define-overloaded (object_create tag x y) (with long? (graphical-long-text-tag? tag) (object-set! (quasiquote ((unquote tag) (unquote (if long? (quasiquote (document "")) "")) (point (unquote x) (unquote y)))) (quote new)) (and-with d (path->tree (cDr (cursor-path))) (when (tree-func? d (quote document)) (tree-go-to d 0 #:start))))))

  (define-option-require opt decl)
    <= (((== mode (quote edit))) (tm-define-overloaded (edit_move mode x y) (with-state-by-name graphics-state (set-texmacs-pointer (quote graphics-cross) #t) (if current-obj (begin (if (current-in? (graphical-text-tag-list)) (set! current-point-no 1)) (if sticky-point (move-point) (move-over))) (begin (set-message "Left click: new object" "Graphics") (graphics-decorations-reset))))))
    => (define-option-match opt decl) <= ((lambda (mode x y) (== mode (quote edit))) (tm-define-overloaded (edit_move mode x y) (with-state-by-name graphics-state (set-texmacs-pointer (quote graphics-cross) #t) (if current-obj (begin (if (current-in? (graphical-text-tag-list)) (set! current-point-no 1)) (if sticky-point (move-point) (move-over))) (begin (set-message "Left click: new object" "Graphics") (graphics-decorations-reset))))))

  (define-option-require opt decl)
    <= (((== mode (quote edit))) (tm-define-overloaded (edit_left-button mode x y) (with-state-by-name graphics-state (set-texmacs-pointer (quote graphics-cross)) (cond (sticky-point (if (current-in? (graphical-text-tag-list)) (object_commit) (next-point))) ((and (current-in? (graphical-text-tag-list)) (== (car (graphics-mode)) (quote edit)) (graphical-contains-text-tag? (cadr (graphics-mode))) (not (graphical-contains-curve-tag? (cadr (graphics-mode)))) (pointer-inside-graphical-text?)) (set-texmacs-pointer (quote text-arrow)) (go-to (car (select-first (s2f current-x) (s2f current-y))))) (else (edit-insert x y))) (set! previous-leftclick (quasiquote (point (unquote current-x) (unquote current-y)))))))
    => (define-option-match opt decl) <= ((lambda (mode x y) (== mode (quote edit))) (tm-define-overloaded (edit_left-button mode x y) (with-state-by-name graphics-state (set-texmacs-pointer (quote graphics-cross)) (cond (sticky-point (if (current-in? (graphical-text-tag-list)) (object_commit) (next-point))) ((and (current-in? (graphical-text-tag-list)) (== (car (graphics-mode)) (quote edit)) (graphical-contains-text-tag? (cadr (graphics-mode))) (not (graphical-contains-curve-tag? (cadr (graphics-mode)))) (pointer-inside-graphical-text?)) (set-texmacs-pointer (quote text-arrow)) (go-to (car (select-first (s2f current-x) (s2f current-y))))) (else (edit-insert x y))) (set! previous-leftclick (quasiquote (point (unquote current-x) (unquote current-y)))))))

  (define-option-require opt decl)
    <= (((== mode (quote edit))) (tm-define-overloaded (edit_middle-button mode x y) (with-state-by-name graphics-state (set-texmacs-pointer (quote graphics-cross)) (when current-obj (graphics-delete)))))
    => (define-option-match opt decl) <= ((lambda (mode x y) (== mode (quote edit))) (tm-define-overloaded (edit_middle-button mode x y) (with-state-by-name graphics-state (set-texmacs-pointer (quote graphics-cross)) (when current-obj (graphics-delete)))))

  (define-option-require opt decl)
    <= (((== mode (quote edit))) (tm-define-overloaded (edit_right-button mode x y) (with-state-by-name graphics-state (set-texmacs-pointer (quote graphics-cross)) (when current-obj (graphics-delete)))))
    => (define-option-match opt decl) <= ((lambda (mode x y) (== mode (quote edit))) (tm-define-overloaded (edit_right-button mode x y) (with-state-by-name graphics-state (set-texmacs-pointer (quote graphics-cross)) (when current-obj (graphics-delete)))))

  (define-option-require opt decl)
    <= (((== mode (quote edit))) (tm-define-overloaded (edit_start-drag mode x y) (with-state-by-name graphics-state (set-texmacs-pointer (quote graphics-cross)) (set! dragging-busy? #t) (set! dragging-create? (or sticky-point (not current-obj))) (if (or sticky-point current-obj) (begin (if (current-in? (graphical-text-tag-list)) (set! current-point-no 1)) (if sticky-point (next-point) (start-move))) (edit-insert x y)) (set! previous-leftclick (quasiquote (point (unquote current-x) (unquote current-y)))))))
    => (define-option-match opt decl) <= ((lambda (mode x y) (== mode (quote edit))) (tm-define-overloaded (edit_start-drag mode x y) (with-state-by-name graphics-state (set-texmacs-pointer (quote graphics-cross)) (set! dragging-busy? #t) (set! dragging-create? (or sticky-point (not current-obj))) (if (or sticky-point current-obj) (begin (if (current-in? (graphical-text-tag-list)) (set! current-point-no 1)) (if sticky-point (next-point) (start-move))) (edit-insert x y)) (set! previous-leftclick (quasiquote (point (unquote current-x) (unquote current-y)))))))

  (define-option-require opt decl)
    <= (((== mode (quote edit))) (tm-define-overloaded (edit_drag mode x y) (with-state-by-name graphics-state (edit_move mode x y) (set-message "Release left button: finish editing" "Dragging"))))
    => (define-option-match opt decl) <= ((lambda (mode x y) (== mode (quote edit))) (tm-define-overloaded (edit_drag mode x y) (with-state-by-name graphics-state (edit_move mode x y) (set-message "Release left button: finish editing" "Dragging"))))

  (define-option-require opt decl)
    <= (((== mode (quote edit))) (tm-define-overloaded (edit_end-drag mode x y) (with-state-by-name graphics-state (when dragging-busy? (set-texmacs-pointer (quote graphics-cross)) (if (or sticky-point current-obj) (if dragging-create? (edit_move mode x y) (last-point))) (set! dragging-busy? #f) (set! dragging-create? #f) (set! previous-leftclick (quasiquote (point (unquote current-x) (unquote current-y))))))))
    => (define-option-match opt decl) <= ((lambda (mode x y) (== mode (quote edit))) (tm-define-overloaded (edit_end-drag mode x y) (with-state-by-name graphics-state (when dragging-busy? (set-texmacs-pointer (quote graphics-cross)) (if (or sticky-point current-obj) (if dragging-create? (edit_move mode x y) (last-point))) (set! dragging-busy? #f) (set! dragging-create? #f) (set! previous-leftclick (quasiquote (point (unquote current-x) (unquote current-y))))))))

  (define-option-require opt decl)
    <= (((== mode (quote edit))) (tm-define-overloaded (edit_tab-key mode inc) (with-state-by-name graphics-state (if (and current-x current-y) (begin (select-next inc) (graphics-update-decorations)) (invalidate-graphical-object)))))
    => (define-option-match opt decl) <= ((lambda (mode inc) (== mode (quote edit))) (tm-define-overloaded (edit_tab-key mode inc) (with-state-by-name graphics-state (if (and current-x current-y) (begin (select-next inc) (graphics-update-decorations)) (invalidate-graphical-object)))))

  (define-option-require opt decl)
    <= (((== mode (quote hand-edit))) (tm-define-overloaded (edit_move mode x y) (with-state-by-name graphics-state (noop))))
    => (define-option-match opt decl) <= ((lambda (mode x y) (== mode (quote hand-edit))) (tm-define-overloaded (edit_move mode x y) (with-state-by-name graphics-state (noop))))

  (define-option-require opt decl)
    <= (((== mode (quote hand-edit))) (tm-define-overloaded (edit_left-button mode x y) (with-state-by-name graphics-state (set-texmacs-pointer (quote graphics-cross)) (edit-clean-up) (object-set! (quasiquote (with "point style" "disk" "point-size" (unquote (graphics-get-property "line-width")) (point (unquote x) (unquote y)))) (quote new)))))
    => (define-option-match opt decl) <= ((lambda (mode x y) (== mode (quote hand-edit))) (tm-define-overloaded (edit_left-button mode x y) (with-state-by-name graphics-state (set-texmacs-pointer (quote graphics-cross)) (edit-clean-up) (object-set! (quasiquote (with "point style" "disk" "point-size" (unquote (graphics-get-property "line-width")) (point (unquote x) (unquote y)))) (quote new)))))

  (define-option-require opt decl)
    <= (((== mode (quote hand-edit))) (tm-define-overloaded (edit_start-drag mode x y) (with-state-by-name graphics-state (set-texmacs-pointer (quote graphics-cross)) (edit-clean-up) (object_create (cadr (graphics-mode)) x y))))
    => (define-option-match opt decl) <= ((lambda (mode x y) (== mode (quote hand-edit))) (tm-define-overloaded (edit_start-drag mode x y) (with-state-by-name graphics-state (set-texmacs-pointer (quote graphics-cross)) (edit-clean-up) (object_create (cadr (graphics-mode)) x y))))

  (define-option-require opt decl)
    <= (((== mode (quote hand-edit))) (tm-define-overloaded (edit_drag mode x y) (with-state-by-name graphics-state (let* ((obj (car (sketch-get1))) (rad (stree-radical obj))) (set-cdr! rad (append (cdr rad) (list (quasiquote (point (unquote x) (unquote y)))))) (object-set! obj)) (graphics-decorations-update))))
    => (define-option-match opt decl) <= ((lambda (mode x y) (== mode (quote hand-edit))) (tm-define-overloaded (edit_drag mode x y) (with-state-by-name graphics-state (let* ((obj (car (sketch-get1))) (rad (stree-radical obj))) (set-cdr! rad (append (cdr rad) (list (quasiquote (point (unquote x) (unquote y)))))) (object-set! obj)) (graphics-decorations-update))))

  (define-option-require opt decl)
    <= (((== mode (quote hand-edit))) (tm-define-overloaded (edit_end-drag mode x y) (with-state-by-name graphics-state (object_commit) (graphics-decorations-reset))))
    => (define-option-match opt decl) <= ((lambda (mode x y) (== mode (quote hand-edit))) (tm-define-overloaded (edit_end-drag mode x y) (with-state-by-name graphics-state (object_commit) (graphics-decorations-reset))))

  (define-option-require opt decl)
    <= (((edit-macro-arg? mode)) (tm-define-overloaded (edit_middle-button mode x y) (with-state-by-name graphics-state (noop))))
    => (define-option-match opt decl) <= ((lambda (mode x y) (edit-macro-arg? mode)) (tm-define-overloaded (edit_middle-button mode x y) (with-state-by-name graphics-state (noop))))

  (define-option-require opt decl)
    <= (((edit-macro-arg? mode)) (tm-define-overloaded (edit_start-drag mode x y) (with-state-by-name graphics-state (noop))))
    => (define-option-match opt decl) <= ((lambda (mode x y) (edit-macro-arg? mode)) (tm-define-overloaded (edit_start-drag mode x y) (with-state-by-name graphics-state (noop))))

  (define-option-require opt decl)
    <= (((edit-macro-arg? mode)) (tm-define-overloaded (edit_drag mode x y) (with-state-by-name graphics-state (noop))))
    => (define-option-match opt decl) <= ((lambda (mode x y) (edit-macro-arg? mode)) (tm-define-overloaded (edit_drag mode x y) (with-state-by-name graphics-state (noop))))

  (define-option-require opt decl)
    <= (((edit-macro-arg? mode)) (tm-define-overloaded (edit_end-drag mode x y) (with-state-by-name graphics-state (noop))))
    => (define-option-match opt decl) <= ((lambda (mode x y) (edit-macro-arg? mode)) (tm-define-overloaded (edit_end-drag mode x y) (with-state-by-name graphics-state (noop))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote translate-in))) (tm-define-overloaded (customizable-parameters t) (list (list "translate-start-x" "Start x") (list "translate-start-y" "Start y"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote translate-in))) (tm-define-overloaded (customizable-parameters t) (list (list "translate-start-x" "Start x") (list "translate-start-y" "Start y"))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote translate-out))) (tm-define-overloaded (customizable-parameters t) (list (list "translate-end-x" "End x") (list "translate-end-y" "End y"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote translate-out))) (tm-define-overloaded (customizable-parameters t) (list (list "translate-end-x" "End x") (list "translate-end-y" "End y"))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote translate-smooth))) (tm-define-overloaded (customizable-parameters t) (list (list "translate-start-x" "Start x") (list "translate-start-y" "Start y") (list "translate-end-x" "End x") (list "translate-end-y" "End y"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote translate-smooth))) (tm-define-overloaded (customizable-parameters t) (list (list "translate-start-x" "Start x") (list "translate-start-y" "Start y") (list "translate-end-x" "End x") (list "translate-end-y" "End y"))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote progressive-in))) (tm-define-overloaded (customizable-parameters t) (list (list "progressive-start-l" "Start left") (list "progressive-start-b" "Start bottom") (list "progressive-start-r" "Start right") (list "progressive-start-t" "Start top"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote progressive-in))) (tm-define-overloaded (customizable-parameters t) (list (list "progressive-start-l" "Start left") (list "progressive-start-b" "Start bottom") (list "progressive-start-r" "Start right") (list "progressive-start-t" "Start top"))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote progressive-out))) (tm-define-overloaded (customizable-parameters t) (list (list "progressive-end-l" "End left") (list "progressive-end-b" "End bottom") (list "progressive-end-r" "End right") (list "progressive-end-t" "End top"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote progressive-out))) (tm-define-overloaded (customizable-parameters t) (list (list "progressive-end-l" "End left") (list "progressive-end-b" "End bottom") (list "progressive-end-r" "End right") (list "progressive-end-t" "End top"))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote progressive-smooth))) (tm-define-overloaded (customizable-parameters t) (list (list "progressive-start-l" "Start left") (list "progressive-start-b" "Start bottom") (list "progressive-start-r" "Start right") (list "progressive-start-t" "Start top") (list "progressive-end-l" "End left") (list "progressive-end-b" "End bottom") (list "progressive-end-r" "End right") (list "progressive-end-t" "End top"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote progressive-smooth))) (tm-define-overloaded (customizable-parameters t) (list (list "progressive-start-l" "Start left") (list "progressive-start-b" "Start bottom") (list "progressive-start-r" "Start right") (list "progressive-start-t" "Start top") (list "progressive-end-l" "End left") (list "progressive-end-b" "End bottom") (list "progressive-end-r" "End right") (list "progressive-end-t" "End top"))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote fade-in))) (tm-define-overloaded (customizable-parameters t) (list (list "fade-start" "Start intensity"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote fade-in))) (tm-define-overloaded (customizable-parameters t) (list (list "fade-start" "Start intensity"))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote fade-out))) (tm-define-overloaded (customizable-parameters t) (list (list "fade-end" "End intensity"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote fade-out))) (tm-define-overloaded (customizable-parameters t) (list (list "fade-end" "End intensity"))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote fade-smooth))) (tm-define-overloaded (customizable-parameters t) (list (list "fade-start" "Start intensity") (list "fade-end" "End intensity"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote fade-smooth))) (tm-define-overloaded (customizable-parameters t) (list (list "fade-start" "Start intensity") (list "fade-end" "End intensity"))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote zoom-in))) (tm-define-overloaded (customizable-parameters t) (list (list "zoom-start" "Start magnification"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote zoom-in))) (tm-define-overloaded (customizable-parameters t) (list (list "zoom-start" "Start magnification"))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote zoom-out))) (tm-define-overloaded (customizable-parameters t) (list (list "zoom-end" "End magnification"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote zoom-out))) (tm-define-overloaded (customizable-parameters t) (list (list "zoom-end" "End magnification"))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote zoom-smooth))) (tm-define-overloaded (customizable-parameters t) (list (list "zoom-start" "Start magnification") (list "zoom-end" "End magnification"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote zoom-smooth))) (tm-define-overloaded (customizable-parameters t) (list (list "zoom-start" "Start magnification") (list "zoom-end" "End magnification"))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (shadowed-smooth emboss-smooth outlined-emboss-smooth)))) (tm-define-overloaded (customizable-parameters t) (list (list "emboss-start-dx" "Start dx") (list "emboss-start-dy" "Start dy") (list "emboss-end-dx" "End dx") (list "emboss-end-dy" "End dy"))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (shadowed-smooth emboss-smooth outlined-emboss-smooth)))) (tm-define-overloaded (customizable-parameters t) (list (list "emboss-start-dx" "Start dx") (list "emboss-start-dy" "Start dy") (list "emboss-end-dx" "End dx") (list "emboss-end-dy" "End dy"))))

  (define-option-argument opt decl)
    <= ((duration "Duration") (tm-define-overloaded (make-anim-constant duration) (insert-go-to (quasiquote (anim-constant "" (unquote duration))) (quote (0 0)))))
    => cons <> cur-props <= ((quote make-anim-constant) #:arguments (quote (duration)))
    => cons <> cur-props <= ((quote make-anim-constant) (quote (#:argument duration)) (quote ("Duration")))
    => cur-props => (((quote make-anim-constant) (quote (#:argument duration)) (quote ("Duration"))) ((quote make-anim-constant) #:arguments (quote (duration))))

(property-set! var prop what conds*)
  <= (make-anim-constant (#:argument duration) ("Duration") ())

(property-set! var prop what conds*)
  <= (make-anim-constant #:arguments (duration) ())

  (define-option-argument opt decl)
    <= ((duration "Duration") (tm-define-overloaded (make-anim-translate-right duration) (make-anim-translate duration (quote (tuple "-1.0" "0.0")))))
    => cons <> cur-props <= ((quote make-anim-translate-right) #:arguments (quote (duration)))
    => cons <> cur-props <= ((quote make-anim-translate-right) (quote (#:argument duration)) (quote ("Duration")))
    => cur-props => (((quote make-anim-translate-right) (quote (#:argument duration)) (quote ("Duration"))) ((quote make-anim-translate-right) #:arguments (quote (duration))))

(property-set! var prop what conds*)
  <= (make-anim-translate-right (#:argument duration) ("Duration") ())

(property-set! var prop what conds*)
  <= (make-anim-translate-right #:arguments (duration) ())

  (define-option-argument opt decl)
    <= ((duration "Duration") (tm-define-overloaded (make-anim-translate-left duration) (make-anim-translate duration (quote (tuple "1.0" "0.0")))))
    => cons <> cur-props <= ((quote make-anim-translate-left) #:arguments (quote (duration)))
    => cons <> cur-props <= ((quote make-anim-translate-left) (quote (#:argument duration)) (quote ("Duration")))
    => cur-props => (((quote make-anim-translate-left) (quote (#:argument duration)) (quote ("Duration"))) ((quote make-anim-translate-left) #:arguments (quote (duration))))

(property-set! var prop what conds*)
  <= (make-anim-translate-left (#:argument duration) ("Duration") ())

(property-set! var prop what conds*)
  <= (make-anim-translate-left #:arguments (duration) ())

  (define-option-argument opt decl)
    <= ((duration "Duration") (tm-define-overloaded (make-anim-translate-up duration) (make-anim-translate duration (quote (tuple "0.0" "-1.0")))))
    => cons <> cur-props <= ((quote make-anim-translate-up) #:arguments (quote (duration)))
    => cons <> cur-props <= ((quote make-anim-translate-up) (quote (#:argument duration)) (quote ("Duration")))
    => cur-props => (((quote make-anim-translate-up) (quote (#:argument duration)) (quote ("Duration"))) ((quote make-anim-translate-up) #:arguments (quote (duration))))

(property-set! var prop what conds*)
  <= (make-anim-translate-up (#:argument duration) ("Duration") ())

(property-set! var prop what conds*)
  <= (make-anim-translate-up #:arguments (duration) ())

  (define-option-argument opt decl)
    <= ((duration "Duration") (tm-define-overloaded (make-anim-translate-down duration) (make-anim-translate duration (quote (tuple "0.0" "1.0")))))
    => cons <> cur-props <= ((quote make-anim-translate-down) #:arguments (quote (duration)))
    => cons <> cur-props <= ((quote make-anim-translate-down) (quote (#:argument duration)) (quote ("Duration")))
    => cur-props => (((quote make-anim-translate-down) (quote (#:argument duration)) (quote ("Duration"))) ((quote make-anim-translate-down) #:arguments (quote (duration))))

(property-set! var prop what conds*)
  <= (make-anim-translate-down (#:argument duration) ("Duration") ())

(property-set! var prop what conds*)
  <= (make-anim-translate-down #:arguments (duration) ())

  (define-option-argument opt decl)
    <= ((duration "Duration") (tm-define-overloaded (make-anim-progressive-right duration) (make-anim-progressive duration (quote (tuple "0.0" "0.0" "0.0" "1.0")))))
    => cons <> cur-props <= ((quote make-anim-progressive-right) #:arguments (quote (duration)))
    => cons <> cur-props <= ((quote make-anim-progressive-right) (quote (#:argument duration)) (quote ("Duration")))
    => cur-props => (((quote make-anim-progressive-right) (quote (#:argument duration)) (quote ("Duration"))) ((quote make-anim-progressive-right) #:arguments (quote (duration))))

(property-set! var prop what conds*)
  <= (make-anim-progressive-right (#:argument duration) ("Duration") ())

(property-set! var prop what conds*)
  <= (make-anim-progressive-right #:arguments (duration) ())

  (define-option-argument opt decl)
    <= ((duration "Duration") (tm-define-overloaded (make-anim-progressive-left duration) (make-anim-progressive duration (quote (tuple "1.0" "0.0" "1.0" "1.0")))))
    => cons <> cur-props <= ((quote make-anim-progressive-left) #:arguments (quote (duration)))
    => cons <> cur-props <= ((quote make-anim-progressive-left) (quote (#:argument duration)) (quote ("Duration")))
    => cur-props => (((quote make-anim-progressive-left) (quote (#:argument duration)) (quote ("Duration"))) ((quote make-anim-progressive-left) #:arguments (quote (duration))))

(property-set! var prop what conds*)
  <= (make-anim-progressive-left (#:argument duration) ("Duration") ())

(property-set! var prop what conds*)
  <= (make-anim-progressive-left #:arguments (duration) ())

  (define-option-argument opt decl)
    <= ((duration "Duration") (tm-define-overloaded (make-anim-progressive-up duration) (make-anim-progressive duration (quote (tuple "0.0" "0.0" "1.0" "0.0")))))
    => cons <> cur-props <= ((quote make-anim-progressive-up) #:arguments (quote (duration)))
    => cons <> cur-props <= ((quote make-anim-progressive-up) (quote (#:argument duration)) (quote ("Duration")))
    => cur-props => (((quote make-anim-progressive-up) (quote (#:argument duration)) (quote ("Duration"))) ((quote make-anim-progressive-up) #:arguments (quote (duration))))

(property-set! var prop what conds*)
  <= (make-anim-progressive-up (#:argument duration) ("Duration") ())

(property-set! var prop what conds*)
  <= (make-anim-progressive-up #:arguments (duration) ())

  (define-option-argument opt decl)
    <= ((duration "Duration") (tm-define-overloaded (make-anim-progressive-down duration) (make-anim-progressive duration (quote (tuple "0.0" "1.0" "1.0" "1.0")))))
    => cons <> cur-props <= ((quote make-anim-progressive-down) #:arguments (quote (duration)))
    => cons <> cur-props <= ((quote make-anim-progressive-down) (quote (#:argument duration)) (quote ("Duration")))
    => cur-props => (((quote make-anim-progressive-down) (quote (#:argument duration)) (quote ("Duration"))) ((quote make-anim-progressive-down) #:arguments (quote (duration))))

(property-set! var prop what conds*)
  <= (make-anim-progressive-down (#:argument duration) ("Duration") ())

(property-set! var prop what conds*)
  <= (make-anim-progressive-down #:arguments (duration) ())

  (define-option-argument opt decl)
    <= ((duration "Duration") (tm-define-overloaded (make-anim-progressive-center duration) (make-anim-progressive duration (quote (tuple "0.5" "0.5" "0.5" "0.5")))))
    => cons <> cur-props <= ((quote make-anim-progressive-center) #:arguments (quote (duration)))
    => cons <> cur-props <= ((quote make-anim-progressive-center) (quote (#:argument duration)) (quote ("Duration")))
    => cur-props => (((quote make-anim-progressive-center) (quote (#:argument duration)) (quote ("Duration"))) ((quote make-anim-progressive-center) #:arguments (quote (duration))))

(property-set! var prop what conds*)
  <= (make-anim-progressive-center (#:argument duration) ("Duration") ())

(property-set! var prop what conds*)
  <= (make-anim-progressive-center #:arguments (duration) ())

  (define-option-require opt decl)
    <= (((anim-context? t)) (tm-define-overloaded (geometry-speed t inc?) (with inc (if inc? 1 -1) (with-focus-after t (length-increase-step (tree-ref t 1) inc)))))
    => (define-option-match opt decl) <= ((lambda (t inc?) (anim-context? t)) (tm-define-overloaded (geometry-speed t inc?) (with inc (if inc? 1 -1) (with-focus-after t (length-increase-step (tree-ref t 1) inc)))))

  (define-option-require opt decl)
    <= (((anim-context? t)) (tm-define-overloaded (geometry-horizontal t forward?) (with inc (if forward? 1 -1) (with-focus-after t (replace-empty t 1 "1s") (length-increase (tree-ref t 1) inc)))))
    => (define-option-match opt decl) <= ((lambda (t forward?) (anim-context? t)) (tm-define-overloaded (geometry-horizontal t forward?) (with inc (if forward? 1 -1) (with-focus-after t (replace-empty t 1 "1s") (length-increase (tree-ref t 1) inc)))))

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" accelerate-test-type?) (tm-define-overloaded (accelerate-set-type t new-type) (and-with a (anim-get-accelerate t) (if (tree-func? a (quote anim-accelerate) 2) (if (== new-type "normal") (tree-remove-node! a 0) (tree-set (tree-ref a 1) new-type)) (if (!= new-type "normal") (tree-set! a (quasiquote (anim-accelerate (unquote a) (unquote new-type)))))) (reset-players a))))
    => ((quote accelerate-set-type) #:check-mark (list "*" accelerate-test-type?))
 => cons <> cur-props
    => cur-props => (((quote accelerate-set-type) #:check-mark (list "*" accelerate-test-type?)))

(property-set! var prop what conds*)
  <= (accelerate-set-type #:check-mark ("*" #<procedure accelerate-test-type? (dummy new-type)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" accelerate-test-reverse?) (tm-define-overloaded (accelerate-toggle-reverse? t) (accelerate-set-type** t (accelerate-get-type* t) (not (accelerate-get-reverse? t)))))
    => ((quote accelerate-toggle-reverse?) #:check-mark (list "*" accelerate-test-reverse?))
 => cons <> cur-props
    => cur-props => (((quote accelerate-toggle-reverse?) #:check-mark (list "*" accelerate-test-reverse?)))

(property-set! var prop what conds*)
  <= (accelerate-toggle-reverse? #:check-mark ("*" #<procedure accelerate-test-reverse? (dummy)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" accelerate-test-type*?) (tm-define-overloaded (accelerate-set-type* t new-type) (accelerate-set-type** t new-type (accelerate-get-reverse? t))))
    => ((quote accelerate-set-type*) #:check-mark (list "*" accelerate-test-type*?))
 => cons <> cur-props
    => cur-props => (((quote accelerate-set-type*) #:check-mark (list "*" accelerate-test-type*?)))

(property-set! var prop what conds*)
  <= (accelerate-set-type* #:check-mark ("*" #<procedure accelerate-test-type*? (dummy new-type)>) ())

  (define-option-argument opt decl)
    <= ((len "Duration") (tm-define-overloaded (retime-selection type) (with sel (selection-tree) (clipboard-cut "primary") (insert-go-to (quasiquote (anim-accelerate (unquote sel) (unquote type))) (cons 0 (path-end sel (list)))))))
    => cons <> cur-props <= ((quote retime-selection) #:arguments (quote (type)))
    => cons <> cur-props <= ((quote retime-selection) (quote (#:argument len)) (quote ("Duration")))
    => cur-props => (((quote retime-selection) (quote (#:argument len)) (quote ("Duration"))) ((quote retime-selection) #:arguments (quote (type))))

(property-set! var prop what conds*)
  <= (retime-selection (#:argument len) ("Duration") ())

(property-set! var prop what conds*)
  <= (retime-selection #:arguments (type) ())

  (define-option-argument opt decl)
    <= ((len "Duration") (tm-define-overloaded (animate-selection len) (with sel (selection-tree) (clipboard-cut "primary") (make-animate sel len) (set-bottom-bar "animate" #t))))
    => cons <> cur-props <= ((quote animate-selection) #:arguments (quote (len)))
    => cons <> cur-props <= ((quote animate-selection) (quote (#:argument len)) (quote ("Duration")))
    => cur-props => (((quote animate-selection) (quote (#:argument len)) (quote ("Duration"))) ((quote animate-selection) #:arguments (quote (len))))

(property-set! var prop what conds*)
  <= (animate-selection (#:argument len) ("Duration") ())

(property-set! var prop what conds*)
  <= (animate-selection #:arguments (len) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" anim-test-new-mode?) (tm-define-overloaded (anim-set-new-mode s) (set! anim-new-mode s)))
    => ((quote anim-set-new-mode) #:check-mark (list "*" anim-test-new-mode?))
 => cons <> cur-props
    => cur-props => (((quote anim-set-new-mode) #:check-mark (list "*" anim-test-new-mode?)))

(property-set! var prop what conds*)
  <= (anim-set-new-mode #:check-mark ("*" #<procedure anim-test-new-mode? (s)>) ())

  (define-option-require opt decl)
    <= (((== (graphics-mode) (quote (group-edit edit-props)))) (tm-define-overloaded (graphics-mode-attribute? mode var) (with v (if (string-starts? var "gr-") (string-drop var 3) var) (with l (map (cut has-attribute? <> v) (sketch-get)) (list-or l)))))
    => (define-option-match opt decl) <= ((lambda (mode var) (== (graphics-mode) (quote (group-edit edit-props)))) (tm-define-overloaded (graphics-mode-attribute? mode var) (with v (if (string-starts? var "gr-") (string-drop var 3) var) (with l (map (cut has-attribute? <> v) (sketch-get)) (list-or l)))))

  (define-option-require opt decl)
    <= (((and (== (graphics-mode) (quote (group-edit edit-props))) (graphics-selection-active?))) (tm-define-overloaded (graphics-get-property var) (with v (if (string-starts? var "gr-") (string-drop var 3) var) (if (graphics-mode-attribute? (graphics-mode) v) (with l (map (cut property-get <> v 0) (sketch-get)) (properties-and l)) (former var)))))
    => (define-option-match opt decl) <= ((lambda (var) (and (== (graphics-mode) (quote (group-edit edit-props))) (graphics-selection-active?))) (tm-define-overloaded (graphics-get-property var) (with v (if (string-starts? var "gr-") (string-drop var 3) var) (if (graphics-mode-attribute? (graphics-mode) v) (with l (map (cut property-get <> v 0) (sketch-get)) (properties-and l)) (former var)))))

  (define-option-require opt decl)
    <= (((and (== (graphics-mode) (quote (group-edit edit-props))) (graphics-selection-active?))) (tm-define-overloaded (graphics-set-property var val) (with v (if (string-starts? var "gr-") (string-drop var 3) var) (if (graphics-mode-attribute? (graphics-mode) v) (with r (map (cut property-set <> v val) (sketch-get)) (sketch-set! r)) (former var val)))))
    => (define-option-match opt decl) <= ((lambda (var val) (and (== (graphics-mode) (quote (group-edit edit-props))) (graphics-selection-active?))) (tm-define-overloaded (graphics-set-property var val) (with v (if (string-starts? var "gr-") (string-drop var 3) var) (if (graphics-mode-attribute? (graphics-mode) v) (with r (map (cut property-set <> v val) (sketch-get)) (sketch-set! r)) (former var val)))))

  (define-option-require opt decl)
    <= (((graphical-non-group-tag? (car obj))) (tm-define-overloaded (start-operation opn p obj) (set! current-path #f) (if (not sticky-point) (set! preselected (nnull? (sketch-get)))) (cond (sticky-point (sketch-commit) (graphics-decorations-update) (if (== (state-ref graphics-first-state (quote graphics-action)) (quote start-operation)) (remove-undo-mark)) (set! graphics-undo-enabled #t) (graphics-forget-states) (if (not preselected) (unselect-all p obj)) (set! preselected #f)) ((and (not multiselecting) (eq? (cadr (graphics-mode)) (quote group-ungroup))) (if (and p (not sticky-point) (null? (sketch-get)) (== (tree-label (path->tree p)) (quote gr-group))) (sketch-set! (quasiquote ((unquote (path->tree p)))))) (if (and (not sticky-point) (== (length (sketch-get)) 1) (== (tree-label (car (sketch-get))) (quote gr-group))) (ungroup-current-object) (group-selected-objects))) ((and (not multiselecting) (== (cadr (graphics-mode)) (quote props))) (if (null? (sketch-get)) (if p (begin (set! obj (stree-at p)) (set! current-path (graphics-assign-props p obj)) (set! current-obj obj) (graphics-decorations-update))) (with l (quote ()) (for (o (sketch-get)) (with p (graphics-assign-props (tree->path o) (tree->stree o)) (set! l (cons (path->tree p) l)))) (sketch-set! (reverse l)) (graphics-decorations-update))) (graphics-group-start)) ((and (not multiselecting) (or p (nnull? (sketch-get)))) (if (null? (sketch-get)) (any_toggle-select #f #f p obj)) (store-important-points) (graphics-store-state (quote start-operation)) (sketch-checkout) (sketch-transform tree->stree) (set! group-first-go (copy-tree (sketch-get))) (set! graphics-undo-enabled #f) (graphics-store-state #f) (set! group-old-x (s2f current-x)) (set! group-old-y (s2f current-y))))))
    => (define-option-match opt decl) <= ((lambda (opn p obj) (graphical-non-group-tag? (car obj))) (tm-define-overloaded (start-operation opn p obj) (set! current-path #f) (if (not sticky-point) (set! preselected (nnull? (sketch-get)))) (cond (sticky-point (sketch-commit) (graphics-decorations-update) (if (== (state-ref graphics-first-state (quote graphics-action)) (quote start-operation)) (remove-undo-mark)) (set! graphics-undo-enabled #t) (graphics-forget-states) (if (not preselected) (unselect-all p obj)) (set! preselected #f)) ((and (not multiselecting) (eq? (cadr (graphics-mode)) (quote group-ungroup))) (if (and p (not sticky-point) (null? (sketch-get)) (== (tree-label (path->tree p)) (quote gr-group))) (sketch-set! (quasiquote ((unquote (path->tree p)))))) (if (and (not sticky-point) (== (length (sketch-get)) 1) (== (tree-label (car (sketch-get))) (quote gr-group))) (ungroup-current-object) (group-selected-objects))) ((and (not multiselecting) (== (cadr (graphics-mode)) (quote props))) (if (null? (sketch-get)) (if p (begin (set! obj (stree-at p)) (set! current-path (graphics-assign-props p obj)) (set! current-obj obj) (graphics-decorations-update))) (with l (quote ()) (for (o (sketch-get)) (with p (graphics-assign-props (tree->path o) (tree->stree o)) (set! l (cons (path->tree p) l)))) (sketch-set! (reverse l)) (graphics-decorations-update))) (graphics-group-start)) ((and (not multiselecting) (or p (nnull? (sketch-get)))) (if (null? (sketch-get)) (any_toggle-select #f #f p obj)) (store-important-points) (graphics-store-state (quote start-operation)) (sketch-checkout) (sketch-transform tree->stree) (set! group-first-go (copy-tree (sketch-get))) (set! graphics-undo-enabled #f) (graphics-store-state #f) (set! group-old-x (s2f current-x)) (set! group-old-y (s2f current-y))))))

  (define-option-require opt decl)
    <= (((graphical-non-group-tag? (car obj))) (tm-define-overloaded (toggle-select x y p obj) (when (list? p) (and-with t (path->tree p) (tree-go-to t #:end))) (any_toggle-select x y p obj)))
    => (define-option-match opt decl) <= ((lambda (x y p obj) (graphical-non-group-tag? (car obj))) (tm-define-overloaded (toggle-select x y p obj) (when (list? p) (and-with t (path->tree p) (tree-go-to t #:end))) (any_toggle-select x y p obj)))

  (define-option-require opt decl)
    <= (((graphical-non-group-tag? (car obj))) (tm-define-overloaded (unselect-all p obj) (any_unselect-all p obj)))
    => (define-option-match opt decl) <= ((lambda (p obj) (graphical-non-group-tag? (car obj))) (tm-define-overloaded (unselect-all p obj) (any_unselect-all p obj)))

  (define-option-require opt decl)
    <= (((eq? mode (quote group-edit))) (tm-define-overloaded (edit_move mode x y) (with-state-by-name graphics-state (cond (sticky-point (set! x (s2f x)) (set! y (s2f y)) (with mode (graphics-mode) (cond ((== (cadr mode) (quote move)) (sketch-transform (group-translate (- x group-old-x) (- y group-old-y)))) ((== (cadr mode) (quote zoom)) (sketch-set! group-first-go) (sketch-transform (group-zoom x y))) ((== (cadr mode) (quote rotate)) (sketch-set! group-first-go) (sketch-transform (group-rotate x y))))) (set! group-old-x x) (set! group-old-y y)) (multiselecting (graphical-object! (append (create-graphical-props (quote default) #f) (quasiquote ((with color red (cline (point (unquote selecting-x0) (unquote selecting-y0)) (point (unquote x) (unquote selecting-y0)) (point (unquote x) (unquote y)) (point (unquote selecting-x0) (unquote y))))))))) (else (cond (current-path (set-message (string-append "Left click: operate; " "Right click: select/unselect") "Group of objects")) ((nnull? (sketch-get)) (set-message "Left click: operate" "Group of objects")) (else (set-message "Move over object on which to operate" "Edit groups of objects"))) (graphics-decorations-update))))))
    => (define-option-match opt decl) <= ((lambda (mode x y) (eq? mode (quote group-edit))) (tm-define-overloaded (edit_move mode x y) (with-state-by-name graphics-state (cond (sticky-point (set! x (s2f x)) (set! y (s2f y)) (with mode (graphics-mode) (cond ((== (cadr mode) (quote move)) (sketch-transform (group-translate (- x group-old-x) (- y group-old-y)))) ((== (cadr mode) (quote zoom)) (sketch-set! group-first-go) (sketch-transform (group-zoom x y))) ((== (cadr mode) (quote rotate)) (sketch-set! group-first-go) (sketch-transform (group-rotate x y))))) (set! group-old-x x) (set! group-old-y y)) (multiselecting (graphical-object! (append (create-graphical-props (quote default) #f) (quasiquote ((with color red (cline (point (unquote selecting-x0) (unquote selecting-y0)) (point (unquote x) (unquote selecting-y0)) (point (unquote x) (unquote y)) (point (unquote selecting-x0) (unquote y))))))))) (else (cond (current-path (set-message (string-append "Left click: operate; " "Right click: select/unselect") "Group of objects")) ((nnull? (sketch-get)) (set-message "Left click: operate" "Group of objects")) (else (set-message "Move over object on which to operate" "Edit groups of objects"))) (graphics-decorations-update))))))

  (define-option-require opt decl)
    <= (((and (== mode (quote edit)) (current-in? (quote (gr-group))))) (tm-define-overloaded (edit_move mode x y) (with-state-by-name graphics-state (if sticky-point (display* "Uncaptured graphical move " mode ", " x ", " y "
") (begin (set! current-point-no #f) (graphics-decorations-update))))))
    => (define-option-match opt decl) <= ((lambda (mode x y) (and (== mode (quote edit)) (current-in? (quote (gr-group))))) (tm-define-overloaded (edit_move mode x y) (with-state-by-name graphics-state (if sticky-point (display* "Uncaptured graphical move " mode ", " x ", " y "
") (begin (set! current-point-no #f) (graphics-decorations-update))))))

  (define-option-require opt decl)
    <= (((eq? mode (quote group-edit))) (tm-define-overloaded (edit_left-button mode x y) (with-state-by-name graphics-state (start-operation (quote move) current-path current-obj))))
    => (define-option-match opt decl) <= ((lambda (mode x y) (eq? mode (quote group-edit))) (tm-define-overloaded (edit_left-button mode x y) (with-state-by-name graphics-state (start-operation (quote move) current-path current-obj))))

  (define-option-require opt decl)
    <= (((in? (graphics-mode) (quote ((group-edit edit-props) (group-edit animate))))) (tm-define-overloaded (edit_left-button mode x y) (with-state-by-name graphics-state (if (and (not current-path) (graphics-selection-active?)) (unselect-all current-path current-obj) (begin (unselect-all current-path current-obj) (toggle-select x y current-path current-obj))))))
    => (define-option-match opt decl) <= ((lambda (mode x y) (in? (graphics-mode) (quote ((group-edit edit-props) (group-edit animate))))) (tm-define-overloaded (edit_left-button mode x y) (with-state-by-name graphics-state (if (and (not current-path) (graphics-selection-active?)) (unselect-all current-path current-obj) (begin (unselect-all current-path current-obj) (toggle-select x y current-path current-obj))))))

  (define-option-require opt decl)
    <= (((eq? mode (quote group-edit))) (tm-define-overloaded (edit_right-button mode x y) (with-state-by-name graphics-state (if (and (not current-path) (graphics-selection-active?)) (unselect-all current-path current-obj) (toggle-select x y current-path current-obj)))))
    => (define-option-match opt decl) <= ((lambda (mode x y) (eq? mode (quote group-edit))) (tm-define-overloaded (edit_right-button mode x y) (with-state-by-name graphics-state (if (and (not current-path) (graphics-selection-active?)) (unselect-all current-path current-obj) (toggle-select x y current-path current-obj)))))

  (define-option-require opt decl)
    <= (((eq? mode (quote group-edit))) (tm-define-overloaded (edit_middle-button mode x y) (with-state-by-name graphics-state (if (!= (logand (get-keyboard-modifiers) ShiftMask) 0) (if (null? (sketch-get)) (graphics-delete) (remove-selected-objects)) (unselect-all current-path current-obj)))))
    => (define-option-match opt decl) <= ((lambda (mode x y) (eq? mode (quote group-edit))) (tm-define-overloaded (edit_middle-button mode x y) (with-state-by-name graphics-state (if (!= (logand (get-keyboard-modifiers) ShiftMask) 0) (if (null? (sketch-get)) (graphics-delete) (remove-selected-objects)) (unselect-all current-path current-obj)))))

  (define-option-require opt decl)
    <= (((eq? mode (quote group-edit))) (tm-define-overloaded (edit_tab-key mode inc) (edit_tab-key (quote edit) inc)))
    => (define-option-match opt decl) <= ((lambda (mode inc) (eq? mode (quote group-edit))) (tm-define-overloaded (edit_tab-key mode inc) (edit_tab-key (quote edit) inc)))

  (define-option-require opt decl)
    <= (((group-edit-macro-arg? mode)) (tm-define-overloaded (edit_move mode x y) (with-state-by-name graphics-state (noop))))
    => (define-option-match opt decl) <= ((lambda (mode x y) (group-edit-macro-arg? mode)) (tm-define-overloaded (edit_move mode x y) (with-state-by-name graphics-state (noop))))

  (define-option-require opt decl)
    <= (((group-edit-macro-arg? mode)) (tm-define-overloaded (edit_left-button mode x y) (with-state-by-name graphics-state (noop))))
    => (define-option-match opt decl) <= ((lambda (mode x y) (group-edit-macro-arg? mode)) (tm-define-overloaded (edit_left-button mode x y) (with-state-by-name graphics-state (noop))))

  (define-option-require opt decl)
    <= (((group-edit-macro-arg? mode)) (tm-define-overloaded (edit_right-button mode x y) (with-state-by-name graphics-state (noop))))
    => (define-option-match opt decl) <= ((lambda (mode x y) (group-edit-macro-arg? mode)) (tm-define-overloaded (edit_right-button mode x y) (with-state-by-name graphics-state (noop))))

  (define-option-require opt decl)
    <= (((group-edit-macro-arg? mode)) (tm-define-overloaded (edit_middle-button mode x y) (with-state-by-name graphics-state (noop))))
    => (define-option-match opt decl) <= ((lambda (mode x y) (group-edit-macro-arg? mode)) (tm-define-overloaded (edit_middle-button mode x y) (with-state-by-name graphics-state (noop))))

  (define-option-require opt decl)
    <= (((and (== (graphics-mode) (quote (group-edit animate))) (graphics-selection-active?))) (tm-define-overloaded (graphics-get-anim-type) (with l (map anim-type-get (sketch-get)) (properties-and l))))
    => (define-option-match opt decl) <= ((lambda () (and (== (graphics-mode) (quote (group-edit animate))) (graphics-selection-active?))) (tm-define-overloaded (graphics-get-anim-type) (with l (map anim-type-get (sketch-get)) (properties-and l))))

  (define-option-require opt decl)
    <= (((and (== (graphics-mode) (quote (group-edit animate))) (graphics-selection-active?))) (tm-define-overloaded (graphics-set-anim-type val) (with r (map (cut anim-type-set <> val) (sketch-get)) (sketch-set! r))))
    => (define-option-match opt decl) <= ((lambda (val) (and (== (graphics-mode) (quote (group-edit animate))) (graphics-selection-active?))) (tm-define-overloaded (graphics-set-anim-type val) (with r (map (cut anim-type-set <> val) (sketch-get)) (sketch-set! r))))

  (define-option-require opt decl)
    <= (((graphics-group-selection?)) (tm-define-overloaded (current-anim-remove) (sketch-map! anim-principal)))
    => (define-option-match opt decl) <= ((lambda () (graphics-group-selection?)) (tm-define-overloaded (current-anim-remove) (sketch-map! anim-principal)))

  (define-option-require opt decl)
    <= (((graphics-group-selection?)) (tm-define-overloaded (current-anim-can-copy?) #t))
    => (define-option-match opt decl) <= ((lambda () (graphics-group-selection?)) (tm-define-overloaded (current-anim-can-copy?) #t))

  (define-option-require opt decl)
    <= (((graphics-group-selection?)) (tm-define-overloaded (current-anim-copy-after) (sketch-map! (lambda (t) (anim-copy-to t >=)))))
    => (define-option-match opt decl) <= ((lambda () (graphics-group-selection?)) (tm-define-overloaded (current-anim-copy-after) (sketch-map! (lambda (t) (anim-copy-to t >=)))))

  (define-option-require opt decl)
    <= (((graphics-group-selection?)) (tm-define-overloaded (current-anim-copy-before) (sketch-map! (lambda (t) (anim-copy-to t <=)))))
    => (define-option-match opt decl) <= ((lambda () (graphics-group-selection?)) (tm-define-overloaded (current-anim-copy-before) (sketch-map! (lambda (t) (anim-copy-to t <=)))))

  (define-option-require opt decl)
    <= (((graphics-group-selection?)) (tm-define-overloaded (current-anim-copy-all) (sketch-map! (lambda (t) (anim-copy-to t always?)))))
    => (define-option-match opt decl) <= ((lambda () (graphics-group-selection?)) (tm-define-overloaded (current-anim-copy-all) (sketch-map! (lambda (t) (anim-copy-to t always?)))))

  (define-option-require opt decl)
    <= (((graphics-group-selection?)) (tm-define-overloaded (current-anim-delete-after) (sketch-map! (lambda (t) (anim-delete-from t >)))))
    => (define-option-match opt decl) <= ((lambda () (graphics-group-selection?)) (tm-define-overloaded (current-anim-delete-after) (sketch-map! (lambda (t) (anim-delete-from t >)))))

  (define-option-require opt decl)
    <= (((graphics-group-selection?)) (tm-define-overloaded (current-anim-delete-before) (sketch-map! (lambda (t) (anim-delete-from t <)))))
    => (define-option-match opt decl) <= ((lambda () (graphics-group-selection?)) (tm-define-overloaded (current-anim-delete-before) (sketch-map! (lambda (t) (anim-delete-from t <)))))

  (define-option-require opt decl)
    <= (((and (inside? (quote graphics)) (!= (car (graphics-mode)) (quote group-edit)))) (tm-define-overloaded (anim-show-new-mode?) #t))
    => (define-option-match opt decl) <= ((lambda () (and (inside? (quote graphics)) (!= (car (graphics-mode)) (quote group-edit)))) (tm-define-overloaded (anim-show-new-mode?) #t))

  (define-option-require opt decl)
    <= (((and (tree-is? t (quote anim-edit)) (tree-get-graphics (tree-ref t 1)))) (tm-define-overloaded (commit-animation t) (with g (tree-get-graphics (tree-ref t 1)) (for-each (cut commit-prepare t <>) (tree-children g)) (former t))))
    => (define-option-match opt decl) <= ((lambda (t) (and (tree-is? t (quote anim-edit)) (tree-get-graphics (tree-ref t 1)))) (tm-define-overloaded (commit-animation t) (with g (tree-get-graphics (tree-ref t 1)) (for-each (cut commit-prepare t <>) (tree-children g)) (former t))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (kbd-insert s) (wrap-insert (lambda () (former s)))))
    => (define-option-match opt decl) <= ((lambda (s) (in-sem-math?)) (tm-define-overloaded (kbd-insert s) (wrap-insert (lambda () (former s)))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (kbd-backspace) (wrap-remove former #f)))
    => (define-option-match opt decl) <= ((lambda () (in-sem-math?)) (tm-define-overloaded (kbd-backspace) (wrap-remove former #f)))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (kbd-delete) (wrap-remove former #t)))
    => (define-option-match opt decl) <= ((lambda () (in-sem-math?)) (tm-define-overloaded (kbd-delete) (wrap-remove former #t)))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (math-insert . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (math-insert . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (make . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (make . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (math-big-operator . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (math-big-operator . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (math-bracket-open . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (math-bracket-open . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (math-separator . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (math-separator . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (math-bracket-close . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (math-bracket-close . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (make-rigid . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (make-rigid . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (make-lprime . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (make-lprime . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (make-rprime . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (make-rprime . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (make-below . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (make-below . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (make-above . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (make-above . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (make-script . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (make-script . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (make-fraction . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (make-fraction . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (make-sqrt . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (make-sqrt . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (make-wide . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (make-wide . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (make-wide-under . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (make-wide-under . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (make-neg . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (make-neg . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (make-tree . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (make-tree . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (make-long-arrow . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (make-long-arrow . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (make-long-arrow* . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (make-long-arrow* . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (kbd-space . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (kbd-space . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (kbd-shift-space . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (kbd-shift-space . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (kbd-return . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (kbd-return . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (kbd-shift-return . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (kbd-shift-return . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (kbd-control-return . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (kbd-control-return . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (kbd-shift-control-return . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (kbd-shift-control-return . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (kbd-alternate-return . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (kbd-alternate-return . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (kbd-shift-alternate-return . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (kbd-shift-alternate-return . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (structured-insert-left . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (structured-insert-left . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (structured-insert-right . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (structured-insert-right . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (structured-insert-up . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (structured-insert-up . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (structured-insert-down . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (structured-insert-down . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (structured-insert-start . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (structured-insert-start . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (structured-insert-end . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (structured-insert-end . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (structured-insert-top . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (structured-insert-top . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (structured-insert-bottom . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (structured-insert-bottom . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (clipboard-cut . l) (with cmd (lambda () (apply former l)) (wrap-remove cmd #f))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (clipboard-cut . l) (with cmd (lambda () (apply former l)) (wrap-remove cmd #f))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (clipboard-paste . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (clipboard-paste . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (make-hybrid . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))
    => (define-option-match opt decl) <= ((lambda l (in-sem-math?)) (tm-define-overloaded (make-hybrid . l) (with cmd (lambda () (apply former l)) (wrap-insert cmd))))

  (define-option-require opt decl)
    <= (((and (tree-is? t (quote hybrid)) (in-sem?) (tree-in-math? t))) (tm-define-overloaded (kbd-enter t forwards?) (with cmd (lambda () (activate-hybrid #f)) (perform-insert cmd))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (and (tree-is? t (quote hybrid)) (in-sem?) (tree-in-math? t))) (tm-define-overloaded (kbd-enter t forwards?) (with cmd (lambda () (activate-hybrid #f)) (perform-insert cmd))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (kbd-space) (when (kbd-space-ok?) (former))))
    => (define-option-match opt decl) <= ((lambda () (in-sem-math?)) (tm-define-overloaded (kbd-space) (when (kbd-space-ok?) (former))))

  (define-option-require opt decl)
    <= (((in-sem-math?)) (tm-define-overloaded (kbd-shift-space) (when (kbd-space-ok?) (former))))
    => (define-option-match opt decl) <= ((lambda () (in-sem-math?)) (tm-define-overloaded (kbd-shift-space) (when (kbd-space-ok?) (former))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Url of the cache with the collected scheme documentation.") (tm-define-overloaded (doc-scm-cache) (with pref (get-preference "doc:doc-scm-cache") (if (and (!= pref "default") (url-exists? (system->url pref))) (system->url pref) (with new (persistent-file-name (unix->url "$TEXMACS_HOME_PATH/system/cache/") "api") (set-preference "doc:doc-scm-cache" (url->system new)) new)))))
   => ((quote doc-scm-cache) #:synopsis (quote ("Url of the cache with the collected scheme documentation.")))
 => cons <> cur-props
   => cur-props => (((quote doc-scm-cache) #:synopsis (quote ("Url of the cache with the collected scheme documentation."))))

(property-set! var prop what conds*)
  <= (doc-scm-cache #:synopsis ("Url of the cache with the collected scheme documentation.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Url of the cache with the collected macro documentation.") (tm-define-overloaded (doc-macro-cache) (with pref (get-preference "doc:doc-macro-cache") (if (and (!= pref "default") (url-exists? (system->url pref))) (system->url pref) (with new (persistent-file-name (unix->url "$TEXMACS_HOME_PATH/system/cache/") "api") (set-preference "doc:doc-macro-cache" (url->system new)) new)))))
   => ((quote doc-macro-cache) #:synopsis (quote ("Url of the cache with the collected macro documentation.")))
 => cons <> cur-props
   => cur-props => (((quote doc-macro-cache) #:synopsis (quote ("Url of the cache with the collected macro documentation."))))

(property-set! var prop what conds*)
  <= (doc-macro-cache #:synopsis ("Url of the cache with the collected macro documentation.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Parse @fname in @basedir and its sub-branches, collecting docs.") (tm-define-overloaded (doc-collect-explains basedir fname) (set! _scm_ (doc-scm-cache)) (set! _macro_ (doc-macro-cache)) (parse-branch (quasiquote (branch (dummy) (unquote fname))) basedir)))
   => ((quote doc-collect-explains) #:synopsis (quote ("Parse @fname in @basedir and its sub-branches, collecting docs.")))
 => cons <> cur-props
   => cur-props => (((quote doc-collect-explains) #:synopsis (quote ("Parse @fname in @basedir and its sub-branches, collecting docs."))))

(property-set! var prop what conds*)
  <= (doc-collect-explains #:synopsis ("Parse @fname in @basedir and its sub-branches, collecting docs.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Collect all explain tags available in the documentation.") (tm-define-overloaded (doc-collect-all lan) (with loc (string-take (language-to-locale lan) 2) (doc-collect-sub "devel/scheme" "scheme" loc) (doc-collect-sub "devel/plugin" "plugin" loc) (doc-collect-sub "devel/plugin" "plugins" loc) (doc-collect-sub "devel/source" "source" loc) (doc-collect-sub "devel/style" "style" loc) (doc-collect-sub "main" "man-reference" loc) (set-preference "doc:collect-timestamp" (current-time)) (append-preference "doc:collect-languages" lan) (set-message "Finished collecting symbols documentation." (string-append "(" lan ")")))))
   => ((quote doc-collect-all) #:synopsis (quote ("Collect all explain tags available in the documentation.")))
 => cons <> cur-props
   => cur-props => (((quote doc-collect-all) #:synopsis (quote ("Collect all explain tags available in the documentation."))))

(property-set! var prop what conds*)
  <= (doc-collect-all #:synopsis ("Collect all explain tags available in the documentation.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Ensure that the documentation cache is built.") (tm-define-overloaded (doc-check-cache) (let ((t (get-preference "doc:collect-timestamp")) (lan (get-output-language)) (langs (get-preference "doc:collect-languages"))) (if (not (and (!= t "default") (list? langs) (member lan langs))) (doc-collect-all lan)))))
   => ((quote doc-check-cache) #:synopsis (quote ("Ensure that the documentation cache is built.")))
 => cons <> cur-props
   => cur-props => (((quote doc-check-cache) #:synopsis (quote ("Ensure that the documentation cache is built."))))

(property-set! var prop what conds*)
  <= (doc-check-cache #:synopsis ("Ensure that the documentation cache is built.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("A list with all help items for @key in language @lan in @cache") (tm-define-overloaded (doc-retrieve cache key lan) (doc-check-cache) (doc-retrieve* cache key lan)))
   => ((quote doc-retrieve) #:synopsis (quote ("A list with all help items for @key in language @lan in @cache")))
 => cons <> cur-props
   => cur-props => (((quote doc-retrieve) #:synopsis (quote ("A list with all help items for @key in language @lan in @cache"))))

(property-set! var prop what conds*)
  <= (doc-retrieve #:synopsis ("A list with all help items for @key in language @lan in @cache") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Delete the documentation cache") (tm-define-overloaded (doc-delete-cache) (with run (lambda (go?) (if go? (doc-delete-cache*) (set-message "Cancelled" ""))) (user-confirm (quasiquote (replace "All the files at %1 and %2 will be deleted. Are you sure?" (verbatim (unquote (url->system (doc-scm-cache)))) (verbatim (unquote (url->system (doc-macro-cache)))))) #t run))))
   => ((quote doc-delete-cache) #:synopsis (quote ("Delete the documentation cache")))
 => cons <> cur-props
   => cur-props => (((quote doc-delete-cache) #:synopsis (quote ("Delete the documentation cache"))))

(property-set! var prop what conds*)
  <= (doc-delete-cache #:synopsis ("Delete the documentation cache") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Returns the list representation of a module given as a string") (tm-define-overloaded (string->module str) (if (or (not (string? str)) (== str "")) (quote ()) (map string->symbol (string-split str #\.)))))
   => ((quote string->module) #:synopsis (quote ("Returns the list representation of a module given as a string")))
 => cons <> cur-props
   => cur-props => (((quote string->module) #:synopsis (quote ("Returns the list representation of a module given as a string"))))

(property-set! var prop what conds*)
  <= (string->module #:synopsis ("Returns the list representation of a module given as a string") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Formats a module in list format (some module) as some.module") (tm-define-overloaded (module->string module) (cond ((list? module) (string-join (map symbol->string module) ".")) ((symbol? module) (symbol->string module)) (else ""))))
   => ((quote module->string) #:synopsis (quote ("Formats a module in list format (some module) as some.module")))
 => cons <> cur-props
   => cur-props => (((quote module->string) #:synopsis (quote ("Formats a module in list format (some module) as some.module"))))

(property-set! var prop what conds*)
  <= (module->string #:synopsis ("Formats a module in list format (some module) as some.module") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("List of exported symbols in @module") (tm-define-overloaded (module-exported module) (or (ahash-ref module-exported-cache module) (and (is-real-module? module) (let* ((fname (module-source-path module #t)) (p (open-input-string (string-load fname))) (defs (quote ())) (add (lambda (f) (with pf (parse-form f fname) (and (!= pf #f) (set! defs (rcons defs pf))))))) (letrec ((r (lambda () (with form (read p) (or (eof-object? form) (begin (add form) (r))))))) (r)) (ahash-set! module-exported-cache module defs))) (quote ()))))
   => ((quote module-exported) #:synopsis (quote ("List of exported symbols in @module")))
 => cons <> cur-props
   => cur-props => (((quote module-exported) #:synopsis (quote ("List of exported symbols in @module"))))

(property-set! var prop what conds*)
  <= (module-exported #:synopsis ("List of exported symbols in @module") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Return all submodules, recursively, for module list @ml") (tm-define-overloaded (list-submodules-recursive ml) (cond ((null? ml) (quote ())) ((npair? ml) (if (is-real-module? ml) (list ml) (list-submodules-recursive (list-submodules ml)))) ((null? (cdr ml)) (if (is-real-module? (car ml)) (list (car ml)) (list-submodules-recursive (list-submodules (car ml))))) (else (if (is-real-module? (car ml)) (cons (car ml) (list-submodules-recursive (cdr ml))) (append (list-submodules-recursive (list-submodules (car ml))) (list-submodules-recursive (cdr ml))))))))
   => ((quote list-submodules-recursive) #:synopsis (quote ("Return all submodules, recursively, for module list @ml")))
 => cons <> cur-props
   => cur-props => (((quote list-submodules-recursive) #:synopsis (quote ("Return all submodules, recursively, for module list @ml"))))

(property-set! var prop what conds*)
  <= (list-submodules-recursive #:synopsis ("Return all submodules, recursively, for module list @ml") ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (docgrep-in-doc-secure what) (docgrep-new-window what)))
    => ((quote docgrep-in-doc-secure) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote docgrep-in-doc-secure) #:secure (list #t)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Search in documentation. Secure routine to use in 'action tags.") (tm-define-overloaded (docgrep-in-doc-secure what) (docgrep-new-window what)))
   => ((quote docgrep-in-doc-secure) #:synopsis (quote ("Search in documentation. Secure routine to use in 'action tags.")))
 => cons <> cur-props
   => cur-props => (((quote docgrep-in-doc-secure) #:synopsis (quote ("Search in documentation. Secure routine to use in 'action tags."))) ((quote docgrep-in-doc-secure) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (docgrep-in-doc-secure #:synopsis ("Search in documentation. Secure routine to use in 'action tags.") ())

(property-set! var prop what conds*)
  <= (docgrep-in-doc-secure #:secure (#t) ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Return a document with the scheme documentation for @key") (tm-define-overloaded ($doc-explain-scm key) (quasiquote (document (unquote ($doc-explain-scm* key)) (freeze (concat (locus (id "__doc__popup__") "")))))))
   => ((quote $doc-explain-scm) #:synopsis (quote ("Return a document with the scheme documentation for @key")))
 => cons <> cur-props
   => cur-props => (((quote $doc-explain-scm) #:synopsis (quote ("Return a document with the scheme documentation for @key"))))

(property-set! var prop what conds*)
  <= ($doc-explain-scm #:synopsis ("Return a document with the scheme documentation for @key") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Return a document with the documentation for macro @key") (tm-define-overloaded ($doc-explain-macro key) (quasiquote (document (unquote ($doc-explain-macro* key)) (freeze (concat (locus (id "__doc__popup__") "")))))))
   => ((quote $doc-explain-macro) #:synopsis (quote ("Return a document with the documentation for macro @key")))
 => cons <> cur-props
   => cur-props => (((quote $doc-explain-macro) #:synopsis (quote ("Return a document with the documentation for macro @key"))))

(property-set! var prop what conds*)
  <= ($doc-explain-macro #:synopsis ("Return a document with the documentation for macro @key") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Display the help window for @key in the @where documentation") (tm-define-overloaded (help-window where key) (if (and (string? key) (!= key "")) (if (help-win-active?) (begin (help-win-display where key) (help-win-show)) (let* ((win (alt-window-handle)) (qui (object->command (lambda () (help-win-hide)))) (men (doc-widget where key)) (scm (list (quote vertical) men)) (wid (make-menu-widget scm 0)) (geo (get-preference "gui:help-window-geometry"))) (alt-window-create-quit win wid "Documentation" qui) (alt-window-show win) (if (list? geo) (window-set-geometry win geo)) (help-win-activate win))))))
   => ((quote help-window) #:synopsis (quote ("Display the help window for @key in the @where documentation")))
 => cons <> cur-props
   => cur-props => (((quote help-window) #:synopsis (quote ("Display the help window for @key in the @where documentation"))))

(property-set! var prop what conds*)
  <= (help-window #:synopsis ("Display the help window for @key in the @where documentation") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Return a list of lists splitting @lst by items equal? to @what") (tm-define-overloaded (list-split lst what) (letrec ((loop (lambda (lst what acc) (cond ((null? lst) (list acc)) ((equal? what (car lst)) (cons acc (loop (cdr lst) what (quote ())))) (else (loop (cdr lst) what (append acc (list (car lst))))))))) (loop lst what (quote ())))))
   => ((quote list-split) #:synopsis (quote ("Return a list of lists splitting @lst by items equal? to @what")))
 => cons <> cur-props
   => cur-props => (((quote list-split) #:synopsis (quote ("Return a list of lists splitting @lst by items equal? to @what"))))

(property-set! var prop what conds*)
  <= (list-split #:synopsis ("Return a list of lists splitting @lst by items equal? to @what") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Returns the word under the cursor, delimited by char-set:stopmark") (tm-define-overloaded (cursor-word) (with ct (cursor-tree) (word-at (tree->string ct) (car (tree-cursor-path ct))))))
   => ((quote cursor-word) #:synopsis (quote ("Returns the word under the cursor, delimited by char-set:stopmark")))
 => cons <> cur-props
   => cur-props => (((quote cursor-word) #:synopsis (quote ("Returns the word under the cursor, delimited by char-set:stopmark"))))

(property-set! var prop what conds*)
  <= (cursor-word #:synopsis ("Returns the word under the cursor, delimited by char-set:stopmark") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Pops up the help window for the scheme symbol @word") (tm-define-overloaded (scheme-popup-help word) (help-window "scheme" word)))
   => ((quote scheme-popup-help) #:synopsis (quote ("Pops up the help window for the scheme symbol @word")))
 => cons <> cur-props
   => cur-props => (((quote scheme-popup-help) #:synopsis (quote ("Pops up the help window for the scheme symbol @word"))))

(property-set! var prop what conds*)
  <= (scheme-popup-help #:synopsis ("Pops up the help window for the scheme symbol @word") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Opens a help buffer for the scheme symbol @word") (tm-define-overloaded (scheme-inbuffer-help word) (load-buffer (string-append "tmfs://apidoc/type=symbol&what=" (string-replace word ":" "%3A")))))
   => ((quote scheme-inbuffer-help) #:synopsis (quote ("Opens a help buffer for the scheme symbol @word")))
 => cons <> cur-props
   => cur-props => (((quote scheme-inbuffer-help) #:synopsis (quote ("Opens a help buffer for the scheme symbol @word"))))

(property-set! var prop what conds*)
  <= (scheme-inbuffer-help #:synopsis ("Opens a help buffer for the scheme symbol @word") ())

  (define-option-proposals opt decl)
    <= ((ssym (exp-modules)) (tm-define-overloaded (ask-insert-symbol-doc ssym) (insert ($doc-symbol-template (string->symbol ssym) #t ""))))
    => cons <> cur-props <= ((quote ask-insert-symbol-doc) (quote (#:proposals ssym)) (lambda () (exp-modules)))
    => cur-props => (((quote ask-insert-symbol-doc) (quote (#:proposals ssym)) (lambda () (exp-modules))))

  (define-option-argument opt decl)
    <= ((ssym "Symbol") (tm-define-overloaded (ask-insert-symbol-doc ssym) (insert ($doc-symbol-template (string->symbol ssym) #t ""))))
    => cons <> cur-props <= ((quote ask-insert-symbol-doc) #:arguments (quote (ssym)))
    => cons <> cur-props <= ((quote ask-insert-symbol-doc) (quote (#:argument ssym)) (quote ("Symbol")))
    => cur-props => (((quote ask-insert-symbol-doc) (quote (#:argument ssym)) (quote ("Symbol"))) ((quote ask-insert-symbol-doc) #:arguments (quote (ssym))) ((quote ask-insert-symbol-doc) (quote (#:proposals ssym)) (lambda () (exp-modules))))

(property-set! var prop what conds*)
  <= (ask-insert-symbol-doc (#:argument ssym) ("Symbol") ())

(property-set! var prop what conds*)
  <= (ask-insert-symbol-doc #:arguments (ssym) ())

(property-set! var prop what conds*)
  <= (ask-insert-symbol-doc (#:proposals ssym) #<procedure #f ()> ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Load the file @u into the scheme interpreter") (tm-define-overloaded (run-scheme-file u) (with s (url->string u) (with run (lambda (save?) (if save? (buffer-save u)) (load s) (set-message (quasiquote (replace "File %1 was executed" (verbatim (unquote s)))) "")) (if (and (buffer-exists? u) (buffer-modified? u)) (user-confirm (quasiquote (replace "File %1 is currently open and modified. Save before running?" (verbatim (unquote s)))) #t run) (run #f))))))
   => ((quote run-scheme-file) #:synopsis (quote ("Load the file @u into the scheme interpreter")))
 => cons <> cur-props
   => cur-props => (((quote run-scheme-file) #:synopsis (quote ("Load the file @u into the scheme interpreter"))))

(property-set! var prop what conds*)
  <= (run-scheme-file #:synopsis ("Load the file @u into the scheme interpreter") ())

  (define-option-require opt decl)
    <= (((and developer-mode? (opt-click? mods) (in-prog-scheme?))) (tm-define-overloaded (mouse-event key x y mods time) (with short (string-take key 4) (cond ((== short "pres") (mouse-any "release-left" x y 1 (+ time 0.0)) (set! cw (cursor-word)) (select-word cw (cursor-tree) (cAr (cursor-path)))) ((== short "rele") (with cw2 (cursor-word) (if (== cw cw2) (help-window "scheme" cw)))) (else (mouse-any key x y mods (+ time 0.0)))))))
    => (define-option-match opt decl) <= ((lambda (key x y mods time) (and developer-mode? (opt-click? mods) (in-prog-scheme?))) (tm-define-overloaded (mouse-event key x y mods time) (with short (string-take key 4) (cond ((== short "pres") (mouse-any "release-left" x y 1 (+ time 0.0)) (set! cw (cursor-word)) (select-word cw (cursor-tree) (cAr (cursor-path)))) ((== short "rele") (with cw2 (cursor-word) (if (== cw cw2) (help-window "scheme" cw)))) (else (mouse-any key x y mods (+ time 0.0)))))))

  (define-option-require opt decl)
    <= (((and developer-mode? (cmd-click? mods) (in-prog-scheme?))) (tm-define-overloaded (mouse-event key x y mods time) (with short (string-take key 4) (cond ((== short "pres") (mouse-any "release-left" x y 1 (+ time 0.0)) (set! cw (cursor-word)) (select-word cw (cursor-tree) (cAr (cursor-path)))) ((== short "rele") (with cw2 (cursor-word) (if (== cw cw2) (scheme-go-to-definition cw)))) (else (mouse-any key x y mods (+ time 0.0)))))))
    => (define-option-match opt decl) <= ((lambda (key x y mods time) (and developer-mode? (cmd-click? mods) (in-prog-scheme?))) (tm-define-overloaded (mouse-event key x y mods time) (with short (string-take key 4) (cond ((== short "pres") (mouse-any "release-left" x y 1 (+ time 0.0)) (set! cw (cursor-word)) (select-word cw (cursor-tree) (cAr (cursor-path)))) ((== short "rele") (with cw2 (cursor-word) (if (== cw cw2) (scheme-go-to-definition cw)))) (else (mouse-any key x y mods (+ time 0.0)))))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("are we inside the line of a textual document?") (tm-define-overloaded (inside-program?) (let* ((ct (cursor-tree)) (dt (tree-ref ct #:up))) (and (tree-atomic? ct) (tree-is? dt (quote document))))))
   => ((quote inside-program?) #:synopsis (quote ("are we inside the line of a textual document?")))
 => cons <> cur-props
   => cur-props => (((quote inside-program?) #:synopsis (quote ("are we inside the line of a textual document?"))))

(property-set! var prop what conds*)
  <= (inside-program? #:synopsis ("are we inside the line of a textual document?") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("get the entire program tree") (tm-define-overloaded (program-tree) (let* ((ct (cursor-tree)) (dt (tree-ref ct #:up))) (and (tree-atomic? ct) (tree-is? dt (quote document)) dt))))
   => ((quote program-tree) #:synopsis (quote ("get the entire program tree")))
 => cons <> cur-props
   => cur-props => (((quote program-tree) #:synopsis (quote ("get the entire program tree"))))

(property-set! var prop what conds*)
  <= (program-tree #:synopsis ("get the entire program tree") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("get the string at a given @row") (tm-define-overloaded (program-row row) (and-with doc (program-tree) (and-with par (tree-ref doc row) (and (tree-atomic? par) (tree->string par))))))
   => ((quote program-row) #:synopsis (quote ("get the string at a given @row")))
 => cons <> cur-props
   => cur-props => (((quote program-row) #:synopsis (quote ("get the string at a given @row"))))

(property-set! var prop what conds*)
  <= (program-row #:synopsis ("get the string at a given @row") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("get the vertical position on the current line") (tm-define-overloaded (program-row-number) (and (inside-program?) (cADr (cursor-path)))))
   => ((quote program-row-number) #:synopsis (quote ("get the vertical position on the current line")))
 => cons <> cur-props
   => cur-props => (((quote program-row-number) #:synopsis (quote ("get the vertical position on the current line"))))

(property-set! var prop what conds*)
  <= (program-row-number #:synopsis ("get the vertical position on the current line") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("get the horizontal position on the current line") (tm-define-overloaded (program-column-number) (and (inside-program?) (cAr (cursor-path)))))
   => ((quote program-column-number) #:synopsis (quote ("get the horizontal position on the current line")))
 => cons <> cur-props
   => cur-props => (((quote program-column-number) #:synopsis (quote ("get the horizontal position on the current line"))))

(property-set! var prop what conds*)
  <= (program-column-number #:synopsis ("get the horizontal position on the current line") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("go to the character at a given @row and @col") (tm-define-overloaded (program-go-to row col) (and-with doc (program-tree) (tree-go-to doc row col))))
   => ((quote program-go-to) #:synopsis (quote ("go to the character at a given @row and @col")))
 => cons <> cur-props
   => cur-props => (((quote program-go-to) #:synopsis (quote ("go to the character at a given @row and @col"))))

(property-set! var prop what conds*)
  <= (program-go-to #:synopsis ("go to the character at a given @row and @col") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("find previous bracket @br with inverse @ibr in @s at @pos") (tm-define-overloaded (string-bracket-forward s pos br ibr) (string-bracket-find s pos 1 br ibr 0)))
   => ((quote string-bracket-forward) #:synopsis (quote ("find previous bracket @br with inverse @ibr in @s at @pos")))
 => cons <> cur-props
   => cur-props => (((quote string-bracket-forward) #:synopsis (quote ("find previous bracket @br with inverse @ibr in @s at @pos"))))

(property-set! var prop what conds*)
  <= (string-bracket-forward #:synopsis ("find previous bracket @br with inverse @ibr in @s at @pos") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("find next bracket @br with inverse @ibr in @s at @pos") (tm-define-overloaded (string-bracket-backward s pos br ibr) (string-bracket-find s pos -1 br ibr 0)))
   => ((quote string-bracket-backward) #:synopsis (quote ("find next bracket @br with inverse @ibr in @s at @pos")))
 => cons <> cur-props
   => cur-props => (((quote string-bracket-backward) #:synopsis (quote ("find next bracket @br with inverse @ibr in @s at @pos"))))

(property-set! var prop what conds*)
  <= (string-bracket-backward #:synopsis ("find next bracket @br with inverse @ibr in @s at @pos") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("find matching opening row for @row and bracket @br") (tm-define-overloaded (program-previous-match row br ibr) (let* ((s (program-row row)) (last (- (string-length s) 1))) (if (not s) row (with ret (string-bracket-level s last -1 br ibr) (if (== ret 0) row (with pos (program-bracket-find row last -1 br ibr -1) (if (not pos) row (car pos)))))))))
   => ((quote program-previous-match) #:synopsis (quote ("find matching opening row for @row and bracket @br")))
 => cons <> cur-props
   => cur-props => (((quote program-previous-match) #:synopsis (quote ("find matching opening row for @row and bracket @br"))))

(property-set! var prop what conds*)
  <= (program-previous-match #:synopsis ("find matching opening row for @row and bracket @br") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Highlights innermost matching brackets around given @path") (tm-define-overloaded (select-brackets path lb rb) (let ((prev (find-left-bracket path lb rb)) (next (find-right-bracket path lb rb))) (if (or (null? prev) (null? next)) (if (nnull? (get-alt-selection "brackets")) (cancel-alt-selection "brackets")) (set-alt-selection "brackets" (list prev (path++ prev) next (path++ next)))))))
   => ((quote select-brackets) #:synopsis (quote ("Highlights innermost matching brackets around given @path")))
 => cons <> cur-props
   => cur-props => (((quote select-brackets) #:synopsis (quote ("Highlights innermost matching brackets around given @path"))))

(property-set! var prop what conds*)
  <= (select-brackets #:synopsis ("Highlights innermost matching brackets around given @path") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Highlight any of @lbs (matching @rbs) after a cursor movement") (tm-define-overloaded (select-brackets-after-movement lbs rbs esc) (let* ((p (cursor-path)) (p* (path-- p)) (ch (program-character p)) (lch (program-character p*)) (i1 (string-index lbs ch)) (i2 (string-index rbs ch)) (i3 (string-index rbs lch))) (cond (i1 (select-brackets p (string-ref* lbs i1) (string-ref* rbs i1))) (i2 (select-brackets p* (string-ref* lbs i2) (string-ref* rbs i2))) (i3 (select-brackets p* (string-ref* lbs i3) (string-ref* rbs i3))) ((nnull? (get-alt-selection "brackets")) (cancel-alt-selection "brackets"))))))
   => ((quote select-brackets-after-movement) #:synopsis (quote ("Highlight any of @lbs (matching @rbs) after a cursor movement")))
 => cons <> cur-props
   => cur-props => (((quote select-brackets-after-movement) #:synopsis (quote ("Highlight any of @lbs (matching @rbs) after a cursor movement"))))

(property-set! var prop what conds*)
  <= (select-brackets-after-movement #:synopsis ("Highlight any of @lbs (matching @rbs) after a cursor movement") ())

  (define-option-require opt decl)
    <= (((not (in-prog?))) (tm-define-overloaded (notify-cursor-moved status) (if (nnull? (get-alt-selection "brackets")) (cancel-alt-selection "brackets"))))
    => (define-option-match opt decl) <= ((lambda (status) (not (in-prog?))) (tm-define-overloaded (notify-cursor-moved status) (if (nnull? (get-alt-selection "brackets")) (cancel-alt-selection "brackets"))))

  (define-option-require opt decl)
    <= ((prog-highlight-brackets?) (tm-define-overloaded (notify-cursor-moved status) (if (nnull? (get-alt-selection "brackets")) (cancel-alt-selection "brackets"))))
    => (define-option-match opt decl) <= ((lambda (status) prog-highlight-brackets?) (tm-define-overloaded (notify-cursor-moved status) (if (nnull? (get-alt-selection "brackets")) (cancel-alt-selection "brackets"))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("does @s only contain whitespace?") (tm-define-overloaded (string-whitespace? s) (list-and (map char-whitespace? (string->list s)))))
   => ((quote string-whitespace?) #:synopsis (quote ("does @s only contain whitespace?")))
 => cons <> cur-props
   => cur-props => (((quote string-whitespace?) #:synopsis (quote ("does @s only contain whitespace?"))))

(property-set! var prop what conds*)
  <= (string-whitespace? #:synopsis ("does @s only contain whitespace?") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("get the indentation of @s") (tm-define-overloaded (string-get-indent s) (with pos (list-find-index (string->list s) char-non-whitespace?) (or pos (string-length s)))))
   => ((quote string-get-indent) #:synopsis (quote ("get the indentation of @s")))
 => cons <> cur-props
   => cur-props => (((quote string-get-indent) #:synopsis (quote ("get the indentation of @s"))))

(property-set! var prop what conds*)
  <= (string-get-indent #:synopsis ("get the indentation of @s") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("set the indentation of @s to @i spaces") (tm-define-overloaded (string-set-indent s i) (let* ((l (make-string i #\space)) (r (substring s (string-get-indent s) (string-length s)))) (string-append l r))))
   => ((quote string-set-indent) #:synopsis (quote ("set the indentation of @s to @i spaces")))
 => cons <> cur-props
   => cur-props => (((quote string-set-indent) #:synopsis (quote ("set the indentation of @s to @i spaces"))))

(property-set! var prop what conds*)
  <= (string-set-indent #:synopsis ("set the indentation of @s to @i spaces") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("get the indentation of the current line") (tm-define-overloaded (program-get-indent) (and (inside-program?) (string-get-indent (program-row (program-row-number))))))
   => ((quote program-get-indent) #:synopsis (quote ("get the indentation of the current line")))
 => cons <> cur-props
   => cur-props => (((quote program-get-indent) #:synopsis (quote ("get the indentation of the current line"))))

(property-set! var prop what conds*)
  <= (program-get-indent #:synopsis ("get the indentation of the current line") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("set the indentation of the current line to @i spaces") (tm-define-overloaded (program-set-indent i) (when (inside-program?) (with t (cursor-tree) (tree-set t (string-set-indent (tree->string t) i))))))
   => ((quote program-set-indent) #:synopsis (quote ("set the indentation of the current line to @i spaces")))
 => cons <> cur-props
   => cur-props => (((quote program-set-indent) #:synopsis (quote ("set the indentation of the current line to @i spaces"))))

(property-set! var prop what conds*)
  <= (program-set-indent #:synopsis ("set the indentation of the current line to @i spaces") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("indent a whole program") (tm-define-overloaded (program-indent-all unindent?) (and-with doc (program-tree) (for-each (lambda (r) (program-indent-line doc r unindent?)) (iota (tree-arity doc))))))
   => ((quote program-indent-all) #:synopsis (quote ("indent a whole program")))
 => cons <> cur-props
   => cur-props => (((quote program-indent-all) #:synopsis (quote ("indent a whole program"))))

(property-set! var prop what conds*)
  <= (program-indent-all #:synopsis ("indent a whole program") ())

  (define-option-mode opt decl)
    <= ((in-prog?) (tm-define-overloaded (insert-return) (insert-raw-return) (program-indent #f)))
    (ctx-add-condition! 0 (car opt)) => cur-conds => (in-prog?)

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Provide the completions for @root as needed by custom-complete") (tm-define-overloaded (scheme-completions root) (quasiquote (tuple (unquote root) (unquote-splicing (map string->tmstring (pt-words-below (pt-find completions (tmstring->string root)))))))))
   => ((quote scheme-completions) #:synopsis (quote ("Provide the completions for @root as needed by custom-complete")))
 => cons <> cur-props
   => cur-props => (((quote scheme-completions) #:synopsis (quote ("Provide the completions for @root as needed by custom-complete"))))

(property-set! var prop what conds*)
  <= (scheme-completions #:synopsis ("Provide the completions for @root as needed by custom-complete") ())

  (define-option-mode opt decl)
    <= ((in-prog-cpp?) (tm-define-overloaded (kbd-select-enlarge) (program-select-enlarge "{" "}")))
    (ctx-add-condition! 0 (car opt)) => cur-conds => (in-prog-cpp?)

  (define-option-require opt decl)
    <= ((prog-select-brackets?) (tm-define-overloaded (kbd-select-enlarge) (program-select-enlarge "{" "}")))
    => (define-option-match opt decl) <= ((lambda () prog-select-brackets?) (tm-define-overloaded (kbd-select-enlarge) (program-select-enlarge "{" "}")))

  (define-option-mode opt decl)
    <= ((in-prog-cpp?) (tm-define-overloaded (notify-cursor-moved status) (select-brackets-after-movement "([{" ")]}" "\\")))
    (ctx-add-condition! 0 (car opt)) => cur-conds => (in-prog-cpp?)

  (define-option-require opt decl)
    <= ((prog-highlight-brackets?) (tm-define-overloaded (notify-cursor-moved status) (select-brackets-after-movement "([{" ")]}" "\\")))
    => (define-option-match opt decl) <= ((lambda (status) prog-highlight-brackets?) (tm-define-overloaded (notify-cursor-moved status) (select-brackets-after-movement "([{" ")]}" "\\")))

  (define-option-mode opt decl)
    <= ((in-prog-python?) (tm-define-overloaded (program-compute-indentation doc row col) (if (<= row 0) 0 (let* ((r (program-row (- row 1))) (s (string-strip-right (strip-comment-buggy (if r r "")))) (i (string-get-indent s)) (c (if (== s "") "" (string-take-right s 1)))) (if (== c ":") (+ i (get-tabstop)) i)))))
    (ctx-add-condition! 0 (car opt)) => cur-conds => (in-prog-python?)

  (define-option-mode opt decl)
    <= ((in-prog-python?) (tm-define-overloaded (notify-cursor-moved status) (select-brackets-after-movement "([{" ")]}" "\\")))
    (ctx-add-condition! 0 (car opt)) => cur-conds => (in-prog-python?)

  (define-option-require opt decl)
    <= ((prog-highlight-brackets?) (tm-define-overloaded (notify-cursor-moved status) (select-brackets-after-movement "([{" ")]}" "\\")))
    => (define-option-match opt decl) <= ((lambda (status) prog-highlight-brackets?) (tm-define-overloaded (notify-cursor-moved status) (select-brackets-after-movement "([{" ")]}" "\\")))

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" buffer-master?) (tm-define-overloaded (buffer-toggle-master) (init-env "project-flag" (if (== (get-init "project-flag") "true") "false" "true"))))
    => ((quote buffer-toggle-master) #:check-mark (list "v" buffer-master?))
 => cons <> cur-props
    => cur-props => (((quote buffer-toggle-master) #:check-mark (list "v" buffer-master?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle using current buffer as master file of project.") (tm-define-overloaded (buffer-toggle-master) (init-env "project-flag" (if (== (get-init "project-flag") "true") "false" "true"))))
   => ((quote buffer-toggle-master) #:synopsis (quote ("Toggle using current buffer as master file of project.")))
 => cons <> cur-props
   => cur-props => (((quote buffer-toggle-master) #:synopsis (quote ("Toggle using current buffer as master file of project."))) ((quote buffer-toggle-master) #:check-mark (list "v" buffer-master?)))

(property-set! var prop what conds*)
  <= (buffer-toggle-master #:synopsis ("Toggle using current buffer as master file of project.") ())

(property-set! var prop what conds*)
  <= (buffer-toggle-master #:check-mark ("v" #<procedure buffer-master? ()>) ())

  (define-option-require opt decl)
    <= (((and (tree-is? t (quote show-preamble)) (tree-empty? (tree-ref t 0)))) (tm-define-overloaded (kbd-remove t forwards?) (buffer-set-part-mode #:all) (when (buffer-has-preamble?) (tree-remove (buffer-tree) 0 1))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (and (tree-is? t (quote show-preamble)) (tree-empty? (tree-ref t 0)))) (tm-define-overloaded (kbd-remove t forwards?) (buffer-set-part-mode #:all) (when (buffer-has-preamble?) (tree-remove (buffer-tree) 0 1))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Get the mode for document part selections") (tm-define-overloaded (buffer-get-part-mode) (cond ((tree-is? (tree-ref (buffer-tree) 0) (quote show-preamble)) #:preamble) ((tree-in? (car (buffer-body-paragraphs)) (quote (show-part hide-part))) part-mode) (else #:all))))
   => ((quote buffer-get-part-mode) #:synopsis (quote ("Get the mode for document part selections")))
 => cons <> cur-props
   => cur-props => (((quote buffer-get-part-mode) #:synopsis (quote ("Get the mode for document part selections"))))

(property-set! var prop what conds*)
  <= (buffer-get-part-mode #:synopsis ("Get the mode for document part selections") ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" buffer-test-part-mode?) (tm-define-overloaded (buffer-set-part-mode mode) (with old-mode (buffer-get-part-mode) (cond ((== mode old-mode) (noop)) ((== mode #:preamble) (when (tree-is? (tree-ref (buffer-tree) 0) (quote hide-preamble)) (buffer-show-preamble) (tree-go-to (buffer-tree) 0 0 #:start))) ((== mode #:all) (buffer-hide-preamble) (buffer-flatten-parts) (tree-go-to (car (buffer-body-paragraphs)) #:start) (update-current-buffer)) (else (buffer-hide-preamble) (buffer-make-parts) (set! part-mode mode) (with first (car (buffer-parts-list #f)) (if (== mode #:one) (buffer-show-part first) (buffer-go-to-part first))) (update-current-buffer))))))
    => ((quote buffer-set-part-mode) #:check-mark (list "v" buffer-test-part-mode?))
 => cons <> cur-props
    => cur-props => (((quote buffer-set-part-mode) #:check-mark (list "v" buffer-test-part-mode?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set the mode for document part selections") (tm-define-overloaded (buffer-set-part-mode mode) (with old-mode (buffer-get-part-mode) (cond ((== mode old-mode) (noop)) ((== mode #:preamble) (when (tree-is? (tree-ref (buffer-tree) 0) (quote hide-preamble)) (buffer-show-preamble) (tree-go-to (buffer-tree) 0 0 #:start))) ((== mode #:all) (buffer-hide-preamble) (buffer-flatten-parts) (tree-go-to (car (buffer-body-paragraphs)) #:start) (update-current-buffer)) (else (buffer-hide-preamble) (buffer-make-parts) (set! part-mode mode) (with first (car (buffer-parts-list #f)) (if (== mode #:one) (buffer-show-part first) (buffer-go-to-part first))) (update-current-buffer))))))
   => ((quote buffer-set-part-mode) #:synopsis (quote ("Set the mode for document part selections")))
 => cons <> cur-props
   => cur-props => (((quote buffer-set-part-mode) #:synopsis (quote ("Set the mode for document part selections"))) ((quote buffer-set-part-mode) #:check-mark (list "v" buffer-test-part-mode?)))

(property-set! var prop what conds*)
  <= (buffer-set-part-mode #:synopsis ("Set the mode for document part selections") ())

(property-set! var prop what conds*)
  <= (buffer-set-part-mode #:check-mark ("v" #<procedure buffer-test-part-mode? (mode)>) ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Does the current buffer contain a preamble?") (tm-define-overloaded (buffer-has-preamble?) (with t (buffer-tree) (tree-in? (tree-ref t 0) (quote (show-preamble hide-preamble))))))
   => ((quote buffer-has-preamble?) #:synopsis (quote ("Does the current buffer contain a preamble?")))
 => cons <> cur-props
   => cur-props => (((quote buffer-has-preamble?) #:synopsis (quote ("Does the current buffer contain a preamble?"))))

(property-set! var prop what conds*)
  <= (buffer-has-preamble? #:synopsis ("Does the current buffer contain a preamble?") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Get the list of all document parts of the current buffer") (tm-define-overloaded (buffer-parts-list all?) (with l (buffer-body-paragraphs) (if (match? l (quote ((ignore (document #:*))))) (set! l (tree-children (tree-ref (car l) 0)))) (with parts (document-get-parts (tm->tree (quasiquote (document (unquote-splicing l)))) all?) (if (and (not (tree-in? (car l) (quote (show-part hide-part)))) (not (principal-section? (car l))) (or all? (== (buffer-get-part-mode) #:all))) (cons "front matter" parts) parts)))))
   => ((quote buffer-parts-list) #:synopsis (quote ("Get the list of all document parts of the current buffer")))
 => cons <> cur-props
   => cur-props => (((quote buffer-parts-list) #:synopsis (quote ("Get the list of all document parts of the current buffer"))))

(property-set! var prop what conds*)
  <= (buffer-parts-list #:synopsis ("Get the list of all document parts of the current buffer") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Go to the part with name @id") (tm-define-overloaded (buffer-go-to-part id) (with t (document-find-part (buffer-tree) id) (and t (tree-go-to t 1 #:start)))))
   => ((quote buffer-go-to-part) #:synopsis (quote ("Go to the part with name @id")))
 => cons <> cur-props
   => cur-props => (((quote buffer-go-to-part) #:synopsis (quote ("Go to the part with name @id"))))

(property-set! var prop what conds*)
  <= (buffer-go-to-part #:synopsis ("Go to the part with name @id") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Show the document part with name @id") (tm-define-overloaded (buffer-show-part id) (when (== (buffer-get-part-mode) #:one) (document-select-part (buffer-tree) id) (buffer-go-to-part id))))
   => ((quote buffer-show-part) #:synopsis (quote ("Show the document part with name @id")))
 => cons <> cur-props
   => cur-props => (((quote buffer-show-part) #:synopsis (quote ("Show the document part with name @id"))))

(property-set! var prop what conds*)
  <= (buffer-show-part #:synopsis ("Show the document part with name @id") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle the visibility of the document part with name @id") (tm-define-overloaded (buffer-toggle-part id) (when (and (== (buffer-get-part-mode) #:several) (list-find (buffer-parts-list #f) (lambda (x) (!= x id)))) (with t (document-find-part (buffer-tree) id) (cond ((not t) (noop)) ((tree-is? t (quote show-part)) (tree-assign-node! t (quote hide-part)) (buffer-go-to-part (car (buffer-parts-list #f)))) ((tree-is? t (quote hide-part)) (tree-assign-node! t (quote show-part)) (buffer-go-to-part id)))))))
   => ((quote buffer-toggle-part) #:synopsis (quote ("Toggle the visibility of the document part with name @id")))
 => cons <> cur-props
   => cur-props => (((quote buffer-toggle-part) #:synopsis (quote ("Toggle the visibility of the document part with name @id"))))

(property-set! var prop what conds*)
  <= (buffer-toggle-part #:synopsis ("Toggle the visibility of the document part with name @id") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Create a preamble for the current document") (tm-define-overloaded (buffer-make-preamble) (when (not (buffer-has-preamble?)) (with t (buffer-tree) (tree-insert! t 0 (quote ((hide-preamble (document ""))))) (buffer-set-part-mode #:preamble)))))
   => ((quote buffer-make-preamble) #:synopsis (quote ("Create a preamble for the current document")))
 => cons <> cur-props
   => cur-props => (((quote buffer-make-preamble) #:synopsis (quote ("Create a preamble for the current document"))))

(property-set! var prop what conds*)
  <= (buffer-make-preamble #:synopsis ("Create a preamble for the current document") ())

  (define-option-require opt decl)
    <= (((and (tree-is? t (quote hide-part)) (== (tree-up t) (buffer-tree)))) (tm-define-overloaded (tree-show-hidden t) (if (== (buffer-get-part-mode) #:one) (with id (document-part-name t) (document-select-part (tree-up t) id)) (tree-assign-node! t (quote show-part)))))
    => (define-option-match opt decl) <= ((lambda (t) (and (tree-is? t (quote hide-part)) (== (tree-up t) (buffer-tree)))) (tm-define-overloaded (tree-show-hidden t) (if (== (buffer-get-part-mode) #:one) (with id (document-part-name t) (document-select-part (tree-up t) id)) (tree-assign-node! t (quote show-part)))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Make hidden part with identifier @id visible") (tm-define-overloaded (show-hidden-part id) (with search? (lambda (t) (match? t (quasiquote (hide-part (unquote id) #:%2)))) (and-with t (list-find (tree-children (buffer-tree)) search?) (tree-show-hidden t) #t))))
   => ((quote show-hidden-part) #:synopsis (quote ("Make hidden part with identifier @id visible")))
 => cons <> cur-props
   => cur-props => (((quote show-hidden-part) #:synopsis (quote ("Make hidden part with identifier @id visible"))))

(property-set! var prop what conds*)
  <= (show-hidden-part #:synopsis ("Make hidden part with identifier @id visible") ())

  (define-option-require opt decl)
    <= (((buffer-contains-includes?)) (tm-define-overloaded (document-part-menu) (menu-dynamic (link document-master-menu))))
    => (define-option-match opt decl) <= ((lambda () (buffer-contains-includes?)) (tm-define-overloaded (document-part-menu) (menu-dynamic (link document-master-menu))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (ext-edit-macro a) (let* ((c (tree-children a)) (name (car c)) (name* (if (not (tm-equal? name "")) name (quasiquote (concat (with "color" "red" "font-shape" "italic" "enter-name") (unquote name))))) (args (cDr (cdr c))) (args* (map (lambda (x) (quasiquote (src-arg (unquote x)))) args)) (body (cAr c)) (body* (if (not (and (tm-equal? name "") (tm-equal? body ""))) body (quasiquote (concat (with "color" "red" "font-shape" "italic" "enter-body") (unquote body)))))) (quasiquote (with "par-first" "0em" "par-par-sep" "0.5em" (document (concat (inline-tag (unquote name*) (unquote-splicing args*)) " " (math "<assign>")) (unquote body*)))))))
    => ((quote ext-edit-macro) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote ext-edit-macro) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (ext-edit-macro #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (open-macro-editor l) (if (symbol? l) (set! l (symbol->string l))) (let* ((b (current-buffer-url)) (u (string->url (string-append "tmfs://aux/edit-" l))) (packs (get-style-list)) (styps (list-remove-duplicates (append packs (list "macro-editor"))))) (and-with doc (build-macro-document l) (dialogue-window (macro-editor u styps doc "Text") (lambda x (noop)) "Macro editor" u) (buffer-set-master u b)))))
    => ((quote open-macro-editor) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-macro-editor) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-macro-editor #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (create-table-macro l) (when (can-create-table-macro?) (position-inside-table) (if (symbol? l) (set! l (symbol->string l))) (let* ((b (current-buffer-url)) (u (string-append "tmfs://aux/edit-" l)) (packs (get-style-list)) (styps (list-remove-duplicates (append packs (list "macro-editor")))) (fm (table-get-format-all)) (tf (quasiquote (tformat (unquote-splicing (tree-children fm)) (arg "body")))) (body (if (selection-active-any?) (with sel (tm->stree (selection-tree)) (tformat-subst-selection sel tf)) tf)) (def (quasiquote (assign (unquote l) (inactive* (macro "body" (unquote body))))))) (and-with doc (build-macro-document* l def) (dialogue-window (macro-editor u styps doc "Source") (lambda x (noop)) "Macro editor") (buffer-set-master u b))))))
    => ((quote create-table-macro) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote create-table-macro) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (create-table-macro #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (open-macros-editor) (let* ((b (current-buffer-url)) (u (string->url "tmfs://aux/macro-editor")) (names (all-defined-macros)) (packs (get-style-list)) (styps (list-remove-duplicates (append packs (list "macro-editor"))))) (dialogue-window (macros-editor u styps names) (lambda x (noop)) "Macros editor" u) (buffer-set-master u b))))
    => ((quote open-macros-editor) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-macros-editor) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-macros-editor #:interactive (#t) ())

  (define-option-require opt decl)
    <= (((table-markup-context? t)) (tm-define-overloaded (standard-focus-menu t) (menu-dynamic (dynamic (focus-tag-menu t)) (-> "Move" (dynamic (focus-move-menu t))) (-> "Resize" (dynamic (focus-insert-menu t))) --- (group "Table") (link table-menu) --- (if (== (get-cell-mode) "cell") (group "Cell")) (if (== (get-cell-mode) "row") (group "Row")) (if (== (get-cell-mode) "column") (group "Column")) (if (== (get-cell-mode) "table") (group "Cells")) (link cell-menu) (dynamic (focus-extra-menu t)) (dynamic (focus-hidden-menu t)))))
    => (define-option-match opt decl) <= ((lambda (t) (table-markup-context? t)) (tm-define-overloaded (standard-focus-menu t) (menu-dynamic (dynamic (focus-tag-menu t)) (-> "Move" (dynamic (focus-move-menu t))) (-> "Resize" (dynamic (focus-insert-menu t))) --- (group "Table") (link table-menu) --- (if (== (get-cell-mode) "cell") (group "Cell")) (if (== (get-cell-mode) "row") (group "Row")) (if (== (get-cell-mode) "column") (group "Column")) (if (== (get-cell-mode) "table") (group "Cells")) (link cell-menu) (dynamic (focus-extra-menu t)) (dynamic (focus-hidden-menu t)))))

  (define-option-require opt decl)
    <= (((table-markup-context? t)) (tm-define-overloaded (focus-tag-extra-icons t) (menu-dynamic (if (document-like? (tree-up t)) ((check (balloon (icon "tm_table_parwidth.xpm") "Extend table to full paragraph width") "v" (table-test-parwidth?)) (table-toggle-parwidth))) (=> (balloon (icon "tm_set_properties.xpm") "Table properties") (mini #f (link table-menu) --- ("Table properties" (open-table-properties)))))))
    => (define-option-match opt decl) <= ((lambda (t) (table-markup-context? t)) (tm-define-overloaded (focus-tag-extra-icons t) (menu-dynamic (if (document-like? (tree-up t)) ((check (balloon (icon "tm_table_parwidth.xpm") "Extend table to full paragraph width") "v" (table-test-parwidth?)) (table-toggle-parwidth))) (=> (balloon (icon "tm_set_properties.xpm") "Table properties") (mini #f (link table-menu) --- ("Table properties" (open-table-properties)))))))

  (define-option-require opt decl)
    <= (((table-markup-context? t)) (tm-define-overloaded (focus-extra-icons t) (menu-dynamic (glue #f #f 10 0) (minibar (if (== (get-cell-mode) "cell") (=> (balloon "Cell" "Change cell operation mode") (mini #f (link cell-mode-icons) --- ("Cell properties" (open-cell-properties))))) (if (== (get-cell-mode) "row") (=> (balloon "Row" "Change cell operation mode") (mini #f (link cell-mode-icons) --- ("Cell properties" (open-cell-properties))))) (if (== (get-cell-mode) "column") (=> (balloon "Column" "Change cell operation mode") (mini #f (link cell-mode-icons) --- ("Cell properties" (open-cell-properties))))) (if (== (get-cell-mode) "table") (=> (balloon "All cells" "Change cell operation mode") (mini #f (link cell-mode-icons) --- ("Cell properties" (open-cell-properties))))) (=> (balloon (icon "tm_cell_size_var.xpm") "Modify cell size") (mini #f (group "Width") (link cell-width-menu) --- (group "Height") (link cell-height-menu) (when (and (== (get-cell-mode) "cell") (not (selection-active-any?))) --- (group "Span") (link cell-span-menu)))) (=> (balloon (icon "tm_cell_border.xpm") "Change border of cell") (mini #f (group "Border") (link cell-alt-border-menu) --- (group "Padding") (link cell-padding-menu))) (=> (balloon (icon (eval (cell-halign-icon))) "Modify cell alignment") (mini #f (group "Horizontal alignment") (link cell-halign-menu) --- (group "Vertical alignment") (link cell-valign-menu))) (=> (balloon (icon "tm_cell_background.xpm") "Set background color of cell") (mini #f (link cell-color-menu))) ((check (balloon (icon "tm_cell_wrap.xpm") "Line wrapping inside cell") "v" (cell-test-wrap?)) (cell-toggle-wrap)) (if (and (not (cell-spans-more?)) (not (selection-active-table?)) (> (* (table-nr-rows) (table-nr-columns)) 1)) ((balloon (icon "tm_cell_subtable.xpm") "Transform cell into subtable") (make-subtable))) (if (and (cell-spans-more?) (not (selection-active-table?))) ((balloon (icon "tm_cell_var_subtable.xpm") "Transform cell into subtable") (make-subtable)) ((balloon (icon "tm_cell_split.xpm") "Dissociate joined cells") (cell-reset-span))) (if (selection-active-table?) ((balloon (icon "tm_cell_join.xpm") "Join selected cells") (cell-set-span-selection)))))))
    => (define-option-match opt decl) <= ((lambda (t) (table-markup-context? t)) (tm-define-overloaded (focus-extra-icons t) (menu-dynamic (glue #f #f 10 0) (minibar (if (== (get-cell-mode) "cell") (=> (balloon "Cell" "Change cell operation mode") (mini #f (link cell-mode-icons) --- ("Cell properties" (open-cell-properties))))) (if (== (get-cell-mode) "row") (=> (balloon "Row" "Change cell operation mode") (mini #f (link cell-mode-icons) --- ("Cell properties" (open-cell-properties))))) (if (== (get-cell-mode) "column") (=> (balloon "Column" "Change cell operation mode") (mini #f (link cell-mode-icons) --- ("Cell properties" (open-cell-properties))))) (if (== (get-cell-mode) "table") (=> (balloon "All cells" "Change cell operation mode") (mini #f (link cell-mode-icons) --- ("Cell properties" (open-cell-properties))))) (=> (balloon (icon "tm_cell_size_var.xpm") "Modify cell size") (mini #f (group "Width") (link cell-width-menu) --- (group "Height") (link cell-height-menu) (when (and (== (get-cell-mode) "cell") (not (selection-active-any?))) --- (group "Span") (link cell-span-menu)))) (=> (balloon (icon "tm_cell_border.xpm") "Change border of cell") (mini #f (group "Border") (link cell-alt-border-menu) --- (group "Padding") (link cell-padding-menu))) (=> (balloon (icon (eval (cell-halign-icon))) "Modify cell alignment") (mini #f (group "Horizontal alignment") (link cell-halign-menu) --- (group "Vertical alignment") (link cell-valign-menu))) (=> (balloon (icon "tm_cell_background.xpm") "Set background color of cell") (mini #f (link cell-color-menu))) ((check (balloon (icon "tm_cell_wrap.xpm") "Line wrapping inside cell") "v" (cell-test-wrap?)) (cell-toggle-wrap)) (if (and (not (cell-spans-more?)) (not (selection-active-table?)) (> (* (table-nr-rows) (table-nr-columns)) 1)) ((balloon (icon "tm_cell_subtable.xpm") "Transform cell into subtable") (make-subtable))) (if (and (cell-spans-more?) (not (selection-active-table?))) ((balloon (icon "tm_cell_var_subtable.xpm") "Transform cell into subtable") (make-subtable)) ((balloon (icon "tm_cell_split.xpm") "Dissociate joined cells") (cell-reset-span))) (if (selection-active-table?) ((balloon (icon "tm_cell_join.xpm") "Join selected cells") (cell-set-span-selection)))))))

  (define-option-require opt decl)
    <= (((inside-graphics-context? t)) (tm-define-overloaded (generic-context? t) #f))
    => (define-option-match opt decl) <= ((lambda (t) (inside-graphics-context? t)) (tm-define-overloaded (generic-context? t) #f))

  (define-option-mode opt decl)
    <= ((in-active-graphics?) (tm-define-overloaded (keyboard-press key time) (cond ((string-occurs? "-" key) (key-press key)) ((in? key graphics-keys) (key-press key)))))
    (ctx-add-condition! 0 (car opt)) => cur-conds => (in-active-graphics?)

  (define-option-require opt decl)
    <= (((in-active-graphics?)) (tm-define-overloaded (kbd-variant t forwards?) (graphics-choose-point (if forwards? 1 -1))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (in-active-graphics?)) (tm-define-overloaded (kbd-variant t forwards?) (graphics-choose-point (if forwards? 1 -1))))

  (define-option-require opt decl)
    <= (((in-active-graphics?)) (tm-define-overloaded (geometry-vertical t down?) (graphics-change-geo-valign down?)))
    => (define-option-match opt decl) <= ((lambda (t down?) (in-active-graphics?)) (tm-define-overloaded (geometry-vertical t down?) (graphics-change-geo-valign down?)))

  (define-option-require opt decl)
    <= (((graphical-text-context? t)) (tm-define-overloaded (kbd-horizontal t forwards?) (with-define (move) ((if forwards? go-right go-left)) (with-define (next) (go-to-next-inside move inside-graphics-context?) (go-to-next-such-that next inside-graphical-text-context?)))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (graphical-text-context? t)) (tm-define-overloaded (kbd-horizontal t forwards?) (with-define (move) ((if forwards? go-right go-left)) (with-define (next) (go-to-next-inside move inside-graphics-context?) (go-to-next-such-that next inside-graphical-text-context?)))))

  (define-option-require opt decl)
    <= (((graphical-text-context? t)) (tm-define-overloaded (kbd-vertical t downwards?) (with-define (move) ((if downwards? go-down go-up)) (with-define (next) (go-to-next-inside move inside-graphics-context?) (go-to-next-such-that next inside-graphical-text-context?)))))
    => (define-option-match opt decl) <= ((lambda (t downwards?) (graphical-text-context? t)) (tm-define-overloaded (kbd-vertical t downwards?) (with-define (move) ((if downwards? go-down go-up)) (with-define (next) (go-to-next-inside move inside-graphics-context?) (go-to-next-such-that next inside-graphical-text-context?)))))

  (define-option-require opt decl)
    <= (((graphical-text-context? t)) (tm-define-overloaded (kbd-extremal t forwards?) (with-define (move) ((if forwards? go-right go-left)) (with-define (next) (go-to-next-inside move inside-graphics-context?) (with-define (action) (go-to-next-such-that next inside-graphical-text-context?) (go-to-repeat action))))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (graphical-text-context? t)) (tm-define-overloaded (kbd-extremal t forwards?) (with-define (move) ((if forwards? go-right go-left)) (with-define (next) (go-to-next-inside move inside-graphics-context?) (with-define (action) (go-to-next-such-that next inside-graphical-text-context?) (go-to-repeat action))))))

  (define-option-require opt decl)
    <= (((graphical-text-context? t)) (tm-define-overloaded (geometry-horizontal t forwards?) (let* ((old (graphical-get-attribute t "text-at-halign")) (new (if forwards? (cond ((== old "right") "center") (else "left")) (cond ((== old "left") "center") (else "right"))))) (graphical-set-attribute t "text-at-halign" new))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (graphical-text-context? t)) (tm-define-overloaded (geometry-horizontal t forwards?) (let* ((old (graphical-get-attribute t "text-at-halign")) (new (if forwards? (cond ((== old "right") "center") (else "left")) (cond ((== old "left") "center") (else "right"))))) (graphical-set-attribute t "text-at-halign" new))))

  (define-option-require opt decl)
    <= (((graphical-text-context? t)) (tm-define-overloaded (geometry-vertical t down?) (display* t ", " (graphics-valign-var t) "
") (let* ((valign-var (graphics-valign-var t)) (old (graphical-get-attribute t valign-var)) (new (if down? (cond ((== old "bottom") "base") ((== old "base") "axis") ((== old "axis") "center") (else "top")) (cond ((== old "top") "center") ((== old "center") "axis") ((== old "axis") "base") (else "bottom"))))) (graphical-set-attribute t valign-var new))))
    => (define-option-match opt decl) <= ((lambda (t down?) (graphical-text-context? t)) (tm-define-overloaded (geometry-vertical t down?) (display* t ", " (graphics-valign-var t) "
") (let* ((valign-var (graphics-valign-var t)) (old (graphical-get-attribute t valign-var)) (new (if down? (cond ((== old "bottom") "base") ((== old "base") "axis") ((== old "axis") "center") (else "top")) (cond ((== old "top") "center") ((== old "center") "axis") ((== old "axis") "base") (else "bottom"))))) (graphical-set-attribute t valign-var new))))

  (define-option-require opt decl)
    <= (((graphical-text-context? t)) (tm-define-overloaded (geometry-extremal t forwards?) (graphical-set-attribute t "text-at-halign" (if forwards? "left" "right"))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (graphical-text-context? t)) (tm-define-overloaded (geometry-extremal t forwards?) (graphical-set-attribute t "text-at-halign" (if forwards? "left" "right"))))

  (define-option-require opt decl)
    <= (((graphical-text-context? t)) (tm-define-overloaded (geometry-incremental t down?) (graphical-set-attribute t (graphics-valign-var t) (if down? "top" "bottom"))))
    => (define-option-match opt decl) <= ((lambda (t down?) (graphical-text-context? t)) (tm-define-overloaded (geometry-incremental t down?) (graphical-set-attribute t (graphics-valign-var t) (if down? "top" "bottom"))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (draw-over draw-under)))) (tm-define-overloaded (focus-hidden-menu t) (menu-dynamic --- ("Enter graphics" (graphics-enter)) (assuming (hidden-child? t 2) (dynamic (string-input-menu t 2))))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (draw-over draw-under)))) (tm-define-overloaded (focus-hidden-menu t) (menu-dynamic --- ("Enter graphics" (graphics-enter)) (assuming (hidden-child? t 2) (dynamic (string-input-menu t 2))))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (draw-over draw-under)))) (tm-define-overloaded (focus-hidden-icons t) (menu-dynamic (glue #f #f 10 0) ((balloon (icon "tm_enter_image.xpm") "Enter graphics mode") (graphics-enter)) (assuming (hidden-child? t 2) (dynamic (string-input-icon t 2))))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (draw-over draw-under)))) (tm-define-overloaded (focus-hidden-icons t) (menu-dynamic (glue #f #f 10 0) ((balloon (icon "tm_enter_image.xpm") "Enter graphics mode") (graphics-enter)) (assuming (hidden-child? t 2) (dynamic (string-input-icon t 2))))))

  (define-option-require opt decl)
    <= (((graphical-text-at-context? t)) (tm-define-overloaded (structured-horizontal? t) #f))
    => (define-option-match opt decl) <= ((lambda (t) (graphical-text-at-context? t)) (tm-define-overloaded (structured-horizontal? t) #f))

  (define-option-require opt decl)
    <= (((graphical-text-at-context? t)) (tm-define-overloaded (focus-hidden-menu t) (menu-dynamic --- (-> "Horizontal alignment" (link text-at-halign-menu)) (-> "Vertical alignment" (link text-at-valign-menu)))))
    => (define-option-match opt decl) <= ((lambda (t) (graphical-text-at-context? t)) (tm-define-overloaded (focus-hidden-menu t) (menu-dynamic --- (-> "Horizontal alignment" (link text-at-halign-menu)) (-> "Vertical alignment" (link text-at-valign-menu)))))

  (define-option-require opt decl)
    <= (((graphical-long-text-at-context? t)) (tm-define-overloaded (focus-hidden-menu t) (menu-dynamic --- (-> "Fill color" (link doc-at-fill-color-menu)) (-> "Horizontal alignment" (link text-at-halign-menu)) (-> "Vertical alignment" (link doc-at-valign-menu)) (-> "Text box style" (link doc-at-mode-menu)))))
    => (define-option-match opt decl) <= ((lambda (t) (graphical-long-text-at-context? t)) (tm-define-overloaded (focus-hidden-menu t) (menu-dynamic --- (-> "Fill color" (link doc-at-fill-color-menu)) (-> "Horizontal alignment" (link text-at-halign-menu)) (-> "Vertical alignment" (link doc-at-valign-menu)) (-> "Text box style" (link doc-at-mode-menu)))))

  (define-option-require opt decl)
    <= (((graphical-text-at-context? t)) (tm-define-overloaded (focus-hidden-icons t) (menu-dynamic / (mini #t (group "Alignment:") (with s (object-get-property "text-at-halign") (=> (eval s) (link text-at-halign-menu))) (with s (object-get-property "text-at-valign") (=> (eval s) (link text-at-valign-menu)))))))
    => (define-option-match opt decl) <= ((lambda (t) (graphical-text-at-context? t)) (tm-define-overloaded (focus-hidden-icons t) (menu-dynamic / (mini #t (group "Alignment:") (with s (object-get-property "text-at-halign") (=> (eval s) (link text-at-halign-menu))) (with s (object-get-property "text-at-valign") (=> (eval s) (link text-at-valign-menu)))))))

  (define-option-require opt decl)
    <= (((graphical-long-text-at-context? t)) (tm-define-overloaded (focus-hidden-icons t) (menu-dynamic / (mini #t (group "Fill color:") (with col (object-get-property "fill-color") (assuming (in? col (list "" "none" "default" "mixed")) (=> (eval (if (== "mixed") col "none")) (link doc-at-fill-color-menu))) (assuming (nin? col (list "" "none" "default" "mixed")) (=> (color col #f #f 25 17) (link doc-at-fill-color-menu))))) / (mini #t (group "Alignment:") (with s (object-get-property "text-at-halign") (=> (eval s) (link text-at-halign-menu))) (with s (object-get-property "doc-at-valign") (=> (eval s) (link doc-at-valign-menu)))) / (mini #t (group "Style:") (let* ((w (object-get-property "doc-at-width")) (m (object-get-property "doc-at-hmode"))) (=> (eval (doc-at-mode w m)) (link doc-at-mode-menu)))))))
    => (define-option-match opt decl) <= ((lambda (t) (graphical-long-text-at-context? t)) (tm-define-overloaded (focus-hidden-icons t) (menu-dynamic / (mini #t (group "Fill color:") (with col (object-get-property "fill-color") (assuming (in? col (list "" "none" "default" "mixed")) (=> (eval (if (== "mixed") col "none")) (link doc-at-fill-color-menu))) (assuming (nin? col (list "" "none" "default" "mixed")) (=> (color col #f #f 25 17) (link doc-at-fill-color-menu))))) / (mini #t (group "Alignment:") (with s (object-get-property "text-at-halign") (=> (eval s) (link text-at-halign-menu))) (with s (object-get-property "doc-at-valign") (=> (eval s) (link doc-at-valign-menu)))) / (mini #t (group "Style:") (let* ((w (object-get-property "doc-at-width")) (m (object-get-property "doc-at-hmode"))) (=> (eval (doc-at-mode w m)) (link doc-at-mode-menu)))))))

  (define-option-require opt decl)
    <= (((in? l prog-field-tags)) (tm-define-overloaded (standard-options l) (list "framed-program" "ring-program")))
    => (define-option-match opt decl) <= ((lambda (l) (in? l prog-field-tags)) (tm-define-overloaded (standard-options l) (list "framed-program" "ring-program")))

  (define-option-require opt decl)
    <= (((prog-field-context? t)) (tm-define-overloaded (focus-tag-menu t) (menu-dynamic (inert ((eval (focus-program-language)) (noop) (noop))) (when (alternate-context? t) ((check "Unfolded" "v" (alternate-second? (focus-tree))) (alternate-toggle (focus-tree)))) (assuming (focus-has-preferences? t) (-> "Preferences" (dynamic (focus-preferences-menu t)))) ("Describe" (set-message "Not yet implemented" "")))))
    => (define-option-match opt decl) <= ((lambda (t) (prog-field-context? t)) (tm-define-overloaded (focus-tag-menu t) (menu-dynamic (inert ((eval (focus-program-language)) (noop) (noop))) (when (alternate-context? t) ((check "Unfolded" "v" (alternate-second? (focus-tree))) (alternate-toggle (focus-tree)))) (assuming (focus-has-preferences? t) (-> "Preferences" (dynamic (focus-preferences-menu t)))) ("Describe" (set-message "Not yet implemented" "")))))

  (define-option-require opt decl)
    <= (((prog-field-context? t)) (tm-define-overloaded (focus-move-menu t) (menu-dynamic ("Previous field" (traverse-previous)) ("Next field" (traverse-next)) ("First field" (traverse-first)) ("Last field" (traverse-last)))))
    => (define-option-match opt decl) <= ((lambda (t) (prog-field-context? t)) (tm-define-overloaded (focus-move-menu t) (menu-dynamic ("Previous field" (traverse-previous)) ("Next field" (traverse-next)) ("First field" (traverse-first)) ("Last field" (traverse-last)))))

  (define-option-require opt decl)
    <= (((prog-field-context? t)) (tm-define-overloaded (focus-can-insert-remove? t) #t))
    => (define-option-match opt decl) <= ((lambda (t) (prog-field-context? t)) (tm-define-overloaded (focus-can-insert-remove? t) #t))

  (define-option-require opt decl)
    <= (((prog-field-context? t)) (tm-define-overloaded (focus-insert-menu t) (menu-dynamic ("Insert field above" (prog-field-insert (focus-tree) #f)) ("Insert field below" (prog-field-insert (focus-tree) #t)) ("Insert text field above" (prog-field-insert-text (focus-tree) #f)) ("Insert text field below" (prog-field-insert-text (focus-tree) #t)) --- ("Remove previous field" (prog-field-remove (focus-tree) #f)) ("Remove next field" (prog-field-remove (focus-tree) #t)) ("Remove banner" (prog-field-remove-banner (focus-tree))) ("Remove last field" (prog-field-remove-extreme (focus-tree) #t)))))
    => (define-option-match opt decl) <= ((lambda (t) (prog-field-context? t)) (tm-define-overloaded (focus-insert-menu t) (menu-dynamic ("Insert field above" (prog-field-insert (focus-tree) #f)) ("Insert field below" (prog-field-insert (focus-tree) #t)) ("Insert text field above" (prog-field-insert-text (focus-tree) #f)) ("Insert text field below" (prog-field-insert-text (focus-tree) #t)) --- ("Remove previous field" (prog-field-remove (focus-tree) #f)) ("Remove next field" (prog-field-remove (focus-tree) #t)) ("Remove banner" (prog-field-remove-banner (focus-tree))) ("Remove last field" (prog-field-remove-extreme (focus-tree) #t)))))

  (define-option-require opt decl)
    <= (((prog-field-context? t)) (tm-define-overloaded (focus-hidden-menu t) (menu-dynamic)))
    => (define-option-match opt decl) <= ((lambda (t) (prog-field-context? t)) (tm-define-overloaded (focus-hidden-menu t) (menu-dynamic)))

  (define-option-require opt decl)
    <= (((prog-field-context? t)) (tm-define-overloaded (focus-extra-menu t) (menu-dynamic --- (-> "Input options" (link program-input-menu)) (-> "Output options" (link program-output-menu)) (-> "Program" (link program-program-menu)) --- (-> "Evaluate" (link program-evaluate-menu)) ("Interrupt execution" (plugin-interrupt)) ("Close program" (plugin-stop)))))
    => (define-option-match opt decl) <= ((lambda (t) (prog-field-context? t)) (tm-define-overloaded (focus-extra-menu t) (menu-dynamic --- (-> "Input options" (link program-input-menu)) (-> "Output options" (link program-output-menu)) (-> "Program" (link program-program-menu)) --- (-> "Evaluate" (link program-evaluate-menu)) ("Interrupt execution" (plugin-interrupt)) ("Close program" (plugin-stop)))))

  (define-option-require opt decl)
    <= (((prog-field-context? t)) (tm-define-overloaded (alternate-second-name t) "Unfold"))
    => (define-option-match opt decl) <= ((lambda (t) (prog-field-context? t)) (tm-define-overloaded (alternate-second-name t) "Unfold"))

  (define-option-require opt decl)
    <= (((prog-field-context? t)) (tm-define-overloaded (alternate-second-icon t) "tm_alternate_both.xpm"))
    => (define-option-match opt decl) <= ((lambda (t) (prog-field-context? t)) (tm-define-overloaded (alternate-second-icon t) "tm_alternate_both.xpm"))

  (define-option-require opt decl)
    <= (((prog-field-context? t)) (tm-define-overloaded (focus-tag-icons t) (menu-dynamic (dynamic (focus-toggle-icons t)) (mini #t (inert ((eval (focus-program-language)) (noop)))) (assuming (focus-has-preferences? t) (=> (balloon (icon "tm_focus_prefs.xpm") "Preferences for tag") (dynamic (focus-preferences-menu t)))) ((balloon (icon "tm_focus_help.xpm") "Describe tag") (focus-help)))))
    => (define-option-match opt decl) <= ((lambda (t) (prog-field-context? t)) (tm-define-overloaded (focus-tag-icons t) (menu-dynamic (dynamic (focus-toggle-icons t)) (mini #t (inert ((eval (focus-program-language)) (noop)))) (assuming (focus-has-preferences? t) (=> (balloon (icon "tm_focus_prefs.xpm") "Preferences for tag") (dynamic (focus-preferences-menu t)))) ((balloon (icon "tm_focus_help.xpm") "Describe tag") (focus-help)))))

  (define-option-require opt decl)
    <= (((prog-field-context? t)) (tm-define-overloaded (focus-move-icons t) (menu-dynamic ((balloon (icon "tm_similar_first.xpm") "Go to first similar tag") (traverse-first)) ((balloon (icon "tm_similar_previous.xpm") "Go to previous similar tag") (traverse-previous)) ((balloon (icon "tm_similar_next.xpm") "Go to next similar tag") (traverse-next)) ((balloon (icon "tm_similar_last.xpm") "Go to last similar tag") (traverse-last)))))
    => (define-option-match opt decl) <= ((lambda (t) (prog-field-context? t)) (tm-define-overloaded (focus-move-icons t) (menu-dynamic ((balloon (icon "tm_similar_first.xpm") "Go to first similar tag") (traverse-first)) ((balloon (icon "tm_similar_previous.xpm") "Go to previous similar tag") (traverse-previous)) ((balloon (icon "tm_similar_next.xpm") "Go to next similar tag") (traverse-next)) ((balloon (icon "tm_similar_last.xpm") "Go to last similar tag") (traverse-last)))))

  (define-option-require opt decl)
    <= (((prog-field-context? t)) (tm-define-overloaded (focus-insert-icons t) (menu-dynamic ((balloon (icon "tm_insert_up.xpm") "Insert field above") (structured-insert-up)) ((balloon (icon "tm_insert_down.xpm") "Insert field below") (structured-insert-down)) ((balloon (icon "tm_delete_up.xpm") "Remove field above") (prog-field-remove (focus-tree) #f)) ((balloon (icon "tm_delete_down.xpm") "Remove field below") (prog-field-remove (focus-tree) #t)))))
    => (define-option-match opt decl) <= ((lambda (t) (prog-field-context? t)) (tm-define-overloaded (focus-insert-icons t) (menu-dynamic ((balloon (icon "tm_insert_up.xpm") "Insert field above") (structured-insert-up)) ((balloon (icon "tm_insert_down.xpm") "Insert field below") (structured-insert-down)) ((balloon (icon "tm_delete_up.xpm") "Remove field above") (prog-field-remove (focus-tree) #f)) ((balloon (icon "tm_delete_down.xpm") "Remove field below") (prog-field-remove (focus-tree) #t)))))

  (define-option-require opt decl)
    <= (((prog-field-context? t)) (tm-define-overloaded (focus-hidden-icons t) (menu-dynamic)))
    => (define-option-match opt decl) <= ((lambda (t) (prog-field-context? t)) (tm-define-overloaded (focus-hidden-icons t) (menu-dynamic)))

  (define-option-require opt decl)
    <= (((prog-field-context? t)) (tm-define-overloaded (focus-extra-icons t) (menu-dynamic (glue #f #f 8 0) (=> (balloon (icon "tm_plugin_input.xpm") "Input options") (link program-input-menu)) (=> (balloon (icon "tm_plugin_output.xpm") "Output options") (link program-output-menu)) (=> (balloon (icon "tm_session_session.xpm") "Program commands") (link program-program-menu)) (glue #f #f 10 0) (=> (balloon (icon "tm_go.xpm") "Evaluate fields") (link program-evaluate-menu)) (if (!= (get-env "prog-language") "scheme") ((balloon (icon "tm_stop.xpm") "Interrupt execution") (plugin-interrupt)) ((balloon (icon "tm_clsession.xpm") "Close program") (plugin-stop))))))
    => (define-option-match opt decl) <= ((lambda (t) (prog-field-context? t)) (tm-define-overloaded (focus-extra-icons t) (menu-dynamic (glue #f #f 8 0) (=> (balloon (icon "tm_plugin_input.xpm") "Input options") (link program-input-menu)) (=> (balloon (icon "tm_plugin_output.xpm") "Output options") (link program-output-menu)) (=> (balloon (icon "tm_session_session.xpm") "Program commands") (link program-program-menu)) (glue #f #f 10 0) (=> (balloon (icon "tm_go.xpm") "Evaluate fields") (link program-evaluate-menu)) (if (!= (get-env "prog-language") "scheme") ((balloon (icon "tm_stop.xpm") "Interrupt execution") (plugin-interrupt)) ((balloon (icon "tm_clsession.xpm") "Close program") (plugin-stop))))))

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" program-math-input?) (tm-define-overloaded (toggle-program-math-input) (ahash-set! program-math-input (program-key) (not (program-math-input?))) (with-innermost t prog-field-context? (prog-field-update-math t))))
    => ((quote toggle-program-math-input) #:check-mark (list "v" program-math-input?))
 => cons <> cur-props
    => cur-props => (((quote toggle-program-math-input) #:check-mark (list "v" program-math-input?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle mathematical input in programs.") (tm-define-overloaded (toggle-program-math-input) (ahash-set! program-math-input (program-key) (not (program-math-input?))) (with-innermost t prog-field-context? (prog-field-update-math t))))
   => ((quote toggle-program-math-input) #:synopsis (quote ("Toggle mathematical input in programs.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-program-math-input) #:synopsis (quote ("Toggle mathematical input in programs."))) ((quote toggle-program-math-input) #:check-mark (list "v" program-math-input?)))

(property-set! var prop what conds*)
  <= (toggle-program-math-input #:synopsis ("Toggle mathematical input in programs.") ())

(property-set! var prop what conds*)
  <= (toggle-program-math-input #:check-mark ("v" #<procedure program-math-input? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" program-multiline-input?) (tm-define-overloaded (toggle-program-multiline-input) (ahash-set! program-multiline-input (program-key) (not (program-multiline-input?)))))
    => ((quote toggle-program-multiline-input) #:check-mark (list "v" program-multiline-input?))
 => cons <> cur-props
    => cur-props => (((quote toggle-program-multiline-input) #:check-mark (list "v" program-multiline-input?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle multi-line input in programs.") (tm-define-overloaded (toggle-program-multiline-input) (ahash-set! program-multiline-input (program-key) (not (program-multiline-input?)))))
   => ((quote toggle-program-multiline-input) #:synopsis (quote ("Toggle multi-line input in programs.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-program-multiline-input) #:synopsis (quote ("Toggle multi-line input in programs."))) ((quote toggle-program-multiline-input) #:check-mark (list "v" program-multiline-input?)))

(property-set! var prop what conds*)
  <= (toggle-program-multiline-input #:synopsis ("Toggle multi-line input in programs.") ())

(property-set! var prop what conds*)
  <= (toggle-program-multiline-input #:check-mark ("v" #<procedure program-multiline-input? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" program-output-timings?) (tm-define-overloaded (toggle-program-output-timings) (ahash-set! program-output-timings (program-key) (not (program-output-timings?)))))
    => ((quote toggle-program-output-timings) #:check-mark (list "v" program-output-timings?))
 => cons <> cur-props
    => cur-props => (((quote toggle-program-output-timings) #:check-mark (list "v" program-output-timings?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle output of evaluation timings.") (tm-define-overloaded (toggle-program-output-timings) (ahash-set! program-output-timings (program-key) (not (program-output-timings?)))))
   => ((quote toggle-program-output-timings) #:synopsis (quote ("Toggle output of evaluation timings.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-program-output-timings) #:synopsis (quote ("Toggle output of evaluation timings."))) ((quote toggle-program-output-timings) #:check-mark (list "v" program-output-timings?)))

(property-set! var prop what conds*)
  <= (toggle-program-output-timings #:synopsis ("Toggle output of evaluation timings.") ())

(property-set! var prop what conds*)
  <= (toggle-program-output-timings #:check-mark ("v" #<procedure program-output-timings? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" program-session-mode?) (tm-define-overloaded (toggle-session-program) (with t (tree-innermost (quote (program session))) (when t (if (program-session-mode?) (program->session t) (session->program t))))))
    => ((quote toggle-session-program) #:check-mark (list "v" program-session-mode?))
 => cons <> cur-props
    => cur-props => (((quote toggle-session-program) #:check-mark (list "v" program-session-mode?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle evaluation mode.") (tm-define-overloaded (toggle-session-program) (with t (tree-innermost (quote (program session))) (when t (if (program-session-mode?) (program->session t) (session->program t))))))
   => ((quote toggle-session-program) #:synopsis (quote ("Toggle evaluation mode.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-session-program) #:synopsis (quote ("Toggle evaluation mode."))) ((quote toggle-session-program) #:check-mark (list "v" program-session-mode?)))

(property-set! var prop what conds*)
  <= (toggle-session-program #:synopsis ("Toggle evaluation mode.") ())

(property-set! var prop what conds*)
  <= (toggle-session-program #:check-mark ("v" #<procedure program-session-mode? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" program-scheme-trees?) (tm-define-overloaded (toggle-program-scheme-trees) (set! program-scheme-trees (not program-scheme-trees))))
    => ((quote toggle-program-scheme-trees) #:check-mark (list "v" program-scheme-trees?))
 => cons <> cur-props
    => cur-props => (((quote toggle-program-scheme-trees) #:check-mark (list "v" program-scheme-trees?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle pretty tree output in scheme programs.") (tm-define-overloaded (toggle-program-scheme-trees) (set! program-scheme-trees (not program-scheme-trees))))
   => ((quote toggle-program-scheme-trees) #:synopsis (quote ("Toggle pretty tree output in scheme programs.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-program-scheme-trees) #:synopsis (quote ("Toggle pretty tree output in scheme programs."))) ((quote toggle-program-scheme-trees) #:check-mark (list "v" program-scheme-trees?)))

(property-set! var prop what conds*)
  <= (toggle-program-scheme-trees #:synopsis ("Toggle pretty tree output in scheme programs.") ())

(property-set! var prop what conds*)
  <= (toggle-program-scheme-trees #:check-mark ("v" #<procedure program-scheme-trees? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" program-scheme-math?) (tm-define-overloaded (toggle-program-scheme-math) (set! program-scheme-math (not program-scheme-math))))
    => ((quote toggle-program-scheme-math) #:check-mark (list "v" program-scheme-math?))
 => cons <> cur-props
    => cur-props => (((quote toggle-program-scheme-math) #:check-mark (list "v" program-scheme-math?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle pretty math output in scheme programs.") (tm-define-overloaded (toggle-program-scheme-math) (set! program-scheme-math (not program-scheme-math))))
   => ((quote toggle-program-scheme-math) #:synopsis (quote ("Toggle pretty math output in scheme programs.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-program-scheme-math) #:synopsis (quote ("Toggle pretty math output in scheme programs."))) ((quote toggle-program-scheme-math) #:check-mark (list "v" program-scheme-math?)))

(property-set! var prop what conds*)
  <= (toggle-program-scheme-math #:synopsis ("Toggle pretty math output in scheme programs.") ())

(property-set! var prop what conds*)
  <= (toggle-program-scheme-math #:check-mark ("v" #<procedure program-scheme-math? ()>) ())

  (define-option-require opt decl)
    <= (((== l "program")) (tm-define-overloaded (standard-parameters l) (prog-field-parameters "program")))
    => (define-option-match opt decl) <= ((lambda (l) (== l "program")) (tm-define-overloaded (standard-parameters l) (prog-field-parameters "program")))

  (define-option-require opt decl)
    <= (((== l "input")) (tm-define-overloaded (standard-parameters l) (prog-field-parameters "input")))
    => (define-option-match opt decl) <= ((lambda (l) (== l "input")) (tm-define-overloaded (standard-parameters l) (prog-field-parameters "input")))

  (define-option-require opt decl)
    <= (((== l "output")) (tm-define-overloaded (standard-parameters l) (prog-field-parameters "output")))
    => (define-option-match opt decl) <= ((lambda (l) (== l "output")) (tm-define-overloaded (standard-parameters l) (prog-field-parameters "output")))

  (define-option-require opt decl)
    <= (((== l "errput")) (tm-define-overloaded (standard-parameters l) (prog-field-parameters "errput")))
    => (define-option-match opt decl) <= ((lambda (l) (== l "errput")) (tm-define-overloaded (standard-parameters l) (prog-field-parameters "errput")))

  (define-option-require opt decl)
    <= (((== l "textput")) (tm-define-overloaded (standard-parameters l) (prog-field-parameters "textput")))
    => (define-option-match opt decl) <= ((lambda (l) (== l "textput")) (tm-define-overloaded (standard-parameters l) (prog-field-parameters "textput")))

  (define-option-require opt decl)
    <= (((prog-field-input-context? t)) (tm-define-overloaded (kbd-enter t shift?) (cond ((xor (program-multiline-input?) shift?) (insert-return)) ((program-supports-input-done?) (let* ((lan (get-env "prog-language")) (ses (get-env "prog-program")) (opts (input-options t)) (st (tree->stree (tree-ref t 1))) (pre (plugin-preprocess lan ses st opts)) (in (plugin-serialize lan pre)) (rew (if (string-ends? in "
") (string-drop-right in 1) in)) (cmd (string-append "(input-done? " (string-quote rew) ")")) (ret (lambda (done?) (kbd-enter-sub t done?)))) (plugin-command lan ses cmd ret (quote ())))) (else (program-evaluate)))))
    => (define-option-match opt decl) <= ((lambda (t shift?) (prog-field-input-context? t)) (tm-define-overloaded (kbd-enter t shift?) (cond ((xor (program-multiline-input?) shift?) (insert-return)) ((program-supports-input-done?) (let* ((lan (get-env "prog-language")) (ses (get-env "prog-program")) (opts (input-options t)) (st (tree->stree (tree-ref t 1))) (pre (plugin-preprocess lan ses st opts)) (in (plugin-serialize lan pre)) (rew (if (string-ends? in "
") (string-drop-right in 1) in)) (cmd (string-append "(input-done? " (string-quote rew) ")")) (ret (lambda (done?) (kbd-enter-sub t done?)))) (plugin-command lan ses cmd ret (quote ())))) (else (program-evaluate)))))

  (define-option-require opt decl)
    <= (((prog-field-context? t)) (tm-define-overloaded (kbd-horizontal t forwards?) (with move (if forwards? go-right go-left) (go-to-remain-inside move prog-field-context? 1))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (prog-field-context? t)) (tm-define-overloaded (kbd-horizontal t forwards?) (with move (if forwards? go-right go-left) (go-to-remain-inside move prog-field-context? 1))))

  (define-option-require opt decl)
    <= (((prog-field-context? t)) (tm-define-overloaded (kbd-extremal t forwards?) (with move (if forwards? go-end-line go-start-line) (go-to-remain-inside move prog-field-context? 1))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (prog-field-context? t)) (tm-define-overloaded (kbd-extremal t forwards?) (with move (if forwards? go-end-line go-start-line) (go-to-remain-inside move prog-field-context? 1))))

  (define-option-require opt decl)
    <= (((prog-field-context? t)) (tm-define-overloaded (kbd-vertical t downwards?) (if downwards? (prog-field-go-down) (prog-field-go-up))))
    => (define-option-match opt decl) <= ((lambda (t downwards?) (prog-field-context? t)) (tm-define-overloaded (kbd-vertical t downwards?) (if downwards? (prog-field-go-down) (prog-field-go-up))))

  (define-option-require opt decl)
    <= (((prog-field-context? t)) (tm-define-overloaded (kbd-incremental t downwards?) (for (n 0 5) (if downwards? (prog-field-go-to-next) (prog-field-go-to-previous)))))
    => (define-option-match opt decl) <= ((lambda (t downwards?) (prog-field-context? t)) (tm-define-overloaded (kbd-incremental t downwards?) (for (n 0 5) (if downwards? (prog-field-go-to-next) (prog-field-go-to-previous)))))

  (define-option-require opt decl)
    <= (((prog-field-input-context? t)) (tm-define-overloaded (kbd-remove t forwards?) (cond ((and (tree-cursor-at? t 1 #:start) (not forwards?)) (noop)) ((and (tree-cursor-at? t 1 #:end) forwards?) (noop)) (else (remove-text forwards?)))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (prog-field-input-context? t)) (tm-define-overloaded (kbd-remove t forwards?) (cond ((and (tree-cursor-at? t 1 #:start) (not forwards?)) (noop)) ((and (tree-cursor-at? t 1 #:end) forwards?) (noop)) (else (remove-text forwards?)))))

  (define-option-require opt decl)
    <= (((and (prog-field-input-context? t) (selection-active-any?))) (tm-define-overloaded (kbd-remove t forwards?) (clipboard-cut "nowhere") (clipboard-clear "nowhere")))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (and (prog-field-input-context? t) (selection-active-any?))) (tm-define-overloaded (kbd-remove t forwards?) (clipboard-cut "nowhere") (clipboard-clear "nowhere")))

  (define-option-require opt decl)
    <= (((and (prog-field-context? t) (program-supports-completions?))) (tm-define-overloaded (kbd-variant t forwards?) (let* ((lan (get-env "prog-language")) (ses (get-env "prog-program")) (cmd (session-complete-command t)) (ret (lambda (x) (when x (custom-complete (tm->tree x)))))) (when (!= cmd "") (plugin-command lan ses cmd ret (quote ()))))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (and (prog-field-context? t) (program-supports-completions?))) (tm-define-overloaded (kbd-variant t forwards?) (let* ((lan (get-env "prog-language")) (ses (get-env "prog-program")) (cmd (session-complete-command t)) (ret (lambda (x) (when x (custom-complete (tm->tree x)))))) (when (!= cmd "") (plugin-command lan ses cmd ret (quote ()))))))

  (define-option-require opt decl)
    <= (((and (tree-is? t (quote document)) (prog-field-input-context? (tree-ref t #:up)))) (tm-define-overloaded (document-context? t) #f))
    => (define-option-match opt decl) <= ((lambda (t) (and (tree-is? t (quote document)) (prog-field-input-context? (tree-ref t #:up)))) (tm-define-overloaded (document-context? t) #f))

  (define-option-require opt decl)
    <= (((prog-field-input-context? t)) (tm-define-overloaded (traverse-horizontal t forwards?) (with move (if forwards? go-to-next-word go-to-previous-word) (go-to-remain-inside move prog-field-context? 1))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (prog-field-input-context? t)) (tm-define-overloaded (traverse-horizontal t forwards?) (with move (if forwards? go-to-next-word go-to-previous-word) (go-to-remain-inside move prog-field-context? 1))))

  (define-option-require opt decl)
    <= (((prog-field-input-context? t)) (tm-define-overloaded (traverse-vertical t downwards?) (if downwards? (prog-field-go-down) (prog-field-go-up))))
    => (define-option-match opt decl) <= ((lambda (t downwards?) (prog-field-input-context? t)) (tm-define-overloaded (traverse-vertical t downwards?) (if downwards? (prog-field-go-down) (prog-field-go-up))))

  (define-option-require opt decl)
    <= (((prog-field-input-context? t)) (tm-define-overloaded (traverse-extremal t forwards?) (with move (if forwards? prog-field-go-down prog-field-go-up) (go-to-repeat move))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (prog-field-input-context? t)) (tm-define-overloaded (traverse-extremal t forwards?) (with move (if forwards? prog-field-go-down prog-field-go-up) (go-to-repeat move))))

  (define-option-require opt decl)
    <= (((prog-field-input-context? t)) (tm-define-overloaded (traverse-incremental t downwards?) (if downwards? (prog-field-go-down) (prog-field-go-up))))
    => (define-option-match opt decl) <= ((lambda (t downwards?) (prog-field-input-context? t)) (tm-define-overloaded (traverse-incremental t downwards?) (if downwards? (prog-field-go-down) (prog-field-go-up))))

  (define-option-require opt decl)
    <= (((prog-field-input-context? t)) (tm-define-overloaded (structured-horizontal t forwards?) (noop)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (prog-field-input-context? t)) (tm-define-overloaded (structured-horizontal t forwards?) (noop)))

  (define-option-require opt decl)
    <= (((prog-field-input-context? t)) (tm-define-overloaded (structured-vertical t downwards?) (with move (if downwards? prog-field-go-down prog-field-go-up) (go-to-remain-inside move (quote program)))))
    => (define-option-match opt decl) <= ((lambda (t downwards?) (prog-field-input-context? t)) (tm-define-overloaded (structured-vertical t downwards?) (with move (if downwards? prog-field-go-down prog-field-go-up) (go-to-remain-inside move (quote program)))))

  (define-option-require opt decl)
    <= (((prog-field-unfolded-context? t)) (tm-define-overloaded (alternate-toggle t) (with i (tree-down-index t) (variant-set t (ahash-ref alternate-table (tree-label t))) (if (== i 2) (tree-go-to t 1 #:end)))))
    => (define-option-match opt decl) <= ((lambda (t) (prog-field-unfolded-context? t)) (tm-define-overloaded (alternate-toggle t) (with i (tree-down-index t) (variant-set t (ahash-ref alternate-table (tree-label t))) (if (== i 2) (tree-go-to t 1 #:end)))))

  (define-option-require opt decl)
    <= (((prog-field-folded-context? t)) (tm-define-overloaded (alternate-toggle t) (variant-set t (ahash-ref alternate-table (tree-label t)))))
    => (define-option-match opt decl) <= ((lambda (t) (prog-field-folded-context? t)) (tm-define-overloaded (alternate-toggle t) (variant-set t (ahash-ref alternate-table (tree-label t)))))

  (define-option-require opt decl)
    <= (((prog-field-input-context? t)) (tm-define-overloaded (structured-insert-horizontal t forwards?) (if forwards? (prog-field-insert-fold t))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (prog-field-input-context? t)) (tm-define-overloaded (structured-insert-horizontal t forwards?) (if forwards? (prog-field-insert-fold t))))

  (define-option-require opt decl)
    <= (((prog-field-input-context? t)) (tm-define-overloaded (structured-insert-vertical t downwards?) (prog-field-insert t downwards?)))
    => (define-option-match opt decl) <= ((lambda (t downwards?) (prog-field-input-context? t)) (tm-define-overloaded (structured-insert-vertical t downwards?) (prog-field-insert t downwards?)))

  (define-option-require opt decl)
    <= (((prog-field-input-context? t)) (tm-define-overloaded (structured-remove-horizontal t forwards?) (prog-field-remove t forwards?)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (prog-field-input-context? t)) (tm-define-overloaded (structured-remove-horizontal t forwards?) (prog-field-remove t forwards?)))

  (define-option-require opt decl)
    <= (((prog-field-input-context? t)) (tm-define-overloaded (structured-remove-vertical t forwards?) (prog-field-remove t forwards?)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (prog-field-input-context? t)) (tm-define-overloaded (structured-remove-vertical t forwards?) (prog-field-remove t forwards?)))

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (open-remote-plugin-selector name call-back) (dialogue-window select-remote-plugin-widget call-back name)))
    => ((quote open-remote-plugin-selector) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-remote-plugin-selector) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-remote-plugin-selector #:interactive (#t) ())

  (define-option-require opt decl)
    <= (((in? l field-tags)) (tm-define-overloaded (standard-options l) (list "framed-session" "ring-session" "large-formulas")))
    => (define-option-match opt decl) <= ((lambda (l) (in? l field-tags)) (tm-define-overloaded (standard-options l) (list "framed-session" "ring-session" "large-formulas")))

  (define-option-require opt decl)
    <= (((field-context? t)) (tm-define-overloaded (focus-tag-menu t) (menu-dynamic (inert ((eval (focus-session-language)) (noop) (noop))) (when (alternate-context? t) ((check "Unfolded" "v" (alternate-second? (focus-tree))) (alternate-toggle (focus-tree)))) (assuming (focus-has-preferences? t) (-> "Preferences" (dynamic (focus-preferences-menu t)))) ("Describe" (set-message "Not yet implemented" "")))))
    => (define-option-match opt decl) <= ((lambda (t) (field-context? t)) (tm-define-overloaded (focus-tag-menu t) (menu-dynamic (inert ((eval (focus-session-language)) (noop) (noop))) (when (alternate-context? t) ((check "Unfolded" "v" (alternate-second? (focus-tree))) (alternate-toggle (focus-tree)))) (assuming (focus-has-preferences? t) (-> "Preferences" (dynamic (focus-preferences-menu t)))) ("Describe" (set-message "Not yet implemented" "")))))

  (define-option-require opt decl)
    <= (((field-context? t)) (tm-define-overloaded (focus-move-menu t) (menu-dynamic ("Previous field" (traverse-previous)) ("Next field" (traverse-next)) ("First field" (traverse-first)) ("Last field" (traverse-last)))))
    => (define-option-match opt decl) <= ((lambda (t) (field-context? t)) (tm-define-overloaded (focus-move-menu t) (menu-dynamic ("Previous field" (traverse-previous)) ("Next field" (traverse-next)) ("First field" (traverse-first)) ("Last field" (traverse-last)))))

  (define-option-require opt decl)
    <= (((field-context? t)) (tm-define-overloaded (focus-can-insert-remove? t) #t))
    => (define-option-match opt decl) <= ((lambda (t) (field-context? t)) (tm-define-overloaded (focus-can-insert-remove? t) #t))

  (define-option-require opt decl)
    <= (((field-context? t)) (tm-define-overloaded (focus-insert-menu t) (menu-dynamic ("Insert field above" (field-insert (focus-tree) #f)) ("Insert field below" (field-insert (focus-tree) #t)) ("Insert text field above" (field-insert-text (focus-tree) #f)) ("Insert text field below" (field-insert-text (focus-tree) #t)) --- ("Remove previous field" (field-remove (focus-tree) #f)) ("Remove next field" (field-remove (focus-tree) #t)) ("Remove banner" (field-remove-banner (focus-tree))) ("Remove last field" (field-remove-extreme (focus-tree) #t)))))
    => (define-option-match opt decl) <= ((lambda (t) (field-context? t)) (tm-define-overloaded (focus-insert-menu t) (menu-dynamic ("Insert field above" (field-insert (focus-tree) #f)) ("Insert field below" (field-insert (focus-tree) #t)) ("Insert text field above" (field-insert-text (focus-tree) #f)) ("Insert text field below" (field-insert-text (focus-tree) #t)) --- ("Remove previous field" (field-remove (focus-tree) #f)) ("Remove next field" (field-remove (focus-tree) #t)) ("Remove banner" (field-remove-banner (focus-tree))) ("Remove last field" (field-remove-extreme (focus-tree) #t)))))

  (define-option-require opt decl)
    <= (((field-context? t)) (tm-define-overloaded (focus-hidden-menu t) (menu-dynamic)))
    => (define-option-match opt decl) <= ((lambda (t) (field-context? t)) (tm-define-overloaded (focus-hidden-menu t) (menu-dynamic)))

  (define-option-require opt decl)
    <= (((field-context? t)) (tm-define-overloaded (focus-extra-menu t) (menu-dynamic --- (-> "Input options" (link session-input-menu)) (-> "Output options" (link session-output-menu)) (-> "Session" (link session-session-menu)) --- (-> "Evaluate" (link session-evaluate-menu)) ("Interrupt execution" (plugin-interrupt)) ("Close session" (plugin-stop)))))
    => (define-option-match opt decl) <= ((lambda (t) (field-context? t)) (tm-define-overloaded (focus-extra-menu t) (menu-dynamic --- (-> "Input options" (link session-input-menu)) (-> "Output options" (link session-output-menu)) (-> "Session" (link session-session-menu)) --- (-> "Evaluate" (link session-evaluate-menu)) ("Interrupt execution" (plugin-interrupt)) ("Close session" (plugin-stop)))))

  (define-option-require opt decl)
    <= (((field-context? t)) (tm-define-overloaded (alternate-second-name t) "Unfold"))
    => (define-option-match opt decl) <= ((lambda (t) (field-context? t)) (tm-define-overloaded (alternate-second-name t) "Unfold"))

  (define-option-require opt decl)
    <= (((field-context? t)) (tm-define-overloaded (alternate-second-icon t) "tm_alternate_both.xpm"))
    => (define-option-match opt decl) <= ((lambda (t) (field-context? t)) (tm-define-overloaded (alternate-second-icon t) "tm_alternate_both.xpm"))

  (define-option-require opt decl)
    <= (((field-context? t)) (tm-define-overloaded (focus-tag-icons t) (menu-dynamic (dynamic (focus-toggle-icons t)) (mini #t (inert ((eval (focus-session-language)) (noop)))) (assuming (focus-has-preferences? t) (=> (balloon (icon "tm_focus_prefs.xpm") "Preferences for tag") (dynamic (focus-preferences-menu t)))) ((balloon (icon "tm_focus_help.xpm") "Describe tag") (focus-help)))))
    => (define-option-match opt decl) <= ((lambda (t) (field-context? t)) (tm-define-overloaded (focus-tag-icons t) (menu-dynamic (dynamic (focus-toggle-icons t)) (mini #t (inert ((eval (focus-session-language)) (noop)))) (assuming (focus-has-preferences? t) (=> (balloon (icon "tm_focus_prefs.xpm") "Preferences for tag") (dynamic (focus-preferences-menu t)))) ((balloon (icon "tm_focus_help.xpm") "Describe tag") (focus-help)))))

  (define-option-require opt decl)
    <= (((field-context? t)) (tm-define-overloaded (focus-move-icons t) (menu-dynamic ((balloon (icon "tm_similar_first.xpm") "Go to first similar tag") (traverse-first)) ((balloon (icon "tm_similar_previous.xpm") "Go to previous similar tag") (traverse-previous)) ((balloon (icon "tm_similar_next.xpm") "Go to next similar tag") (traverse-next)) ((balloon (icon "tm_similar_last.xpm") "Go to last similar tag") (traverse-last)))))
    => (define-option-match opt decl) <= ((lambda (t) (field-context? t)) (tm-define-overloaded (focus-move-icons t) (menu-dynamic ((balloon (icon "tm_similar_first.xpm") "Go to first similar tag") (traverse-first)) ((balloon (icon "tm_similar_previous.xpm") "Go to previous similar tag") (traverse-previous)) ((balloon (icon "tm_similar_next.xpm") "Go to next similar tag") (traverse-next)) ((balloon (icon "tm_similar_last.xpm") "Go to last similar tag") (traverse-last)))))

  (define-option-require opt decl)
    <= (((field-context? t)) (tm-define-overloaded (focus-insert-icons t) (menu-dynamic ((balloon (icon "tm_insert_up.xpm") "Insert field above") (structured-insert-up)) ((balloon (icon "tm_insert_down.xpm") "Insert field below") (structured-insert-down)) ((balloon (icon "tm_delete_up.xpm") "Remove field above") (field-remove (focus-tree) #f)) ((balloon (icon "tm_delete_down.xpm") "Remove field below") (field-remove (focus-tree) #t)))))
    => (define-option-match opt decl) <= ((lambda (t) (field-context? t)) (tm-define-overloaded (focus-insert-icons t) (menu-dynamic ((balloon (icon "tm_insert_up.xpm") "Insert field above") (structured-insert-up)) ((balloon (icon "tm_insert_down.xpm") "Insert field below") (structured-insert-down)) ((balloon (icon "tm_delete_up.xpm") "Remove field above") (field-remove (focus-tree) #f)) ((balloon (icon "tm_delete_down.xpm") "Remove field below") (field-remove (focus-tree) #t)))))

  (define-option-require opt decl)
    <= (((field-context? t)) (tm-define-overloaded (focus-hidden-icons t) (menu-dynamic)))
    => (define-option-match opt decl) <= ((lambda (t) (field-context? t)) (tm-define-overloaded (focus-hidden-icons t) (menu-dynamic)))

  (define-option-require opt decl)
    <= (((field-context? t)) (tm-define-overloaded (focus-extra-icons t) (menu-dynamic (glue #f #f 8 0) (=> (balloon (icon "tm_plugin_input.xpm") "Input options") (link session-input-menu)) (=> (balloon (icon "tm_plugin_output.xpm") "Output options") (link session-output-menu)) (=> (balloon (icon "tm_session_session.xpm") "Session commands") (link session-session-menu)) (glue #f #f 10 0) (=> (balloon (icon "tm_go.xpm") "Evaluate fields") (link session-evaluate-menu)) (if (!= (get-env "prog-language") "scheme") ((balloon (icon "tm_stop.xpm") "Interrupt execution") (plugin-interrupt)) ((balloon (icon "tm_clsession.xpm") "Close session") (plugin-stop))))))
    => (define-option-match opt decl) <= ((lambda (t) (field-context? t)) (tm-define-overloaded (focus-extra-icons t) (menu-dynamic (glue #f #f 8 0) (=> (balloon (icon "tm_plugin_input.xpm") "Input options") (link session-input-menu)) (=> (balloon (icon "tm_plugin_output.xpm") "Output options") (link session-output-menu)) (=> (balloon (icon "tm_session_session.xpm") "Session commands") (link session-session-menu)) (glue #f #f 10 0) (=> (balloon (icon "tm_go.xpm") "Evaluate fields") (link session-evaluate-menu)) (if (!= (get-env "prog-language") "scheme") ((balloon (icon "tm_stop.xpm") "Interrupt execution") (plugin-interrupt)) ((balloon (icon "tm_clsession.xpm") "Close session") (plugin-stop))))))

  (define-option-require opt decl)
    <= (((evaluate-context? t)) (tm-define-overloaded (alternate-second-name t) "Evaluate"))
    => (define-option-match opt decl) <= ((lambda (t) (evaluate-context? t)) (tm-define-overloaded (alternate-second-name t) "Evaluate"))

  (define-option-require opt decl)
    <= (((plot-context? t)) (tm-define-overloaded (alternate-second-name t) "Plot"))
    => (define-option-match opt decl) <= ((lambda (t) (plot-context? t)) (tm-define-overloaded (alternate-second-name t) "Plot"))

  (define-option-require opt decl)
    <= (((converter-context? t)) (tm-define-overloaded (alternate-second-name t) "Convert"))
    => (define-option-match opt decl) <= ((lambda (t) (converter-context? t)) (tm-define-overloaded (alternate-second-name t) "Convert"))

  (define-option-require opt decl)
    <= (((calc-labeled-context? t)) (tm-define-overloaded (pure-alternate-context? t) #f))
    => (define-option-match opt decl) <= ((lambda (t) (calc-labeled-context? t)) (tm-define-overloaded (pure-alternate-context? t) #f))

  (define-option-require opt decl)
    <= (((calc-labeled-context? t)) (tm-define-overloaded (hidden-child? t i) (== i 0)))
    => (define-option-match opt decl) <= ((lambda (t i) (calc-labeled-context? t)) (tm-define-overloaded (hidden-child? t i) (== i 0)))

  (define-option-require opt decl)
    <= (((anim-get-accelerate t)) (tm-define-overloaded (focus-tree-modified t) (reset-players (anim-get-accelerate t))))
    => (define-option-match opt decl) <= ((lambda (t) (anim-get-accelerate t)) (tm-define-overloaded (focus-tree-modified t) (reset-players (anim-get-accelerate t))))

  (define-option-require opt decl)
    <= (((anim-get-accelerate t)) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic)))
    => (define-option-match opt decl) <= ((lambda (t) (anim-get-accelerate t)) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic)))

  (define-option-require opt decl)
    <= (((anim-get-accelerate t)) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic)))
    => (define-option-match opt decl) <= ((lambda (t) (anim-get-accelerate t)) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic)))

  (define-option-require opt decl)
    <= (((anim-get-accelerate t)) (tm-define-overloaded (focus-animate-menu t) (menu-dynamic (with type (accelerate-get-type t) (-> "Time evolution" (dynamic (anim-acceleration-menu t)))))))
    => (define-option-match opt decl) <= ((lambda (t) (anim-get-accelerate t)) (tm-define-overloaded (focus-animate-menu t) (menu-dynamic (with type (accelerate-get-type t) (-> "Time evolution" (dynamic (anim-acceleration-menu t)))))))

  (define-option-require opt decl)
    <= (((anim-get-accelerate t)) (tm-define-overloaded (focus-animate-icons t) (menu-dynamic (with type (accelerate-get-type t) (=> (balloon (icon (eval (accelerate-icon type))) "Time evolution") (dynamic (anim-acceleration-menu t)))))))
    => (define-option-match opt decl) <= ((lambda (t) (anim-get-accelerate t)) (tm-define-overloaded (focus-animate-icons t) (menu-dynamic (with type (accelerate-get-type t) (=> (balloon (icon (eval (accelerate-icon type))) "Time evolution") (dynamic (anim-acceleration-menu t)))))))

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" translate-test?) (tm-define-overloaded (translate-set t x y inv?) (let* ((xx (number->string (if inv? (- x) x))) (yy (number->string (if inv? (- y) y))) (xn (if inv? "translate-end-x" "translate-start-x")) (yn (if inv? "translate-end-y" "translate-start-y"))) (tree-with-set t xn xx yn yy))))
    => ((quote translate-set) #:check-mark (list "*" translate-test?))
 => cons <> cur-props
    => cur-props => (((quote translate-set) #:check-mark (list "*" translate-test?)))

(property-set! var prop what conds*)
  <= (translate-set #:check-mark ("*" #<procedure translate-test? (t x y inv?)>) ())

  (define-option-require opt decl)
    <= (((tree-in? t (quote (translate-in)))) (tm-define-overloaded (focus-misc-icons t) (menu-dynamic (let* ((x (string->number (get-env "translate-start-x"))) (y (string->number (get-env "translate-start-y")))) (=> (balloon (icon (eval (translate-icon x y))) "Direction of translation") (dynamic (anim-translation-menu t #f)))))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (translate-in)))) (tm-define-overloaded (focus-misc-icons t) (menu-dynamic (let* ((x (string->number (get-env "translate-start-x"))) (y (string->number (get-env "translate-start-y")))) (=> (balloon (icon (eval (translate-icon x y))) "Direction of translation") (dynamic (anim-translation-menu t #f)))))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (translate-out)))) (tm-define-overloaded (focus-misc-icons t) (menu-dynamic (let* ((x (string->number (get-env "translate-end-x"))) (y (string->number (get-env "translate-end-y")))) (=> (balloon (icon (eval (translate-icon (- x) (- y)))) "Direction of translation") (dynamic (anim-translation-menu t #t)))))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (translate-out)))) (tm-define-overloaded (focus-misc-icons t) (menu-dynamic (let* ((x (string->number (get-env "translate-end-x"))) (y (string->number (get-env "translate-end-y")))) (=> (balloon (icon (eval (translate-icon (- x) (- y)))) "Direction of translation") (dynamic (anim-translation-menu t #t)))))))

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("*" progressive-test?) (tm-define-overloaded (progressive-set ft l b r t inv?) (let* ((ll (number->string (if inv? (min (- 1 l) (- 1 r)) l))) (bb (number->string (if inv? (min (- 1 b) (- 1 t)) b))) (rr (number->string (if inv? (max (- 1 l) (- 1 r)) r))) (tt (number->string (if inv? (max (- 1 b) (- 1 t)) t))) (ln (if inv? "progressive-end-l" "progressive-start-l")) (bn (if inv? "progressive-end-b" "progressive-start-b")) (rn (if inv? "progressive-end-r" "progressive-start-r")) (tn (if inv? "progressive-end-t" "progressive-start-t"))) (tree-with-set ft ln ll bn bb rn rr tn tt))))
    => ((quote progressive-set) #:check-mark (list "*" progressive-test?))
 => cons <> cur-props
    => cur-props => (((quote progressive-set) #:check-mark (list "*" progressive-test?)))

(property-set! var prop what conds*)
  <= (progressive-set #:check-mark ("*" #<procedure progressive-test? (ft l b r t inv?)>) ())

  (define-option-require opt decl)
    <= (((tree-in? ft (quote (progressive-in)))) (tm-define-overloaded (focus-misc-icons ft) (menu-dynamic (let* ((l (string->number (get-env "progressive-start-l"))) (b (string->number (get-env "progressive-start-b"))) (r (string->number (get-env "progressive-start-r"))) (t (string->number (get-env "progressive-start-t")))) (=> (balloon (icon (eval (progressive-icon l b r t #f))) "Direction of progression") (dynamic (anim-progressive-menu ft #f)))))))
    => (define-option-match opt decl) <= ((lambda (ft) (tree-in? ft (quote (progressive-in)))) (tm-define-overloaded (focus-misc-icons ft) (menu-dynamic (let* ((l (string->number (get-env "progressive-start-l"))) (b (string->number (get-env "progressive-start-b"))) (r (string->number (get-env "progressive-start-r"))) (t (string->number (get-env "progressive-start-t")))) (=> (balloon (icon (eval (progressive-icon l b r t #f))) "Direction of progression") (dynamic (anim-progressive-menu ft #f)))))))

  (define-option-require opt decl)
    <= (((tree-in? ft (quote (progressive-out)))) (tm-define-overloaded (focus-misc-icons ft) (menu-dynamic (let* ((l (string->number (get-env "progressive-end-l"))) (b (string->number (get-env "progressive-end-b"))) (r (string->number (get-env "progressive-end-r"))) (t (string->number (get-env "progressive-end-t"))) (cl (min (- 1 l) (- 1 r))) (cr (max (- 1 l) (- 1 r))) (cb (min (- 1 b) (- 1 t))) (ct (max (- 1 b) (- 1 t)))) (=> (balloon (icon (eval (progressive-icon cl cb cr ct #t))) "Direction of progression") (dynamic (anim-progressive-menu ft #t)))))))
    => (define-option-match opt decl) <= ((lambda (ft) (tree-in? ft (quote (progressive-out)))) (tm-define-overloaded (focus-misc-icons ft) (menu-dynamic (let* ((l (string->number (get-env "progressive-end-l"))) (b (string->number (get-env "progressive-end-b"))) (r (string->number (get-env "progressive-end-r"))) (t (string->number (get-env "progressive-end-t"))) (cl (min (- 1 l) (- 1 r))) (cr (max (- 1 l) (- 1 r))) (cb (min (- 1 b) (- 1 t))) (ct (max (- 1 b) (- 1 t)))) (=> (balloon (icon (eval (progressive-icon cl cb cr ct #t))) "Direction of progression") (dynamic (anim-progressive-menu ft #t)))))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote anim-edit))) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic ("Play animation" (current-anim-commit)))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote anim-edit))) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic ("Play animation" (current-anim-commit)))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (anim-static anim-dynamic)))) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic ("Edit animation" (current-anim-checkout)))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (anim-static anim-dynamic)))) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic ("Edit animation" (current-anim-checkout)))))

  (define-option-require opt decl)
    <= (((tree-func? t (quote gr-screen) 1) (user-anim-context? (tree-ref t 0))) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic (dynamic (focus-toggle-menu (tree-ref t 0))))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-func? t (quote gr-screen) 1)) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic (dynamic (focus-toggle-menu (tree-ref t 0))))))

  (define-option-require opt decl)
    <= (((user-anim-context? t)) (tm-define-overloaded (focus-hidden-menu t) (menu-dynamic)))
    => (define-option-match opt decl) <= ((lambda (t) (user-anim-context? t)) (tm-define-overloaded (focus-hidden-menu t) (menu-dynamic)))

  (define-option-require opt decl)
    <= (((tree-is? t (quote anim-edit))) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic ((balloon (icon "tm_search_next.xpm") "Play animation") (current-anim-commit)))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote anim-edit))) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic ((balloon (icon "tm_search_next.xpm") "Play animation") (current-anim-commit)))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (anim-static anim-dynamic)))) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic ((balloon (icon "tm_show_hidden.xpm") "Edit animation") (current-anim-checkout)))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (anim-static anim-dynamic)))) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic ((balloon (icon "tm_show_hidden.xpm") "Edit animation") (current-anim-checkout)))))

  (define-option-require opt decl)
    <= (((tree-func? t (quote gr-screen) 1) (user-anim-context? (tree-ref t 0))) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic (dynamic (focus-toggle-icons (tree-ref t 0))))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-func? t (quote gr-screen) 1)) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic (dynamic (focus-toggle-icons (tree-ref t 0))))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote anim-edit))) (tm-define-overloaded (focus-hidden-icons t) (menu-dynamic)))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote anim-edit))) (tm-define-overloaded (focus-hidden-icons t) (menu-dynamic)))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (anim-static anim-dynamic)))) (tm-define-overloaded (focus-hidden-icons t) (menu-dynamic (assuming (not (test-bottom-bar? "animate")) // (dynamic (anim-duration-field "Duration" t 1)) (dynamic (anim-step-field "Step" t 2))))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (anim-static anim-dynamic)))) (tm-define-overloaded (focus-hidden-icons t) (menu-dynamic (assuming (not (test-bottom-bar? "animate")) // (dynamic (anim-duration-field "Duration" t 1)) (dynamic (anim-step-field "Step" t 2))))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Pops up the help window for the innermost TeXmacs macro") (tm-define-overloaded (macro-popup-help) (with t (tree-up (cursor-tree)) (help-window "macros" (symbol->string (tree-label t))))))
   => ((quote macro-popup-help) #:synopsis (quote ("Pops up the help window for the innermost TeXmacs macro")))
 => cons <> cur-props
   => cur-props => (((quote macro-popup-help) #:synopsis (quote ("Pops up the help window for the innermost TeXmacs macro"))))

(property-set! var prop what conds*)
  <= (macro-popup-help #:synopsis ("Pops up the help window for the innermost TeXmacs macro") ())

  (define-option-argument opt decl)
    <= ((sub "Subclassification") (tm-define-overloaded (tmweb-insert-classifiers main sub) (init-env "tmweb-main" main) (init-env "tmweb-sub" sub) (and-with tit (tree-ref (buffer-tree) 0) (when (tree-is? tit (quote tmweb-title)) (and-with links (tree-ref tit 1) (with s (string-append "tmweb-" (locase-all main) "-links") (if (== s "tmweb-plug-ins-links") (set! s "tmweb-plugin-links")) (tree-set links (quasiquote ((unquote (string->symbol s)))))))))))
    => cons <> cur-props <= ((quote tmweb-insert-classifiers) #:arguments (quote (main sub)))
    => cons <> cur-props <= ((quote tmweb-insert-classifiers) (quote (#:argument sub)) (quote ("Subclassification")))
    => cur-props => (((quote tmweb-insert-classifiers) (quote (#:argument sub)) (quote ("Subclassification"))) ((quote tmweb-insert-classifiers) #:arguments (quote (main sub))))

  (define-option-argument opt decl)
    <= ((main "Main classification") (tm-define-overloaded (tmweb-insert-classifiers main sub) (init-env "tmweb-main" main) (init-env "tmweb-sub" sub) (and-with tit (tree-ref (buffer-tree) 0) (when (tree-is? tit (quote tmweb-title)) (and-with links (tree-ref tit 1) (with s (string-append "tmweb-" (locase-all main) "-links") (if (== s "tmweb-plug-ins-links") (set! s "tmweb-plugin-links")) (tree-set links (quasiquote ((unquote (string->symbol s)))))))))))
    => cons <> cur-props <= ((quote tmweb-insert-classifiers) #:arguments (quote (main sub)))
    => cons <> cur-props <= ((quote tmweb-insert-classifiers) (quote (#:argument main)) (quote ("Main classification")))
    => cur-props => (((quote tmweb-insert-classifiers) (quote (#:argument main)) (quote ("Main classification"))) ((quote tmweb-insert-classifiers) #:arguments (quote (main sub))) ((quote tmweb-insert-classifiers) (quote (#:argument sub)) (quote ("Subclassification"))) ((quote tmweb-insert-classifiers) #:arguments (quote (main sub))))

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (tmweb-insert-classifiers main sub) (init-env "tmweb-main" main) (init-env "tmweb-sub" sub) (and-with tit (tree-ref (buffer-tree) 0) (when (tree-is? tit (quote tmweb-title)) (and-with links (tree-ref tit 1) (with s (string-append "tmweb-" (locase-all main) "-links") (if (== s "tmweb-plug-ins-links") (set! s "tmweb-plugin-links")) (tree-set links (quasiquote ((unquote (string->symbol s)))))))))))
    => ((quote tmweb-insert-classifiers) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote tmweb-insert-classifiers) #:interactive (list #t)) ((quote tmweb-insert-classifiers) (quote (#:argument main)) (quote ("Main classification"))) ((quote tmweb-insert-classifiers) #:arguments (quote (main sub))) ((quote tmweb-insert-classifiers) (quote (#:argument sub)) (quote ("Subclassification"))) ((quote tmweb-insert-classifiers) #:arguments (quote (main sub))))

(property-set! var prop what conds*)
  <= (tmweb-insert-classifiers #:interactive (#t) ())

(property-set! var prop what conds*)
  <= (tmweb-insert-classifiers (#:argument main) ("Main classification") ())

(property-set! var prop what conds*)
  <= (tmweb-insert-classifiers #:arguments (main sub) ())

(property-set! var prop what conds*)
  <= (tmweb-insert-classifiers (#:argument sub) ("Subclassification") ())

(property-set! var prop what conds*)
  <= (tmweb-insert-classifiers #:arguments (main sub) ())

  (define-option-require opt decl)
    <= (((tree-in? t (quote (tmdoc-title tmweb-title tmdoc-copyright tmdoc-license tmweb-license)))) (tm-define-overloaded (focus-can-move? t) #f))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (tmdoc-title tmweb-title tmdoc-copyright tmdoc-license tmweb-license)))) (tm-define-overloaded (focus-can-move? t) #f))

  (define-option-require opt decl)
    <= (((tmdoc-propose-title?)) (tm-define-overloaded (focus-document-extra-icons t) (menu-dynamic (minibar ((balloon "Title" "Insert title") (tmdoc-insert-title))))))
    => (define-option-match opt decl) <= ((lambda (t) (tmdoc-propose-title?)) (tm-define-overloaded (focus-document-extra-icons t) (menu-dynamic (minibar ((balloon "Title" "Insert title") (tmdoc-insert-title))))))

  (define-option-require opt decl)
    <= (((tmdoc-propose-copyright-and-license?)) (tm-define-overloaded (focus-document-extra-icons t) (menu-dynamic (minibar ((balloon "Copyright" "Insert copyright and license information") (tmdoc-insert-copyright-and-license))))))
    => (define-option-match opt decl) <= ((lambda (t) (tmdoc-propose-copyright-and-license?)) (tm-define-overloaded (focus-document-extra-icons t) (menu-dynamic (minibar ((balloon "Copyright" "Insert copyright and license information") (tmdoc-insert-copyright-and-license))))))

  (define-option-require opt decl)
    <= (((tmweb-propose-title?)) (tm-define-overloaded (focus-document-extra-icons t) (menu-dynamic (minibar ((balloon "Title" "Insert title") (tmweb-insert-title))))))
    => (define-option-match opt decl) <= ((lambda (t) (tmweb-propose-title?)) (tm-define-overloaded (focus-document-extra-icons t) (menu-dynamic (minibar ((balloon "Title" "Insert title") (tmweb-insert-title))))))

  (define-option-require opt decl)
    <= (((tmweb-propose-copyright-and-license?)) (tm-define-overloaded (focus-document-extra-icons t) (menu-dynamic (minibar ((balloon "Copyright" "Insert copyright and license information") (tmweb-insert-copyright-and-license))))))
    => (define-option-match opt decl) <= ((lambda (t) (tmweb-propose-copyright-and-license?)) (tm-define-overloaded (focus-document-extra-icons t) (menu-dynamic (minibar ((balloon "Copyright" "Insert copyright and license information") (tmweb-insert-copyright-and-license))))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Create a tmlength object given its value and unit components.") (tm-define-overloaded tmlength (case-lambda (() (quote ())) ((n unit) (tmlength-check-value n) (tmlength-check-unit unit) (list n unit)))))
   => ((quote tmlength) #:synopsis (quote ("Create a tmlength object given its value and unit components.")))
 => cons <> cur-props
   => cur-props => (((quote tmlength) #:synopsis (quote ("Create a tmlength object given its value and unit components."))))

(property-set! var prop what conds*)
  <= (tmlength #:synopsis ("Create a tmlength object given its value and unit components.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Is @x a null tmlength (zero value, unspecified unit)?") (tm-define-overloaded (tmlength-null? x) (null? x)))
   => ((quote tmlength-null?) #:synopsis (quote ("Is @x a null tmlength (zero value, unspecified unit)?")))
 => cons <> cur-props
   => cur-props => (((quote tmlength-null?) #:synopsis (quote ("Is @x a null tmlength (zero value, unspecified unit)?"))))

  ((define-property which)  opt decl)
    <= ((#:type)  ((forall T (-> T bool))) (tm-define-overloaded (tmlength-null? x) (null? x)))
   => ((quote tmlength-null?) #:type (quote ((forall T (-> T bool)))))
 => cons <> cur-props
   => cur-props => (((quote tmlength-null?) #:type (quote ((forall T (-> T bool))))) ((quote tmlength-null?) #:synopsis (quote ("Is @x a null tmlength (zero value, unspecified unit)?"))))

(property-set! var prop what conds*)
  <= (tmlength-null? #:type ((forall T (-> T bool))) ())

(property-set! var prop what conds*)
  <= (tmlength-null? #:synopsis ("Is @x a null tmlength (zero value, unspecified unit)?") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Is @x a, possible null, tmlength?") (tm-define-overloaded (tmlength? x) (or (tmlength-null? x) (and (list? x) (= 2 (length x)) (tmlength-value? (first x)) (tmlength-unit? (second x))))))
   => ((quote tmlength?) #:synopsis (quote ("Is @x a, possible null, tmlength?")))
 => cons <> cur-props
   => cur-props => (((quote tmlength?) #:synopsis (quote ("Is @x a, possible null, tmlength?"))))

  ((define-property which)  opt decl)
    <= ((#:type)  ((forall T (-> T bool))) (tm-define-overloaded (tmlength? x) (or (tmlength-null? x) (and (list? x) (= 2 (length x)) (tmlength-value? (first x)) (tmlength-unit? (second x))))))
   => ((quote tmlength?) #:type (quote ((forall T (-> T bool)))))
 => cons <> cur-props
   => cur-props => (((quote tmlength?) #:type (quote ((forall T (-> T bool))))) ((quote tmlength?) #:synopsis (quote ("Is @x a, possible null, tmlength?"))))

(property-set! var prop what conds*)
  <= (tmlength? #:type ((forall T (-> T bool))) ())

(property-set! var prop what conds*)
  <= (tmlength? #:synopsis ("Is @x a, possible null, tmlength?") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Get the value part of @tmlen.") (tm-define-overloaded (tmlength-zero? tmlen) (or (tmlength-null? tmlen) (= (first tmlen) 0))))
   => ((quote tmlength-zero?) #:synopsis (quote ("Get the value part of @tmlen.")))
 => cons <> cur-props
   => cur-props => (((quote tmlength-zero?) #:synopsis (quote ("Get the value part of @tmlen."))))

  ((define-property which)  opt decl)
    <= ((#:type)  ((-> tmlength number)) (tm-define-overloaded (tmlength-zero? tmlen) (or (tmlength-null? tmlen) (= (first tmlen) 0))))
   => ((quote tmlength-zero?) #:type (quote ((-> tmlength number))))
 => cons <> cur-props
   => cur-props => (((quote tmlength-zero?) #:type (quote ((-> tmlength number)))) ((quote tmlength-zero?) #:synopsis (quote ("Get the value part of @tmlen."))))

(property-set! var prop what conds*)
  <= (tmlength-zero? #:type ((-> tmlength number)) ())

(property-set! var prop what conds*)
  <= (tmlength-zero? #:synopsis ("Get the value part of @tmlen.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Get the value part of @tmlen.") (tm-define-overloaded (tmlength-value tmlen) (if (tmlength-null? tmlen) 0 (first tmlen))))
   => ((quote tmlength-value) #:synopsis (quote ("Get the value part of @tmlen.")))
 => cons <> cur-props
   => cur-props => (((quote tmlength-value) #:synopsis (quote ("Get the value part of @tmlen."))))

  ((define-property which)  opt decl)
    <= ((#:type)  ((-> tmlength number)) (tm-define-overloaded (tmlength-value tmlen) (if (tmlength-null? tmlen) 0 (first tmlen))))
   => ((quote tmlength-value) #:type (quote ((-> tmlength number))))
 => cons <> cur-props
   => cur-props => (((quote tmlength-value) #:type (quote ((-> tmlength number)))) ((quote tmlength-value) #:synopsis (quote ("Get the value part of @tmlen."))))

(property-set! var prop what conds*)
  <= (tmlength-value #:type ((-> tmlength number)) ())

(property-set! var prop what conds*)
  <= (tmlength-value #:synopsis ("Get the value part of @tmlen.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Get the unit part of @tmlen.") (tm-define-overloaded (tmlength-unit tmlen) (if (tmlength-null? tmlen) #f (second tmlen))))
   => ((quote tmlength-unit) #:synopsis (quote ("Get the unit part of @tmlen.")))
 => cons <> cur-props
   => cur-props => (((quote tmlength-unit) #:synopsis (quote ("Get the unit part of @tmlen."))))

  ((define-property which)  opt decl)
    <= ((#:type)  ((-> tmlength symbol)) (tm-define-overloaded (tmlength-unit tmlen) (if (tmlength-null? tmlen) #f (second tmlen))))
   => ((quote tmlength-unit) #:type (quote ((-> tmlength symbol))))
 => cons <> cur-props
   => cur-props => (((quote tmlength-unit) #:type (quote ((-> tmlength symbol)))) ((quote tmlength-unit) #:synopsis (quote ("Get the unit part of @tmlen."))))

(property-set! var prop what conds*)
  <= (tmlength-unit #:type ((-> tmlength symbol)) ())

(property-set! var prop what conds*)
  <= (tmlength-unit #:synopsis ("Get the unit part of @tmlen.") ())

  ((define-property which)  opt decl)
    <= ((#:returns)  ((1 "value part of @tmlen") (2 "unit part of @tmlen")) (tm-define-overloaded (tmlength-value+unit tmlen) (if (tmlength-null? tmlen) (values 0 #f) (values (first tmlen) (second tmlen)))))
   => ((quote tmlength-value+unit) #:returns (quote ((1 "value part of @tmlen") (2 "unit part of @tmlen"))))
 => cons <> cur-props
   => cur-props => (((quote tmlength-value+unit) #:returns (quote ((1 "value part of @tmlen") (2 "unit part of @tmlen")))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Fundamental tmlength deconstructor.") (tm-define-overloaded (tmlength-value+unit tmlen) (if (tmlength-null? tmlen) (values 0 #f) (values (first tmlen) (second tmlen)))))
   => ((quote tmlength-value+unit) #:synopsis (quote ("Fundamental tmlength deconstructor.")))
 => cons <> cur-props
   => cur-props => (((quote tmlength-value+unit) #:synopsis (quote ("Fundamental tmlength deconstructor."))) ((quote tmlength-value+unit) #:returns (quote ((1 "value part of @tmlen") (2 "unit part of @tmlen")))))

  ((define-property which)  opt decl)
    <= ((#:type)  ((-> tmlength (cross tmlength-value tmlength-unit))) (tm-define-overloaded (tmlength-value+unit tmlen) (if (tmlength-null? tmlen) (values 0 #f) (values (first tmlen) (second tmlen)))))
   => ((quote tmlength-value+unit) #:type (quote ((-> tmlength (cross tmlength-value tmlength-unit)))))
 => cons <> cur-props
   => cur-props => (((quote tmlength-value+unit) #:type (quote ((-> tmlength (cross tmlength-value tmlength-unit))))) ((quote tmlength-value+unit) #:synopsis (quote ("Fundamental tmlength deconstructor."))) ((quote tmlength-value+unit) #:returns (quote ((1 "value part of @tmlen") (2 "unit part of @tmlen")))))

(property-set! var prop what conds*)
  <= (tmlength-value+unit #:type ((-> tmlength (cross tmlength-value tmlength-unit))) ())

(property-set! var prop what conds*)
  <= (tmlength-value+unit #:synopsis ("Fundamental tmlength deconstructor.") ())

(property-set! var prop what conds*)
  <= (tmlength-value+unit #:returns ((1 "value part of @tmlen") (2 "unit part of @tmlen")) ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Create a tmlength object from its string representation.") (tm-define-overloaded (string->tmlength s) (receive (value-str unit-str) (string-span (do ((ss s (string-tail ss 2))) ((not (string-starts? ss "--")) ss)) char-decimal?) (let ((value (if (string-null? value-str) 0 (string->number value-str))) (unit (if (string-null? unit-str) #f (string->symbol unit-str)))) (cond ((and (not unit) (not (zero? value))) #f) ((not unit) (tmlength)) ((not (tmlength-unit? unit)) (tmlength)) (else (tmlength value unit)))))))
   => ((quote string->tmlength) #:synopsis (quote ("Create a tmlength object from its string representation.")))
 => cons <> cur-props
   => cur-props => (((quote string->tmlength) #:synopsis (quote ("Create a tmlength object from its string representation."))))

  ((define-property which)  opt decl)
    <= ((#:type)  ((-> string tmlength)) (tm-define-overloaded (string->tmlength s) (receive (value-str unit-str) (string-span (do ((ss s (string-tail ss 2))) ((not (string-starts? ss "--")) ss)) char-decimal?) (let ((value (if (string-null? value-str) 0 (string->number value-str))) (unit (if (string-null? unit-str) #f (string->symbol unit-str)))) (cond ((and (not unit) (not (zero? value))) #f) ((not unit) (tmlength)) ((not (tmlength-unit? unit)) (tmlength)) (else (tmlength value unit)))))))
   => ((quote string->tmlength) #:type (quote ((-> string tmlength))))
 => cons <> cur-props
   => cur-props => (((quote string->tmlength) #:type (quote ((-> string tmlength)))) ((quote string->tmlength) #:synopsis (quote ("Create a tmlength object from its string representation."))))

(property-set! var prop what conds*)
  <= (string->tmlength #:type ((-> string tmlength)) ())

(property-set! var prop what conds*)
  <= (string->tmlength #:synopsis ("Create a tmlength object from its string representation.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Produce the string representation of a tmlength object.") (tm-define-overloaded (tmlength->string tmlen) (if (tmlength-null? tmlen) "" (receive (value unit) (tmlength-value+unit tmlen) (string-append (number->string value) (symbol->string unit))))))
   => ((quote tmlength->string) #:synopsis (quote ("Produce the string representation of a tmlength object.")))
 => cons <> cur-props
   => cur-props => (((quote tmlength->string) #:synopsis (quote ("Produce the string representation of a tmlength object."))))

  ((define-property which)  opt decl)
    <= ((#:type)  ((-> tmlength string)) (tm-define-overloaded (tmlength->string tmlen) (if (tmlength-null? tmlen) "" (receive (value unit) (tmlength-value+unit tmlen) (string-append (number->string value) (symbol->string unit))))))
   => ((quote tmlength->string) #:type (quote ((-> tmlength string))))
 => cons <> cur-props
   => cur-props => (((quote tmlength->string) #:type (quote ((-> tmlength string)))) ((quote tmlength->string) #:synopsis (quote ("Produce the string representation of a tmlength object."))))

(property-set! var prop what conds*)
  <= (tmlength->string #:type ((-> tmlength string)) ())

(property-set! var prop what conds*)
  <= (tmlength->string #:synopsis ("Produce the string representation of a tmlength object.") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Return necessary catcode definitions for @doc") (tm-define-overloaded (latex-catcode-defs doc) (string-append (if tmtex-use-catcodes? (begin (set! latex-catcode-table (make-ahash-table)) (latex-catcode-defs-sub doc) (let* ((l1 (ahash-table->list latex-catcode-table)) (l2 (list-sort l1 (lambda (x y) (string<=? (car x) (car y))))) (l3 (map (lambda (x) (latex-catcode-def (car x) (cdr x))) l2))) (apply string-append l3))) "") (begin (set! latex-catcode-table (make-ahash-table)) (latex-catcode-defs-sub* doc #t) (let* ((l1 (ahash-table->list latex-catcode-table)) (l2 (list-sort l1 (lambda (x y) (string<=? (car x) (car y))))) (keys (map car l2)) (ims (map (lambda (x) (string-append "
\\fontencoding{T1}\\selectfont\\symbol{" (cdr x) "}\\fontencoding{\\encodingdefault}")) l2)) (l3 (map latex-catcode-def keys ims))) (apply string-append l3))))))
   => ((quote latex-catcode-defs) #:synopsis (quote ("Return necessary catcode definitions for @doc")))
 => cons <> cur-props
   => cur-props => (((quote latex-catcode-defs) #:synopsis (quote ("Return necessary catcode definitions for @doc"))))

(property-set! var prop what conds*)
  <= (latex-catcode-defs #:synopsis ("Return necessary catcode definitions for @doc") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Expand all TeXmacs macros occurring in @t") (tm-define-overloaded (latex-expand-macros t) (if (npair? t) t (let* ((head (car t)) (tail (map latex-expand-macros (cdr t))) (body (latex-texmacs-macro-body head)) (arity (and body (latex-texmacs-arity head))) (env (and (env-begin? head) (latex-texmacs-environment-body (cadr head)))) (envar (and env (latex-texmacs-arity head)))) (cond ((and body (== (length tail) arity)) (latex-substitute body t)) ((and env (== (length tail) 1) (== (length (cddr head)) envar)) (latex-substitute env (append (cdr t) (cddr head)))) (else (cons head tail)))))))
   => ((quote latex-expand-macros) #:synopsis (quote ("Expand all TeXmacs macros occurring in @t")))
 => cons <> cur-props
   => cur-props => (((quote latex-expand-macros) #:synopsis (quote ("Expand all TeXmacs macros occurring in @t"))))

(property-set! var prop what conds*)
  <= (latex-expand-macros #:synopsis ("Expand all TeXmacs macros occurring in @t") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Return necessary macro and environment definitions for @doc") (tm-define-overloaded (latex-macro-defs t) (set! latex-macro-table (make-ahash-table)) (set! latex-env-table (make-ahash-table)) (set! latex-preamble-table (make-ahash-table)) (latex-macro-defs-sub t) (let* ((c1 (ahash-table->list latex-macro-table)) (c2 (list-sort c1 (lambda (x y) (latex<=? (car x) (car y))))) (c3 (map (cut cons (quote !newcommand) <>) c2)) (e1 (ahash-table->list latex-env-table)) (e2 (list-sort e1 (lambda (x y) (latex<=? (car x) (car y))))) (e3 (map (cut cons (quote !newenvironment) <>) e2)) (p1 (ahash-table->list latex-preamble-table)) (p2 (list-sort p1 (lambda (x y) (latex<=? (car x) (car y))))) (p3 (map cdr (map (cut latex-expand-def <> #f) p2)))) (cons (quote !append) (append c3 e3 p3)))))
   => ((quote latex-macro-defs) #:synopsis (quote ("Return necessary macro and environment definitions for @doc")))
 => cons <> cur-props
   => cur-props => (((quote latex-macro-defs) #:synopsis (quote ("Return necessary macro and environment definitions for @doc"))))

(property-set! var prop what conds*)
  <= (latex-macro-defs #:synopsis ("Return necessary macro and environment definitions for @doc") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Serialize a LaTeX preamble @t") (tm-define-overloaded (latex-serialize-preamble t) (cond ((string? t) t) ((func? t (quote !append)) (apply string-append (map latex-serialize-preamble (cdr t)))) ((func? t (quote !newcommand) 3) (apply latex-macro-def (cdr t))) ((func? t (quote !newenvironment) 3) (apply latex-env-def (cdr t))) (else (serialize-latex t)))))
   => ((quote latex-serialize-preamble) #:synopsis (quote ("Serialize a LaTeX preamble @t")))
 => cons <> cur-props
   => cur-props => (((quote latex-serialize-preamble) #:synopsis (quote ("Serialize a LaTeX preamble @t"))))

(property-set! var prop what conds*)
  <= (latex-serialize-preamble #:synopsis ("Serialize a LaTeX preamble @t") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Determine all dependencies of packages @ps") (tm-define-overloaded (latex-packages-dependencies ps) (insert-dependencies (list) ps)))
   => ((quote latex-packages-dependencies) #:synopsis (quote ("Determine all dependencies of packages @ps")))
 => cons <> cur-props
   => cur-props => (((quote latex-packages-dependencies) #:synopsis (quote ("Determine all dependencies of packages @ps"))))

(property-set! var prop what conds*)
  <= (latex-packages-dependencies #:synopsis ("Determine all dependencies of packages @ps") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Remove all implied packages in package list @ps") (tm-define-overloaded (latex-packages-simplify ps) (list-filter ps (lambda (p) (non-redundant-package? p ps)))))
   => ((quote latex-packages-simplify) #:synopsis (quote ("Remove all implied packages in package list @ps")))
 => cons <> cur-props
   => cur-props => (((quote latex-packages-simplify) #:synopsis (quote ("Remove all implied packages in package list @ps"))))

(property-set! var prop what conds*)
  <= (latex-packages-simplify #:synopsis ("Remove all implied packages in package list @ps") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Return the usepackage command for @doc") (tm-define-overloaded (latex-use-package-command doc) (set! latex-uses-table (make-ahash-table)) (latex-use-which-package doc) (let* ((l1 latex-all-packages) (s1 (latex-as-use-package (list-difference l1 (quote ("amsthm"))))) (l2 (map car (ahash-table->list latex-uses-table))) (s2 (latex-as-use-package (list-difference l2 l1)))) (string-append s1 s2))))
   => ((quote latex-use-package-command) #:synopsis (quote ("Return the usepackage command for @doc")))
 => cons <> cur-props
   => cur-props => (((quote latex-use-package-command) #:synopsis (quote ("Return the usepackage command for @doc"))))

(property-set! var prop what conds*)
  <= (latex-use-package-command #:synopsis ("Return the usepackage command for @doc") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Compute preamble for @text") (tm-define-overloaded (latex-preamble text style lan init colors colormaps) (with-global tmtex-style (if (list? style) (cAr style) style) (set! latex-packages-option (make-ahash-table)) (set-packages-option "xcolor" colormaps) (let* ((Page (latex-preamble-page-type init)) (Macro (latex-macro-defs text)) (Colors (latex-colors-defs colors)) (Text (list (quote !tuple) Page Macro Colors text)) (pre-page (latex-serialize-preamble Page)) (pre-macro (latex-serialize-preamble Macro)) (pre-colors (latex-serialize-preamble Colors)) (pre-catcode (latex-catcode-defs Text)) (pre-uses (latex-use-package-command Text))) (values (cond ((and (in? "amsthm" latex-all-packages) (== style "amsart")) "[amsthm]") ((list? style) (latex-make-option (cDr style))) (else "")) (string-append pre-uses) (string-append pre-page) (string-append pre-catcode pre-macro pre-colors))))))
   => ((quote latex-preamble) #:synopsis (quote ("Compute preamble for @text")))
 => cons <> cur-props
   => cur-props => (((quote latex-preamble) #:synopsis (quote ("Compute preamble for @text"))))

(property-set! var prop what conds*)
  <= (latex-preamble #:synopsis ("Compute preamble for @text") ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tmdoc-render-keys s) (cond ((string? s) (let* ((l1 (string-tokenize-by-char s #\space)) (l2 (map (lambda (x) (quasiquote (render-key (unquote x)))) l1))) (cond ((null? l2) (quote (render-key ""))) ((list-1? l2) (car l2)) (else (quasiquote (concat (unquote-splicing l2))))))) ((tree? s) (tmdoc-render-keys (tree->stree s))) (else (quote (render-render-keys (with "color" "red" "?")))))))
    => ((quote tmdoc-render-keys) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tmdoc-render-keys) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (tmdoc-render-keys #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tmdoc-key s) (lazy-keyboard-force #t) (cond ((string? s) (let* ((s2 (kbd-pre-rewrite s)) (s3 (kbd-post-rewrite s2 #f))) (kbd-system-rewrite s3))) ((tree? s) (tmdoc-key (tree->stree s))) (else (quote (render-key (with "color" "red" "?")))))))
    => ((quote tmdoc-key) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tmdoc-key) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (tmdoc-key #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tmdoc-key* s) (lazy-keyboard-force #t) (cond ((string? s) (kbd-system-rewrite s)) ((tree? s) (tmdoc-key* (tree->stree s))) (else (quote (render-key (with "color" "red" "?")))))))
    => ((quote tmdoc-key*) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tmdoc-key*) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (tmdoc-key* #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tmdoc-shortcut s) (lazy-keyboard-force #t) (cond ((string? s) (with r (kbd-find-rev-binding s) (tmdoc-key r))) ((tree? s) (tmdoc-shortcut (tree->stree s))) (else (quote (render-key (with "color" "red" "?")))))))
    => ((quote tmdoc-shortcut) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tmdoc-shortcut) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (tmdoc-shortcut #:secure (#t) ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Horizontal concatenation of list of LaTeX expressions") (tm-define-overloaded (tex-concat l) (let ((r (tex-concat-similar (tex-concat-list l)))) (if (null? r) "" (if (null? (cdr r)) (car r) (cons (quote !concat) r))))))
   => ((quote tex-concat) #:synopsis (quote ("Horizontal concatenation of list of LaTeX expressions")))
 => cons <> cur-props
   => cur-props => (((quote tex-concat) #:synopsis (quote ("Horizontal concatenation of list of LaTeX expressions"))))

(property-set! var prop what conds*)
  <= (tex-concat #:synopsis ("Horizontal concatenation of list of LaTeX expressions") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Variant of tex-concat which concatenates adjacent strings") (tm-define-overloaded (tex-concat* l) (tex-concat (tex-concat-strings l))))
   => ((quote tex-concat*) #:synopsis (quote ("Variant of tex-concat which concatenates adjacent strings")))
 => cons <> cur-props
   => cur-props => (((quote tex-concat*) #:synopsis (quote ("Variant of tex-concat which concatenates adjacent strings"))))

(property-set! var prop what conds*)
  <= (tex-concat* #:synopsis ("Variant of tex-concat which concatenates adjacent strings") ())

  (define-option-mode opt decl)
    <= ((natbib-package?) (tm-define-overloaded (tmtex-cite s l) (tex-apply (quote citep) (tmtex-cite-list l))))
    (ctx-add-condition! 0 (car opt)) => cur-conds => (natbib-package?)

  (define-option-mode opt decl)
    <= ((natbib-package?) (tm-define-overloaded (tmtex-cite-detail s l) (tex-apply (quote citetext) (quasiquote (!concat (citealp (unquote (tmtex (car l)))) ", " (unquote (tmtex (cadr l))))))))
    (ctx-add-condition! 0 (car opt)) => cur-conds => (natbib-package?)

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Try to export and LaTeX all TeXmacs files inside @u") (tm-define-overloaded (check-latex-export u) (let* ((tm-files (url-append u (url-append (url-any) "*.tm"))) (l (url->list (url-expand (url-complete tm-files "fr"))))) (for (x l) (check-latex-export-one x)))))
   => ((quote check-latex-export) #:synopsis (quote ("Try to export and LaTeX all TeXmacs files inside @u")))
 => cons <> cur-props
   => cur-props => (((quote check-latex-export) #:synopsis (quote ("Try to export and LaTeX all TeXmacs files inside @u"))))

(property-set! var prop what conds*)
  <= (check-latex-export #:synopsis ("Try to export and LaTeX all TeXmacs files inside @u") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Run all regression tests in directory @u.") (tm-define-overloaded (check-all u) (check-latex-export u)))
   => ((quote check-all) #:synopsis (quote ("Run all regression tests in directory @u.")))
 => cons <> cur-props
   => cur-props => (((quote check-all) #:synopsis (quote ("Run all regression tests in directory @u."))))

(property-set! var prop what conds*)
  <= (check-all #:synopsis ("Run all regression tests in directory @u.") ())

  (define-option-argument opt decl)
    <= ((name "Channel") (tm-define-overloaded (make-mirror name) (let* ((l (id->trees name)) (id (create-unique-id))) (if (and (nnull? l) (mirror-body? (car l))) (let* ((doc (tm->stree (car l))) (p (path-start doc (quote ())))) (insert-go-to (quasiquote (mirror (unquote id) (unquote name) (unquote doc))) (cons 2 p))) (insert-go-to (quasiquote (mirror (unquote id) (unquote name) "")) (list 2 0))))))
    => cons <> cur-props <= ((quote make-mirror) #:arguments (quote (name)))
    => cons <> cur-props <= ((quote make-mirror) (quote (#:argument name)) (quote ("Channel")))
    => cur-props => (((quote make-mirror) (quote (#:argument name)) (quote ("Channel"))) ((quote make-mirror) #:arguments (quote (name))))

(property-set! var prop what conds*)
  <= (make-mirror (#:argument name) ("Channel") ())

(property-set! var prop what conds*)
  <= (make-mirror #:arguments (name) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (mirror-initialize t) (when (mirror-body? t) (with key (cons (mirror-id t) (mirror-unique-id t)) (when (not (ahash-ref mirror-initialized key)) (when (not (mirror-up-to-date? t)) (mirror-invalidate t)) (ahash-set! mirror-initialized key #t)) (when (>= (length (id->trees (mirror-unique-id t))) 2) (mirror-invalidate t))))))
    => ((quote mirror-initialize) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote mirror-initialize) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (mirror-initialize #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (mirror-notify event t mod) (when (and mirror-idle? (== event (quote announce)) (!= (modification-type mod) (quote set-cursor)) (mirror-body? t)) (and-with p (tree-up t) (when (tree-func? p (quote shared)) (buffer-initialize-shared (mirror-id p)) (buffer-notify-shared (mirror-id p) mod))) (with l (mirror-list t) (mirror-list-notify l mod)))))
    => ((quote mirror-notify) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote mirror-notify) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (mirror-notify #:secure (#t) ())

  (define-option-require opt decl)
    <= (((url-rooted-tmfs-protocol? (current-buffer) "part")) (tm-define-overloaded (document-part-menu) (menu-dynamic (let* ((name (part-open-name (current-buffer))) (m (part-master name)) (f (part-file name)) (t (tree-import m "texmacs")) (b (tmfile-get t (quote body))) (l (tm-get-includes b))) ((eval (url->string (url-tail m))) (load-buffer m)) --- (for (incl l) ((eval incl) (goto-include m incl)))))))
    => (define-option-match opt decl) <= ((lambda () (url-rooted-tmfs-protocol? (current-buffer) "part")) (tm-define-overloaded (document-part-menu) (menu-dynamic (let* ((name (part-open-name (current-buffer))) (m (part-master name)) (f (part-file name)) (t (tree-import m "texmacs")) (b (tmfile-get t (quote body))) (l (tm-get-includes b))) ((eval (url->string (url-tail m))) (load-buffer m)) --- (for (incl l) ((eval incl) (goto-include m incl)))))))

  (define-option-argument opt decl)
    <= ((type "Entry type") (tm-define-overloaded (make-db-entry type) (with doc (outer-document (cursor-tree)) (when doc (let* ((i (tree-index (tree-down doc))) (id (with-database (user-database) (db-create-id))) (date (number->string (current-time))) (res (quasiquote (db-entry (unquote id) (unquote type) "" (document (db-field "contributor" (unquote (get-default-user))) (db-field "modus" "manual") (db-field "date" (unquote date))) (document))))) (tree-insert! doc (+ i 1) (list res)) (tree-go-to doc (+ i 1) 2 #:start) (db-complete-fields (tree-ref doc (+ i 1)) #t))))))
    => cons <> cur-props <= ((quote make-db-entry) #:arguments (quote (type)))
    => cons <> cur-props <= ((quote make-db-entry) (quote (#:argument type)) (quote ("Entry type")))
    => cur-props => (((quote make-db-entry) (quote (#:argument type)) (quote ("Entry type"))) ((quote make-db-entry) #:arguments (quote (type))))

(property-set! var prop what conds*)
  <= (make-db-entry (#:argument type) ("Entry type") ())

(property-set! var prop what conds*)
  <= (make-db-entry #:arguments (type) ())

  (define-option-proposals opt decl)
    <= ((attr (db-field-possible-attributes)) (tm-define-overloaded (make-db-field-before attr) (make-db-field attr 0)))
    => cons <> cur-props <= ((quote make-db-field-before) (quote (#:proposals attr)) (lambda () (db-field-possible-attributes)))
    => cur-props => (((quote make-db-field-before) (quote (#:proposals attr)) (lambda () (db-field-possible-attributes))))

  (define-option-argument opt decl)
    <= ((attr "Field attribute") (tm-define-overloaded (make-db-field-before attr) (make-db-field attr 0)))
    => cons <> cur-props <= ((quote make-db-field-before) #:arguments (quote (attr)))
    => cons <> cur-props <= ((quote make-db-field-before) (quote (#:argument attr)) (quote ("Field attribute")))
    => cur-props => (((quote make-db-field-before) (quote (#:argument attr)) (quote ("Field attribute"))) ((quote make-db-field-before) #:arguments (quote (attr))) ((quote make-db-field-before) (quote (#:proposals attr)) (lambda () (db-field-possible-attributes))))

(property-set! var prop what conds*)
  <= (make-db-field-before (#:argument attr) ("Field attribute") ())

(property-set! var prop what conds*)
  <= (make-db-field-before #:arguments (attr) ())

(property-set! var prop what conds*)
  <= (make-db-field-before (#:proposals attr) #<procedure #f ()> ())

  (define-option-proposals opt decl)
    <= ((attr (db-field-possible-attributes)) (tm-define-overloaded (make-db-field-after attr) (make-db-field attr 1)))
    => cons <> cur-props <= ((quote make-db-field-after) (quote (#:proposals attr)) (lambda () (db-field-possible-attributes)))
    => cur-props => (((quote make-db-field-after) (quote (#:proposals attr)) (lambda () (db-field-possible-attributes))))

  (define-option-argument opt decl)
    <= ((attr "Field attribute") (tm-define-overloaded (make-db-field-after attr) (make-db-field attr 1)))
    => cons <> cur-props <= ((quote make-db-field-after) #:arguments (quote (attr)))
    => cons <> cur-props <= ((quote make-db-field-after) (quote (#:argument attr)) (quote ("Field attribute")))
    => cur-props => (((quote make-db-field-after) (quote (#:argument attr)) (quote ("Field attribute"))) ((quote make-db-field-after) #:arguments (quote (attr))) ((quote make-db-field-after) (quote (#:proposals attr)) (lambda () (db-field-possible-attributes))))

(property-set! var prop what conds*)
  <= (make-db-field-after (#:argument attr) ("Field attribute") ())

(property-set! var prop what conds*)
  <= (make-db-field-after #:arguments (attr) ())

(property-set! var prop what conds*)
  <= (make-db-field-after (#:proposals attr) #<procedure #f ()> ())

  (define-option-require opt decl)
    <= (((db-entry? t)) (tm-define-overloaded (kbd-enter t shift?) (with u (tree-ref t #:down) (cond ((tree-search-upwards t (quote inactive)) (former t shift?)) ((and u (= (tree-index u) 2)) (if (tree-empty? u) (set-message "Error: should fill out name for referencing" "db-entry") (with d (tree-ref u #:up #:last) (when (and (> (tm-arity d) 0) (db-field-any? (tree-ref d 0))) (tree-go-to d 0 1 #:end))))) (else (keep-completing t #t))))))
    => (define-option-match opt decl) <= ((lambda (t shift?) (db-entry? t)) (tm-define-overloaded (kbd-enter t shift?) (with u (tree-ref t #:down) (cond ((tree-search-upwards t (quote inactive)) (former t shift?)) ((and u (= (tree-index u) 2)) (if (tree-empty? u) (set-message "Error: should fill out name for referencing" "db-entry") (with d (tree-ref u #:up #:last) (when (and (> (tm-arity d) 0) (db-field-any? (tree-ref d 0))) (tree-go-to d 0 1 #:end))))) (else (keep-completing t #t))))))

  (define-option-require opt decl)
    <= (((db-field? t)) (tm-define-overloaded (kbd-enter t shift?) (cond ((tree-empty? (tree-ref t 1)) (set-message "Error: should fill out required field" "db-field")) ((db-next-field t) (tree-go-to (db-next-field t) 1 #:end)) (else (keep-completing t #t)))))
    => (define-option-match opt decl) <= ((lambda (t shift?) (db-field? t)) (tm-define-overloaded (kbd-enter t shift?) (cond ((tree-empty? (tree-ref t 1)) (set-message "Error: should fill out required field" "db-field")) ((db-next-field t) (tree-go-to (db-next-field t) 1 #:end)) (else (keep-completing t #t)))))

  (define-option-require opt decl)
    <= (((db-field-optional? t)) (tm-define-overloaded (kbd-enter t shift?) (if (tree-empty? (tree-ref t 1)) (let* ((u t) (next (db-next-field t)) (prev (db-previous-field t))) (when (or next prev) (tree-go-to (or next prev) 1 #:end) (tree-remove (tree-ref u #:up) (tree-index u) 1))) (with next (db-next-field t) (tree-assign-node t (quote db-field)) (if next (tree-go-to next 1 #:end))))))
    => (define-option-match opt decl) <= ((lambda (t shift?) (db-field-optional? t)) (tm-define-overloaded (kbd-enter t shift?) (if (tree-empty? (tree-ref t 1)) (let* ((u t) (next (db-next-field t)) (prev (db-previous-field t))) (when (or next prev) (tree-go-to (or next prev) 1 #:end) (tree-remove (tree-ref u #:up) (tree-index u) 1))) (with next (db-next-field t) (tree-assign-node t (quote db-field)) (if next (tree-go-to next 1 #:end))))))

  (define-option-require opt decl)
    <= (((db-field-alternative? t)) (tm-define-overloaded (kbd-enter t shift?) (let* ((alts (or (db-alternative-fields t) (list))) (pred? (lambda (f) (not (tree-empty? (tree-ref f 1))))) (ok (list-filter alts pred?))) (cond ((null? ok) (set-message "Error: one of the alternatives should be filled out" "db-field-alternative")) ((> (length ok) 1) (set-message "Error: only one alternatives should be filled out" "db-field-alternative")) (else (with a (car ok) (tree-go-to a 1 #:end) (tree-assign-node! a (quote db-field)) (for (f alts) (when (db-field-alternative? f) (tree-remove (tree-ref f #:up) (tree-index f) 1))) (with next (db-next-field a) (if next (tree-go-to next 1 #:end)))))))))
    => (define-option-match opt decl) <= ((lambda (t shift?) (db-field-alternative? t)) (tm-define-overloaded (kbd-enter t shift?) (let* ((alts (or (db-alternative-fields t) (list))) (pred? (lambda (f) (not (tree-empty? (tree-ref f 1))))) (ok (list-filter alts pred?))) (cond ((null? ok) (set-message "Error: one of the alternatives should be filled out" "db-field-alternative")) ((> (length ok) 1) (set-message "Error: only one alternatives should be filled out" "db-field-alternative")) (else (with a (car ok) (tree-go-to a 1 #:end) (tree-assign-node! a (quote db-field)) (for (f alts) (when (db-field-alternative? f) (tree-remove (tree-ref f #:up) (tree-index f) 1))) (with next (db-next-field a) (if next (tree-go-to next 1 #:end)))))))))

  (define-option-require opt decl)
    <= (((db-entry-any? t)) (tm-define-overloaded (kbd-alternate-enter t shift?) (keep-completing t #f)))
    => (define-option-match opt decl) <= ((lambda (t shift?) (db-entry-any? t)) (tm-define-overloaded (kbd-alternate-enter t shift?) (keep-completing t #f)))

  (define-option-require opt decl)
    <= (((and (in-database?) (pair? (selected-entries)))) (tm-define-overloaded (kbd-alternate-enter t shift?) (when (db-url? (current-buffer)) (confirm-entries (selected-entries)))))
    => (define-option-match opt decl) <= ((lambda (t shift?) (and (in-database?) (pair? (selected-entries)))) (tm-define-overloaded (kbd-alternate-enter t shift?) (when (db-url? (current-buffer)) (confirm-entries (selected-entries)))))

  (define-option-require opt decl)
    <= (((and (db-entry? t) (not (selection-active-any?)))) (tm-define-overloaded (kbd-remove t forwards?) (cond ((and (cursor-inside? (tree-ref t 2)) (tree-empty? (tree-ref t 2)) (tree-empty? (tree-ref t #:last))) (tree-cut t)) ((and (tree-at-start? (tree-ref t 2)) (not forwards?)) (tree-go-to t #:start)) ((and (tree-at-end? (tree-ref t 2)) forwards?) (with f (db-first-field t #f) (if f (tree-go-to f #:start) (tree-go-to t #:end)))) ((cursor-inside? (tree-ref t 2)) (former t forwards?)) ((and (tree-at-start? (tree-ref t #:last)) (not forwards?)) (tree-go-to t 2 #:end)) ((and (not (db-field-any? (cursor-tree))) (with-innermost u db-field-any? u)) (former t forwards?)) ((not forwards?) (kbd-left)) (forwards? (kbd-right)))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (and (db-entry? t) (not (selection-active-any?)))) (tm-define-overloaded (kbd-remove t forwards?) (cond ((and (cursor-inside? (tree-ref t 2)) (tree-empty? (tree-ref t 2)) (tree-empty? (tree-ref t #:last))) (tree-cut t)) ((and (tree-at-start? (tree-ref t 2)) (not forwards?)) (tree-go-to t #:start)) ((and (tree-at-end? (tree-ref t 2)) forwards?) (with f (db-first-field t #f) (if f (tree-go-to f #:start) (tree-go-to t #:end)))) ((cursor-inside? (tree-ref t 2)) (former t forwards?)) ((and (tree-at-start? (tree-ref t #:last)) (not forwards?)) (tree-go-to t 2 #:end)) ((and (not (db-field-any? (cursor-tree))) (with-innermost u db-field-any? u)) (former t forwards?)) ((not forwards?) (kbd-left)) (forwards? (kbd-right)))))

  (define-option-require opt decl)
    <= (((and (db-field-any? t) (not (selection-active-any?)))) (tm-define-overloaded (kbd-remove t forwards?) (cond ((and (cursor-inside? (tree-ref t 1)) (tree-empty? (tree-ref t 1))) (let* ((next (if forwards? (db-next-field t) (db-previous-field t))) (res (tree-search-upwards t (quote db-entry)))) (cond (next (tree-go-to next 1 (if forwards? #:start #:end))) ((and (not forwards?) res) (tree-go-to res 2 #:end)) ((and forwards? res) (tree-go-to res 1))) (tree-remove (tree-up t) (tree-index t) 1))) ((and (tree-at-start? (tree-ref t 1)) (not forwards?)) (tree-go-to t #:start)) ((and (tree-at-end? (tree-ref t 1)) forwards?) (tree-go-to t #:end)) (else (former t forwards?)))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (and (db-field-any? t) (not (selection-active-any?)))) (tm-define-overloaded (kbd-remove t forwards?) (cond ((and (cursor-inside? (tree-ref t 1)) (tree-empty? (tree-ref t 1))) (let* ((next (if forwards? (db-next-field t) (db-previous-field t))) (res (tree-search-upwards t (quote db-entry)))) (cond (next (tree-go-to next 1 (if forwards? #:start #:end))) ((and (not forwards?) res) (tree-go-to res 2 #:end)) ((and forwards? res) (tree-go-to res 1))) (tree-remove (tree-up t) (tree-index t) 1))) ((and (tree-at-start? (tree-ref t 1)) (not forwards?)) (tree-go-to t #:start)) ((and (tree-at-end? (tree-ref t 1)) forwards?) (tree-go-to t #:end)) (else (former t forwards?)))))

  (define-option-require opt decl)
    <= (((db-entry-any? t)) (tm-define-overloaded (structured-remove-horizontal t forwards?) (remove-entry t) (tree-select t) (clipboard-cut "nowhere") (adjust-cursor forwards?)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (db-entry-any? t)) (tm-define-overloaded (structured-remove-horizontal t forwards?) (remove-entry t) (tree-select t) (clipboard-cut "nowhere") (adjust-cursor forwards?)))

  (define-option-require opt decl)
    <= (((and (in-database?) (pair? (selected-entries)))) (tm-define-overloaded (structured-remove-horizontal t forwards?) (remove-entries (selected-entries)) (clipboard-cut "nowhere") (adjust-cursor forwards?)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (and (in-database?) (pair? (selected-entries)))) (tm-define-overloaded (structured-remove-horizontal t forwards?) (remove-entries (selected-entries)) (clipboard-cut "nowhere") (adjust-cursor forwards?)))

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (db-import-select) (noop)))
    => ((quote db-import-select) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote db-import-select) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (db-import-select #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (db-export-select) (noop)))
    => ((quote db-export-select) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote db-export-select) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (db-export-select #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (db-confirm-result t) (when (tm-atomic? t) (db-quit-search (tm->string t)))))
    => ((quote db-confirm-result) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote db-confirm-result) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (db-confirm-result #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (open-identities) (set! adding-user? #f) (top-window db-identities-widget "Specify user identity")))
    => ((quote open-identities) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-identities) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-identities #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (open-db-chooser db kind name call-back) (db-reset) (set! db-search-cache (make-ahash-table)) (set! db-result-cache (make-ahash-table)) (dialogue-window (db-search-widget db kind) (lambda args (set! db-quit-search ignore) (apply call-back args)) name (db-search-results-buffer))))
    => ((quote open-db-chooser) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-db-chooser) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-db-chooser #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (open-db-preferences) (top-window db-preferences-widget "TeXmacs database preferences")))
    => ((quote open-db-preferences) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-db-preferences) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-db-preferences #:interactive (#t) ())

  (define-option-mode opt decl)
    <= ((in-database?) (tm-define-overloaded (insert-menu) (menu-dynamic (if (db-get-types) (=> "Database entry" (link insert-entry-menu))) (if (not (db-get-types)) ("Database entry" (interactive make-db-entry))) (when (and (with-database-tool?) (not (db-url? (current-buffer)))) (if (not (selection-active-any?)) (when (tree-innermost db-entry-any?) ("Import entry" (db-import-this-entry)))) (if (selection-active-any?) ("Import selected entries" (db-import-selection)))) (link db-extra-menu) (if (or (in-text?) (in-math?)) ---) (if (in-text?) (link text-inline-menu)) (if (in-math?) (link math-insert-menu)) --- (link texmacs-insert-menu))))
    (ctx-add-condition! 0 (car opt)) => cur-conds => (in-database?)

  (define-option-mode opt decl)
    <= ((in-database?) (tm-define-overloaded (texmacs-mode-icons) (menu-dynamic (link db-insert-icons) (if (or (in-text?) (in-math?) (in-prog?)) /) (if (in-text?) (link text-inline-icons)) (if (in-math?) (link math-insert-icons)) (if (in-prog?) (link prog-format-icons)) (link texmacs-insert-icons))))
    (ctx-add-condition! 0 (car opt)) => cur-conds => (in-database?)

  (define-option-require opt decl)
    <= (((tree-is? t (quote db-entry))) (tm-define-overloaded (alternate-second-icon t) "tm_alternate_both.xpm"))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote db-entry))) (tm-define-overloaded (alternate-second-icon t) "tm_alternate_both.xpm"))

  (define-option-require opt decl)
    <= (((or (db-entry? t) (db-field? t))) (tm-define-overloaded (focus-can-insert-remove? t) #t))
    => (define-option-match opt decl) <= ((lambda (t) (or (db-entry? t) (db-field? t))) (tm-define-overloaded (focus-can-insert-remove? t) #t))

  (define-option-require opt decl)
    <= (((or (db-entry? t) (db-field? t))) (tm-define-overloaded (focus-insert-menu t) (menu-dynamic (when (db-field? t) (-> "Insert above" (dynamic (focus-insert-field-menu t make-db-field-before)))) (-> "Insert below" (dynamic (focus-insert-field-menu t make-db-field-after))) (when (db-field? t) ("Remove upwards" (remove-db-field #f)) ("Remove downwards" (remove-db-field #t))))))
    => (define-option-match opt decl) <= ((lambda (t) (or (db-entry? t) (db-field? t))) (tm-define-overloaded (focus-insert-menu t) (menu-dynamic (when (db-field? t) (-> "Insert above" (dynamic (focus-insert-field-menu t make-db-field-before)))) (-> "Insert below" (dynamic (focus-insert-field-menu t make-db-field-after))) (when (db-field? t) ("Remove upwards" (remove-db-field #f)) ("Remove downwards" (remove-db-field #t))))))

  (define-option-require opt decl)
    <= (((or (db-entry? t) (db-field? t))) (tm-define-overloaded (focus-insert-icons t) (menu-dynamic (when (db-field? t) (=> (balloon (icon "tm_insert_up.xpm") "Structured insert above") (dynamic (focus-insert-field-menu t make-db-field-before)))) (=> (balloon (icon "tm_insert_down.xpm") "Structured insert below") (dynamic (focus-insert-field-menu t make-db-field-after))) (when (db-field? t) ((balloon (icon "tm_delete_up.xpm") "Structured remove upwards") (remove-db-field #f)) ((balloon (icon "tm_delete_down.xpm") "Structured remove downwards") (remove-db-field #t))))))
    => (define-option-match opt decl) <= ((lambda (t) (or (db-entry? t) (db-field? t))) (tm-define-overloaded (focus-insert-icons t) (menu-dynamic (when (db-field? t) (=> (balloon (icon "tm_insert_up.xpm") "Structured insert above") (dynamic (focus-insert-field-menu t make-db-field-before)))) (=> (balloon (icon "tm_insert_down.xpm") "Structured insert below") (dynamic (focus-insert-field-menu t make-db-field-after))) (when (db-field? t) ((balloon (icon "tm_delete_up.xpm") "Structured remove upwards") (remove-db-field #f)) ((balloon (icon "tm_delete_down.xpm") "Structured remove downwards") (remove-db-field #t))))))

  (define-option-require opt decl)
    <= (((and (== kind "bib") (== fm #:pretty))) (tm-define-overloaded (db-pretty l kind fm) (let* ((bib (map db->bib l)) (doc (quasiquote (document (unquote-splicing bib)))) (gen (bib-generate "bib" "siam" doc))) (when (tm-func? gen (quote bib-list)) (set! gen (tm-ref gen #:last))) (with r (if (tm-func? gen (quote document)) (tm-children gen) (list gen)) (map rewrite-bibitem r)))))
    => (define-option-match opt decl) <= ((lambda (l kind fm) (and (== kind "bib") (== fm #:pretty))) (tm-define-overloaded (db-pretty l kind fm) (let* ((bib (map db->bib l)) (doc (quasiquote (document (unquote-splicing bib)))) (gen (bib-generate "bib" "siam" doc))) (when (tm-func? gen (quote bib-list)) (set! gen (tm-ref gen #:last))) (with r (if (tm-func? gen (quote document)) (tm-children gen) (list gen)) (map rewrite-bibitem r)))))

  (define-option-require opt decl)
    <= (((bib-importable?)) (tm-define-overloaded (db-importable?) #t))
    => (define-option-match opt decl) <= ((lambda () (bib-importable?)) (tm-define-overloaded (db-importable?) #t))

  (define-option-require opt decl)
    <= (((bib-exportable?)) (tm-define-overloaded (db-exportable?) #t))
    => (define-option-match opt decl) <= ((lambda () (bib-exportable?)) (tm-define-overloaded (db-exportable?) #t))

  (define-option-require opt decl)
    <= (((in-bib?)) (tm-define-overloaded (db-import-file name) (bib-import-bibtex name)))
    => (define-option-match opt decl) <= ((lambda (name) (in-bib?)) (tm-define-overloaded (db-import-file name) (bib-import-bibtex name)))

  (define-option-require opt decl)
    <= (((in-bib?)) (tm-define-overloaded (db-export-file name) (bib-export-bibtex name)))
    => (define-option-match opt decl) <= ((lambda (name) (in-bib?)) (tm-define-overloaded (db-export-file name) (bib-export-bibtex name)))

  (define-option-require opt decl)
    <= (((in-bib?)) (tm-define-overloaded (db-import-select) (choose-file bib-import-bibtex "Import from BibTeX file" "tmbib")))
    => (define-option-match opt decl) <= ((lambda () (in-bib?)) (tm-define-overloaded (db-import-select) (choose-file bib-import-bibtex "Import from BibTeX file" "tmbib")))

  (define-option-require opt decl)
    <= (((bib-exportable?)) (tm-define-overloaded (db-export-select) (choose-file bib-export-bibtex "Export to BibTeX file" "tmbib")))
    => (define-option-match opt decl) <= ((lambda () (bib-exportable?)) (tm-define-overloaded (db-export-select) (choose-file bib-export-bibtex "Export to BibTeX file" "tmbib")))

  (define-option-require opt decl)
    <= (((bib-importable?)) (tm-define-overloaded (db-import-selection) (bib-import-selection)))
    => (define-option-match opt decl) <= ((lambda () (bib-importable?)) (tm-define-overloaded (db-import-selection) (bib-import-selection)))

  (define-option-require opt decl)
    <= (((bib-importable?)) (tm-define-overloaded (db-import-this-entry) (and-with t (tree-innermost db-entry-any?) (bib-import-tree t))))
    => (define-option-match opt decl) <= ((lambda () (bib-importable?)) (tm-define-overloaded (db-import-this-entry) (and-with t (tree-innermost db-entry-any?) (bib-import-tree t))))

  (define-option-require opt decl)
    <= (((bib-importable?)) (tm-define-overloaded (db-import-current-buffer) (bib-import-current-buffer)))
    => (define-option-match opt decl) <= ((lambda () (bib-importable?)) (tm-define-overloaded (db-import-current-buffer) (bib-import-current-buffer)))

  (define-option-mode opt decl)
    <= ((in-bib?) (tm-define-overloaded (db-get-kind) "bib"))
    (ctx-add-condition! 0 (car opt)) => cur-conds => (in-bib?)

  (define-option-mode opt decl)
    <= ((in-bib-names?) (tm-define-overloaded (db-extra-menu) (menu-dynamic --- (-> "Particle" (link bib-von-menu)) ("Last name" (make (quote name))) (-> "Title suffix" (link bib-jr-menu)) ("Extra name" (make (quote name-sep))))))
    (ctx-add-condition! 0 (car opt)) => cur-conds => (in-bib-names?)

  (define-option-mode opt decl)
    <= ((in-bib-names?) (tm-define-overloaded (db-extra-icons) (menu-dynamic / (=> (balloon (icon "tm_von.xpm") "Insert particle") (link bib-von-menu)) ((balloon (icon "tm_name_bis.xpm") "Insert last name") (make (quote name))) (=> (balloon (icon "tm_junior.xpm") "Insert title after name") (link bib-jr-menu)) ((balloon (icon "tm_and.xpm") "Insert more names") (make-name-sep)))))
    (ctx-add-condition! 0 (car opt)) => cur-conds => (in-bib-names?)

  (define-option-require opt decl)
    <= (((and (supports-db?) (bib-cite-context? t))) (tm-define-overloaded (focus-can-search? t) #t))
    => (define-option-match opt decl) <= ((lambda (t) (and (supports-db?) (bib-cite-context? t))) (tm-define-overloaded (focus-can-search? t) #t))

  (define-option-require opt decl)
    <= (((and (supports-db?) (bib-cite-context? t))) (tm-define-overloaded (focus-open-search-tool t) (and-with u (if (tree-func? t (quote cite-detail)) (tree-ref t 0) (tree-down t)) (open-bib-chooser (lambda (key) (when (and (tree->path u) (tree-in? (tree-up u) (quote (cite nocite cite-detail)))) (tree-set! u key)))))))
    => (define-option-match opt decl) <= ((lambda (t) (and (supports-db?) (bib-cite-context? t))) (tm-define-overloaded (focus-open-search-tool t) (and-with u (if (tree-func? t (quote cite-detail)) (tree-ref t 0) (tree-down t)) (open-bib-chooser (lambda (key) (when (and (tree->path u) (tree-in? (tree-up u) (quote (cite nocite cite-detail)))) (tree-set! u key)))))))

  (define-option-require opt decl)
    <= (((and (supports-db?) (bib-cite-context? t))) (tm-define-overloaded (kbd-variant t forwards?) (and-with u (if (tree-func? t (quote cite-detail)) (tree-ref t 0) (tree-down t)) (and-with key (and (tree-atomic? u) (tree->string u)) (with-database (bib-database) (with completions (sort (index-get-name-completions key) string<=?) (if (null? completions) (set-message "No completions" "complete bibliographic reference") (with cs (cons key (map (cut string-drop <> (string-length key)) completions)) (custom-complete (tm->tree (quasiquote (tuple (unquote-splicing cs)))))))))))))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (and (supports-db?) (bib-cite-context? t))) (tm-define-overloaded (kbd-variant t forwards?) (and-with u (if (tree-func? t (quote cite-detail)) (tree-ref t 0) (tree-down t)) (and-with key (and (tree-atomic? u) (tree->string u)) (with-database (bib-database) (with completions (sort (index-get-name-completions key) string<=?) (if (null? completions) (set-message "No completions" "complete bibliographic reference") (with cs (cons key (map (cut string-drop <> (string-length key)) completions)) (custom-complete (tm->tree (quasiquote (tuple (unquote-splicing cs)))))))))))))

  (define-option-require opt decl)
    <= (((and (supports-db?) (bib-cite-context? t))) (tm-define-overloaded (kbd-alternate-variant t forwards?) (focus-open-search-tool t)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (and (supports-db?) (bib-cite-context? t))) (tm-define-overloaded (kbd-alternate-variant t forwards?) (focus-open-search-tool t)))

  (define-option-require opt decl)
    <= (((and (db-field? t) (not shift?) (in? (db-field-attr t) (list "author" "editor")))) (tm-define-overloaded (kbd-enter t shift?) (let* ((old (tm->stree (tm-ref t #:down))) (new (transform-names old))) (if (== new old) (former t shift?) (tree-assign (tm-ref t #:down) new)))))
    => (define-option-match opt decl) <= ((lambda (t shift?) (and (db-field? t) (not shift?) (in? (db-field-attr t) (list "author" "editor")))) (tm-define-overloaded (kbd-enter t shift?) (let* ((old (tm->stree (tm-ref t #:down))) (new (transform-names old))) (if (== new old) (former t shift?) (tree-assign (tm-ref t #:down) new)))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("GnuPG executable") (tm-define-overloaded (gpg-get-executable) gpg-executable))
   => ((quote gpg-get-executable) #:synopsis (quote ("GnuPG executable")))
 => cons <> cur-props
   => cur-props => (((quote gpg-get-executable) #:synopsis (quote ("GnuPG executable"))))

(property-set! var prop what conds*)
  <= (gpg-get-executable #:synopsis ("GnuPG executable") ())

  (define-option-argument opt decl)
    <= ((exe "GnuPG executable") (tm-define-overloaded (gpg-set-executable exe) (when (gpg-valid-executable? exe) (set-preference "gpg executable" exe))))
    => cons <> cur-props <= ((quote gpg-set-executable) #:arguments (quote (exe)))
    => cons <> cur-props <= ((quote gpg-set-executable) (quote (#:argument exe)) (quote ("GnuPG executable")))
    => cur-props => (((quote gpg-set-executable) (quote (#:argument exe)) (quote ("GnuPG executable"))) ((quote gpg-set-executable) #:arguments (quote (exe))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set GnuPG executable") (tm-define-overloaded (gpg-set-executable exe) (when (gpg-valid-executable? exe) (set-preference "gpg executable" exe))))
   => ((quote gpg-set-executable) #:synopsis (quote ("Set GnuPG executable")))
 => cons <> cur-props
   => cur-props => (((quote gpg-set-executable) #:synopsis (quote ("Set GnuPG executable"))) ((quote gpg-set-executable) (quote (#:argument exe)) (quote ("GnuPG executable"))) ((quote gpg-set-executable) #:arguments (quote (exe))))

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (gpg-set-executable exe) (when (gpg-valid-executable? exe) (set-preference "gpg executable" exe))))
    => ((quote gpg-set-executable) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote gpg-set-executable) #:interactive (list #t)) ((quote gpg-set-executable) #:synopsis (quote ("Set GnuPG executable"))) ((quote gpg-set-executable) (quote (#:argument exe)) (quote ("GnuPG executable"))) ((quote gpg-set-executable) #:arguments (quote (exe))))

(property-set! var prop what conds*)
  <= (gpg-set-executable #:interactive (#t) ())

(property-set! var prop what conds*)
  <= (gpg-set-executable #:synopsis ("Set GnuPG executable") ())

(property-set! var prop what conds*)
  <= (gpg-set-executable (#:argument exe) ("GnuPG executable") ())

(property-set! var prop what conds*)
  <= (gpg-set-executable #:arguments (exe) ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Tells if GnuPG is available") (tm-define-overloaded (supports-gpg?) (and (== (get-preference "experimental encryption") "on") (!= gpg-executable "") (url-exists-in-path? gpg-executable) (or (url-exists? (url-append (gpg-homedir) "pubring.gpg")) (gpg-make-homedir)))))
   => ((quote supports-gpg?) #:synopsis (quote ("Tells if GnuPG is available")))
 => cons <> cur-props
   => cur-props => (((quote supports-gpg?) #:synopsis (quote ("Tells if GnuPG is available"))))

(property-set! var prop what conds*)
  <= (supports-gpg? #:synopsis ("Tells if GnuPG is available") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("GnuPG cipher algorithm for passphrase encryption") (tm-define-overloaded (gpg-get-cipher-algorithm) gpg-cipher-algorithm))
   => ((quote gpg-get-cipher-algorithm) #:synopsis (quote ("GnuPG cipher algorithm for passphrase encryption")))
 => cons <> cur-props
   => cur-props => (((quote gpg-get-cipher-algorithm) #:synopsis (quote ("GnuPG cipher algorithm for passphrase encryption"))))

(property-set! var prop what conds*)
  <= (gpg-get-cipher-algorithm #:synopsis ("GnuPG cipher algorithm for passphrase encryption") ())

  (define-option-argument opt decl)
    <= ((val "GnuPG cipher algorithm") (tm-define-overloaded (gpg-set-cipher-algorithm val) (when (member val (list "AES192" "AES256")) (set-preference "gpg cipher algorithm" val))))
    => cons <> cur-props <= ((quote gpg-set-cipher-algorithm) #:arguments (quote (val)))
    => cons <> cur-props <= ((quote gpg-set-cipher-algorithm) (quote (#:argument val)) (quote ("GnuPG cipher algorithm")))
    => cur-props => (((quote gpg-set-cipher-algorithm) (quote (#:argument val)) (quote ("GnuPG cipher algorithm"))) ((quote gpg-set-cipher-algorithm) #:arguments (quote (val))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set GnuPG cipher algorithm for passphrase encryption") (tm-define-overloaded (gpg-set-cipher-algorithm val) (when (member val (list "AES192" "AES256")) (set-preference "gpg cipher algorithm" val))))
   => ((quote gpg-set-cipher-algorithm) #:synopsis (quote ("Set GnuPG cipher algorithm for passphrase encryption")))
 => cons <> cur-props
   => cur-props => (((quote gpg-set-cipher-algorithm) #:synopsis (quote ("Set GnuPG cipher algorithm for passphrase encryption"))) ((quote gpg-set-cipher-algorithm) (quote (#:argument val)) (quote ("GnuPG cipher algorithm"))) ((quote gpg-set-cipher-algorithm) #:arguments (quote (val))))

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (gpg-set-cipher-algorithm val) (when (member val (list "AES192" "AES256")) (set-preference "gpg cipher algorithm" val))))
    => ((quote gpg-set-cipher-algorithm) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote gpg-set-cipher-algorithm) #:interactive (list #t)) ((quote gpg-set-cipher-algorithm) #:synopsis (quote ("Set GnuPG cipher algorithm for passphrase encryption"))) ((quote gpg-set-cipher-algorithm) (quote (#:argument val)) (quote ("GnuPG cipher algorithm"))) ((quote gpg-set-cipher-algorithm) #:arguments (quote (val))))

(property-set! var prop what conds*)
  <= (gpg-set-cipher-algorithm #:interactive (#t) ())

(property-set! var prop what conds*)
  <= (gpg-set-cipher-algorithm #:synopsis ("Set GnuPG cipher algorithm for passphrase encryption") ())

(property-set! var prop what conds*)
  <= (gpg-set-cipher-algorithm (#:argument val) ("GnuPG cipher algorithm") ())

(property-set! var prop what conds*)
  <= (gpg-set-cipher-algorithm #:arguments (val) ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Collect public keys from buffer") (tm-define-overloaded (tm-gpg-collect-public-keys-from-buffer) (let* ((fingerprints (get-new-key-fingerprints-from-buffer)) (ckeys (gpg-get-ahash-table-attachment "gpg")) (keys (make-ahash-table))) (for (f fingerprints) (and-with val (ahash-ref ckeys f) (ahash-set! keys f val))) (gpg-add-collected-public-keys keys))))
   => ((quote tm-gpg-collect-public-keys-from-buffer) #:synopsis (quote ("Collect public keys from buffer")))
 => cons <> cur-props
   => cur-props => (((quote tm-gpg-collect-public-keys-from-buffer) #:synopsis (quote ("Collect public keys from buffer"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tm-gpg-collect-public-keys-from-buffer) (let* ((fingerprints (get-new-key-fingerprints-from-buffer)) (ckeys (gpg-get-ahash-table-attachment "gpg")) (keys (make-ahash-table))) (for (f fingerprints) (and-with val (ahash-ref ckeys f) (ahash-set! keys f val))) (gpg-add-collected-public-keys keys))))
    => ((quote tm-gpg-collect-public-keys-from-buffer) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tm-gpg-collect-public-keys-from-buffer) #:secure (list #t)) ((quote tm-gpg-collect-public-keys-from-buffer) #:synopsis (quote ("Collect public keys from buffer"))))

(property-set! var prop what conds*)
  <= (tm-gpg-collect-public-keys-from-buffer #:secure (#t) ())

(property-set! var prop what conds*)
  <= (tm-gpg-collect-public-keys-from-buffer #:synopsis ("Collect public keys from buffer") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Create a new GnuGP identity") (tm-define-overloaded (gpg-gen-key name email comment passphrase . homedir) (let* ((dir (if (null? homedir) (url-none) (car homedir))) (cmd (gpg-executable-gen-key dir)) (ret (evaluate-system cmd (quote (0)) (list (gpg-gen-key-make-formatted-input name email comment passphrase)) (quote (2 3))))) (if (!= (car ret) "0") (gpg-error cmd (cadr ret) (caddr ret)) #t))))
   => ((quote gpg-gen-key) #:synopsis (quote ("Create a new GnuGP identity")))
 => cons <> cur-props
   => cur-props => (((quote gpg-gen-key) #:synopsis (quote ("Create a new GnuGP identity"))))

(property-set! var prop what conds*)
  <= (gpg-gen-key #:synopsis ("Create a new GnuGP identity") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("GnuPG public keys") (tm-define-overloaded (gpg-public-keys . homedir) (let* ((dir (if (null? homedir) (url-none) (car homedir))) (cmd (gpg-executable-list-public-keys dir)) (ret (evaluate-system cmd (quote ()) (quote ()) (quote (1 2))))) (if (!= (car ret) "0") (begin (gpg-error cmd (cadr ret) (caddr ret)) (quote ())) (let* ((srows (string-decompose (utf8->cork (cadr ret)) "
")) (crows (filter (lambda (x) (!= x "")) srows)) (rows (map gpg-decompose-key-string crows))) (gpg-split-public-key-list rows))))))
   => ((quote gpg-public-keys) #:synopsis (quote ("GnuPG public keys")))
 => cons <> cur-props
   => cur-props => (((quote gpg-public-keys) #:synopsis (quote ("GnuPG public keys"))))

(property-set! var prop what conds*)
  <= (gpg-public-keys #:synopsis ("GnuPG public keys") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("GnuPG secret keys") (tm-define-overloaded (gpg-secret-keys . homedir) (let* ((dir (if (null? homedir) (url-none) (car homedir))) (cmd (gpg-executable-list-secret-keys dir)) (ret (evaluate-system cmd (quote ()) (quote ()) (quote (1 2))))) (if (!= (car ret) "0") (begin (gpg-error cmd (cadr ret) (caddr ret)) (quote ())) (let* ((srows (string-decompose (utf8->cork (cadr ret)) "
")) (crows (filter (lambda (x) (!= x "")) srows)) (rows (map gpg-decompose-key-string crows))) (gpg-split-secret-key-list rows))))))
   => ((quote gpg-secret-keys) #:synopsis (quote ("GnuPG secret keys")))
 => cons <> cur-props
   => cur-props => (((quote gpg-secret-keys) #:synopsis (quote ("GnuPG secret keys"))))

(property-set! var prop what conds*)
  <= (gpg-secret-keys #:synopsis ("GnuPG secret keys") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("List the fingerprints of the public keyring") (tm-define-overloaded (gpg-public-key-fingerprints . homedir) (let* ((dir (if (null? homedir) (url-none) (car homedir))) (keys (gpg-public-keys dir))) (map (lambda (x) (tenth (car (filter gpg-fingerprint-row? x)))) keys))))
   => ((quote gpg-public-key-fingerprints) #:synopsis (quote ("List the fingerprints of the public keyring")))
 => cons <> cur-props
   => cur-props => (((quote gpg-public-key-fingerprints) #:synopsis (quote ("List the fingerprints of the public keyring"))))

(property-set! var prop what conds*)
  <= (gpg-public-key-fingerprints #:synopsis ("List the fingerprints of the public keyring") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Tells if @fpr actually belongs to the public keyring") (tm-define-overloaded (gpg-public-key-fingerprint? fpr . homedir) (with dir (if (null? homedir) (url-none) (car homedir)) (member fpr (gpg-public-key-fingerprints dir)))))
   => ((quote gpg-public-key-fingerprint?) #:synopsis (quote ("Tells if @fpr actually belongs to the public keyring")))
 => cons <> cur-props
   => cur-props => (((quote gpg-public-key-fingerprint?) #:synopsis (quote ("Tells if @fpr actually belongs to the public keyring"))))

(property-set! var prop what conds*)
  <= (gpg-public-key-fingerprint? #:synopsis ("Tells if @fpr actually belongs to the public keyring") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("List the fingerprints of the secret keyring") (tm-define-overloaded (gpg-secret-key-fingerprints . homedir) (let* ((dir (if (null? homedir) (url-none) (car homedir))) (keys (gpg-secret-keys dir))) (map (lambda (x) (tenth (car (filter gpg-fingerprint-row? x)))) keys))))
   => ((quote gpg-secret-key-fingerprints) #:synopsis (quote ("List the fingerprints of the secret keyring")))
 => cons <> cur-props
   => cur-props => (((quote gpg-secret-key-fingerprints) #:synopsis (quote ("List the fingerprints of the secret keyring"))))

(property-set! var prop what conds*)
  <= (gpg-secret-key-fingerprints #:synopsis ("List the fingerprints of the secret keyring") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Tells if @fpr actually belongs to the secret keyring") (tm-define-overloaded (gpg-secret-key-fingerprint? fpr . homedir) (with dir (if (null? homedir) (url-none) (car homedir)) (member fpr (gpg-secret-key-fingerprints dir)))))
   => ((quote gpg-secret-key-fingerprint?) #:synopsis (quote ("Tells if @fpr actually belongs to the secret keyring")))
 => cons <> cur-props
   => cur-props => (((quote gpg-secret-key-fingerprint?) #:synopsis (quote ("Tells if @fpr actually belongs to the secret keyring"))))

(property-set! var prop what conds*)
  <= (gpg-secret-key-fingerprint? #:synopsis ("Tells if @fpr actually belongs to the secret keyring") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Delete GnuPG public key of fingerprint @fingerprint") (tm-define-overloaded (gpg-delete-public-key fingerprint . homedir) (let* ((dir (if (null? homedir) (url-none) (car homedir))) (cmd (gpg-executable-delete-secret-and-public-key fingerprint dir)) (ret (evaluate-system cmd (quote ()) (quote ()) (quote (1 2))))) (or (== (car ret) "0") (gpg-error cmd (cadr ret) (caddr ret))))))
   => ((quote gpg-delete-public-key) #:synopsis (quote ("Delete GnuPG public key of fingerprint @fingerprint")))
 => cons <> cur-props
   => cur-props => (((quote gpg-delete-public-key) #:synopsis (quote ("Delete GnuPG public key of fingerprint @fingerprint"))))

(property-set! var prop what conds*)
  <= (gpg-delete-public-key #:synopsis ("Delete GnuPG public key of fingerprint @fingerprint") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Delete GnuPG secret and public keys of fingerprint @fingerprint") (tm-define-overloaded (gpg-delete-secret-and-public-key fingerprint . homedir) (let* ((dir (if (null? homedir) (url-none) (car homedir))) (cmd (gpg-executable-delete-secret-and-public-key fingerprint dir)) (ret (evaluate-system cmd (quote ()) (quote ()) (quote (1 2))))) (or (== (car ret) "0") (gpg-error cmd (cadr ret) (caddr ret))))))
   => ((quote gpg-delete-secret-and-public-key) #:synopsis (quote ("Delete GnuPG secret and public keys of fingerprint @fingerprint")))
 => cons <> cur-props
   => cur-props => (((quote gpg-delete-secret-and-public-key) #:synopsis (quote ("Delete GnuPG secret and public keys of fingerprint @fingerprint"))))

(property-set! var prop what conds*)
  <= (gpg-delete-secret-and-public-key #:synopsis ("Delete GnuPG secret and public keys of fingerprint @fingerprint") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("GnuPG encrypt string @data for recipient fingerprint list @rcps") (tm-define-overloaded (gpg-encrypt data rcps . homedir) (let* ((dir (if (null? homedir) (url-none) (car homedir))) (rcps-args (map (lambda (x) (string-append "-r " x)) rcps)) (cmd (gpg-executable-encrypt rcps-args dir)) (ret (evaluate-system cmd (quote (0)) (list data) (quote (1 2))))) (if (!= (car ret) "0") (gpg-error cmd (cadr ret) (caddr ret)) (cadr ret)))))
   => ((quote gpg-encrypt) #:synopsis (quote ("GnuPG encrypt string @data for recipient fingerprint list @rcps")))
 => cons <> cur-props
   => cur-props => (((quote gpg-encrypt) #:synopsis (quote ("GnuPG encrypt string @data for recipient fingerprint list @rcps"))))

(property-set! var prop what conds*)
  <= (gpg-encrypt #:synopsis ("GnuPG encrypt string @data for recipient fingerprint list @rcps") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("GnuPG decrypt armored string @data with passphrase @passphrase") (tm-define-overloaded (gpg-decrypt data passphrase . homedir) (let* ((dir (if (null? homedir) (url-none) (car homedir))) (cmd (gpg-executable-decrypt dir)) (ret (evaluate-system cmd (quote (0 -1)) (list data passphrase) (quote (1 2))))) (if (!= (car ret) "0") (gpg-error cmd (cadr ret) (caddr ret)) (cadr ret)))))
   => ((quote gpg-decrypt) #:synopsis (quote ("GnuPG decrypt armored string @data with passphrase @passphrase")))
 => cons <> cur-props
   => cur-props => (((quote gpg-decrypt) #:synopsis (quote ("GnuPG decrypt armored string @data with passphrase @passphrase"))))

(property-set! var prop what conds*)
  <= (gpg-decrypt #:synopsis ("GnuPG decrypt armored string @data with passphrase @passphrase") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Tells if @data can be decrypted with passphrase @passphrase") (tm-define-overloaded (gpg-decryptable? data passphrase . homedir) (let* ((dir (if (null? homedir) (url-none) (car homedir))) (cmd (gpg-executable-decrypt dir)) (ret (evaluate-system cmd (quote (0 -1)) (list data passphrase) (quote (1 2))))) (== (car ret) "0"))))
   => ((quote gpg-decryptable?) #:synopsis (quote ("Tells if @data can be decrypted with passphrase @passphrase")))
 => cons <> cur-props
   => cur-props => (((quote gpg-decryptable?) #:synopsis (quote ("Tells if @data can be decrypted with passphrase @passphrase"))))

(property-set! var prop what conds*)
  <= (gpg-decryptable? #:synopsis ("Tells if @data can be decrypted with passphrase @passphrase") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Tells if passphrase @passphrase is correct for @fingerprint") (tm-define-overloaded (gpg-correct-passphrase? fingerprint passphrase . homedir) (let* ((dir (if (null? homedir) (url-none) (car homedir))) (enc (gpg-encrypt "test" (list fingerprint) dir))) (and enc (gpg-decryptable? enc passphrase dir)))))
   => ((quote gpg-correct-passphrase?) #:synopsis (quote ("Tells if passphrase @passphrase is correct for @fingerprint")))
 => cons <> cur-props
   => cur-props => (((quote gpg-correct-passphrase?) #:synopsis (quote ("Tells if passphrase @passphrase is correct for @fingerprint"))))

(property-set! var prop what conds*)
  <= (gpg-correct-passphrase? #:synopsis ("Tells if passphrase @passphrase is correct for @fingerprint") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Export GnuPG public keys of fingerprint in the given list") (tm-define-overloaded (gpg-export-public-keys fingerprints . homedir) (let* ((dir (if (null? homedir) (url-none) (car homedir))) (fingerprints-args (map (lambda (x) (string-append " " x)) fingerprints)) (cmd (gpg-executable-export-public-keys fingerprints-args dir)) (ret (evaluate-system cmd (quote ()) (quote ()) (quote (1 2))))) (if (!= (car ret) "0") (gpg-error cmd (cadr ret) (caddr ret)) (cadr ret)))))
   => ((quote gpg-export-public-keys) #:synopsis (quote ("Export GnuPG public keys of fingerprint in the given list")))
 => cons <> cur-props
   => cur-props => (((quote gpg-export-public-keys) #:synopsis (quote ("Export GnuPG public keys of fingerprint in the given list"))))

(property-set! var prop what conds*)
  <= (gpg-export-public-keys #:synopsis ("Export GnuPG public keys of fingerprint in the given list") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Export GnuPG secret keys of fingerprint in the given list") (tm-define-overloaded (gpg-export-secret-keys fingerprints . homedir) (let* ((dir (if (null? homedir) (url-none) (car homedir))) (fingerprints-args (map (lambda (x) (string-append " " x)) fingerprints)) (cmd (gpg-executable-export-secret-keys fingerprints-args dir)) (ret (evaluate-system cmd (quote ()) (quote ()) (quote (1 2))))) (if (!= (car ret) "0") (gpg-error cmd (cadr ret) (caddr ret)) (cadr ret)))))
   => ((quote gpg-export-secret-keys) #:synopsis (quote ("Export GnuPG secret keys of fingerprint in the given list")))
 => cons <> cur-props
   => cur-props => (((quote gpg-export-secret-keys) #:synopsis (quote ("Export GnuPG secret keys of fingerprint in the given list"))))

(property-set! var prop what conds*)
  <= (gpg-export-secret-keys #:synopsis ("Export GnuPG secret keys of fingerprint in the given list") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Import GnuPG public keys") (tm-define-overloaded (gpg-import-public-keys s . homedir) (with dir (if (null? homedir) (url-none) (car homedir)) (gpg-import s dir))))
   => ((quote gpg-import-public-keys) #:synopsis (quote ("Import GnuPG public keys")))
 => cons <> cur-props
   => cur-props => (((quote gpg-import-public-keys) #:synopsis (quote ("Import GnuPG public keys"))))

(property-set! var prop what conds*)
  <= (gpg-import-public-keys #:synopsis ("Import GnuPG public keys") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Import GnuPG secret keys") (tm-define-overloaded (gpg-import-secret-keys s . homedir) (with dir (if (null? homedir) (url-none) (car homedir)) (gpg-import s dir))))
   => ((quote gpg-import-secret-keys) #:synopsis (quote ("Import GnuPG secret keys")))
 => cons <> cur-props
   => cur-props => (((quote gpg-import-secret-keys) #:synopsis (quote ("Import GnuPG secret keys"))))

(property-set! var prop what conds*)
  <= (gpg-import-secret-keys #:synopsis ("Import GnuPG secret keys") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Encrypt and save string @s to @url for @fingerprint") (tm-define-overloaded (gpg-string-encrypt-save s url fingerprint . homedir) (let* ((dir (if (null? homedir) (url-none) (car homedir))) (e (gpg-encrypt s (list fingerprint) dir))) (and e (string-save e url)))))
   => ((quote gpg-string-encrypt-save) #:synopsis (quote ("Encrypt and save string @s to @url for @fingerprint")))
 => cons <> cur-props
   => cur-props => (((quote gpg-string-encrypt-save) #:synopsis (quote ("Encrypt and save string @s to @url for @fingerprint"))))

(property-set! var prop what conds*)
  <= (gpg-string-encrypt-save #:synopsis ("Encrypt and save string @s to @url for @fingerprint") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Load and decrypt string from @url with @passphrase") (tm-define-overloaded (gpg-string-load-decrypt url passphrase . homedir) (let* ((dir (if (null? homedir) (url-none) (car homedir))) (s (string-load url))) (and s (gpg-decrypt s passphrase dir)))))
   => ((quote gpg-string-load-decrypt) #:synopsis (quote ("Load and decrypt string from @url with @passphrase")))
 => cons <> cur-props
   => cur-props => (((quote gpg-string-load-decrypt) #:synopsis (quote ("Load and decrypt string from @url with @passphrase"))))

(property-set! var prop what conds*)
  <= (gpg-string-load-decrypt #:synopsis ("Load and decrypt string from @url with @passphrase") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Encrypt and save object @o to @url for @fingerprint") (tm-define-overloaded (gpg-encrypt-save-object url o fingerprint . homedir) (let* ((dir (if (null? homedir) (url-none) (car homedir))) (port (open-output-string))) (pretty-print o port) (with ret (gpg-string-encrypt-save (get-output-string port) url fingerprint dir) (close-output-port port) ret))))
   => ((quote gpg-encrypt-save-object) #:synopsis (quote ("Encrypt and save object @o to @url for @fingerprint")))
 => cons <> cur-props
   => cur-props => (((quote gpg-encrypt-save-object) #:synopsis (quote ("Encrypt and save object @o to @url for @fingerprint"))))

(property-set! var prop what conds*)
  <= (gpg-encrypt-save-object #:synopsis ("Encrypt and save object @o to @url for @fingerprint") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Load and decrypt object from @url with @passphrase") (tm-define-overloaded (gpg-load-decrypt-object url passphrase . homedir) (let* ((dir (if (null? homedir) (url-none) (car homedir))) (d (gpg-string-load-decrypt url passphrase dir))) (and d (let* ((p (open-input-string d)) (e (read p))) (if (eof-object? e) (quote ()) e))))))
   => ((quote gpg-load-decrypt-object) #:synopsis (quote ("Load and decrypt object from @url with @passphrase")))
 => cons <> cur-props
   => cur-props => (((quote gpg-load-decrypt-object) #:synopsis (quote ("Load and decrypt object from @url with @passphrase"))))

(property-set! var prop what conds*)
  <= (gpg-load-decrypt-object #:synopsis ("Load and decrypt object from @url with @passphrase") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("GnuPG encrypt string @data with @passphrase") (tm-define-overloaded (gpg-passphrase-encrypt data passphrase . homedir) (let* ((dir (if (null? homedir) (url-none) (car homedir))) (cmd (gpg-executable-passphrase-encrypt dir)) (ret (evaluate-system cmd (quote (0 -1)) (list data passphrase) (quote (1 2))))) (if (!= (car ret) "0") (gpg-error cmd (cadr ret) (caddr ret)) (cadr ret)))))
   => ((quote gpg-passphrase-encrypt) #:synopsis (quote ("GnuPG encrypt string @data with @passphrase")))
 => cons <> cur-props
   => cur-props => (((quote gpg-passphrase-encrypt) #:synopsis (quote ("GnuPG encrypt string @data with @passphrase"))))

(property-set! var prop what conds*)
  <= (gpg-passphrase-encrypt #:synopsis ("GnuPG encrypt string @data with @passphrase") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("GnuPG decrypt armored string @data with passphrase @passphrase") (tm-define-overloaded (gpg-passphrase-decrypt data passphrase . homedir) (let* ((dir (if (null? homedir) (url-none) (car homedir)))) (gpg-decrypt data passphrase dir))))
   => ((quote gpg-passphrase-decrypt) #:synopsis (quote ("GnuPG decrypt armored string @data with passphrase @passphrase")))
 => cons <> cur-props
   => cur-props => (((quote gpg-passphrase-decrypt) #:synopsis (quote ("GnuPG decrypt armored string @data with passphrase @passphrase"))))

(property-set! var prop what conds*)
  <= (gpg-passphrase-decrypt #:synopsis ("GnuPG decrypt armored string @data with passphrase @passphrase") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Tells if the platform provides a wallet implementation") (tm-define-overloaded (supports-wallet?) (supports-gpg?)))
   => ((quote supports-wallet?) #:synopsis (quote ("Tells if the platform provides a wallet implementation")))
 => cons <> cur-props
   => cur-props => (((quote supports-wallet?) #:synopsis (quote ("Tells if the platform provides a wallet implementation"))))

(property-set! var prop what conds*)
  <= (supports-wallet? #:synopsis ("Tells if the platform provides a wallet implementation") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Tells if wallet has been initialized") (tm-define-overloaded (wallet-initialized?) (gpg-wallet-initialized?)))
   => ((quote wallet-initialized?) #:synopsis (quote ("Tells if wallet has been initialized")))
 => cons <> cur-props
   => cur-props => (((quote wallet-initialized?) #:synopsis (quote ("Tells if wallet has been initialized"))))

(property-set! var prop what conds*)
  <= (wallet-initialized? #:synopsis ("Tells if wallet has been initialized") ())

  (define-option-argument opt decl)
    <= ((passphrase "password" "Wallet passphrase") (tm-define-overloaded (wallet-initialize passphrase) (and (supports-wallet?) (gpg-wallet-initialize passphrase))))
    => cons <> cur-props <= ((quote wallet-initialize) #:arguments (quote (passphrase)))
    => cons <> cur-props <= ((quote wallet-initialize) (quote (#:argument passphrase)) (quote ("password" "Wallet passphrase")))
    => cur-props => (((quote wallet-initialize) (quote (#:argument passphrase)) (quote ("password" "Wallet passphrase"))) ((quote wallet-initialize) #:arguments (quote (passphrase))))

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (wallet-initialize passphrase) (and (supports-wallet?) (gpg-wallet-initialize passphrase))))
    => ((quote wallet-initialize) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote wallet-initialize) #:interactive (list #t)) ((quote wallet-initialize) (quote (#:argument passphrase)) (quote ("password" "Wallet passphrase"))) ((quote wallet-initialize) #:arguments (quote (passphrase))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Initialize a new wallet") (tm-define-overloaded (wallet-initialize passphrase) (and (supports-wallet?) (gpg-wallet-initialize passphrase))))
   => ((quote wallet-initialize) #:synopsis (quote ("Initialize a new wallet")))
 => cons <> cur-props
   => cur-props => (((quote wallet-initialize) #:synopsis (quote ("Initialize a new wallet"))) ((quote wallet-initialize) #:interactive (list #t)) ((quote wallet-initialize) (quote (#:argument passphrase)) (quote ("password" "Wallet passphrase"))) ((quote wallet-initialize) #:arguments (quote (passphrase))))

(property-set! var prop what conds*)
  <= (wallet-initialize #:synopsis ("Initialize a new wallet") ())

(property-set! var prop what conds*)
  <= (wallet-initialize #:interactive (#t) ())

(property-set! var prop what conds*)
  <= (wallet-initialize (#:argument passphrase) ("password" "Wallet passphrase") ())

(property-set! var prop what conds*)
  <= (wallet-initialize #:arguments (passphrase) ())

  (define-option-argument opt decl)
    <= ((new-passphrase "password" "New wallet passphrase") (tm-define-overloaded (wallet-reinitialize old-passphrase new-passphrase) (gpg-wallet-reinitialize old-passphrase new-passphrase)))
    => cons <> cur-props <= ((quote wallet-reinitialize) #:arguments (quote (old-passphrase new-passphrase)))
    => cons <> cur-props <= ((quote wallet-reinitialize) (quote (#:argument new-passphrase)) (quote ("password" "New wallet passphrase")))
    => cur-props => (((quote wallet-reinitialize) (quote (#:argument new-passphrase)) (quote ("password" "New wallet passphrase"))) ((quote wallet-reinitialize) #:arguments (quote (old-passphrase new-passphrase))))

  (define-option-argument opt decl)
    <= ((old-passphrase "password" "Current wallet passphrase") (tm-define-overloaded (wallet-reinitialize old-passphrase new-passphrase) (gpg-wallet-reinitialize old-passphrase new-passphrase)))
    => cons <> cur-props <= ((quote wallet-reinitialize) #:arguments (quote (old-passphrase new-passphrase)))
    => cons <> cur-props <= ((quote wallet-reinitialize) (quote (#:argument old-passphrase)) (quote ("password" "Current wallet passphrase")))
    => cur-props => (((quote wallet-reinitialize) (quote (#:argument old-passphrase)) (quote ("password" "Current wallet passphrase"))) ((quote wallet-reinitialize) #:arguments (quote (old-passphrase new-passphrase))) ((quote wallet-reinitialize) (quote (#:argument new-passphrase)) (quote ("password" "New wallet passphrase"))) ((quote wallet-reinitialize) #:arguments (quote (old-passphrase new-passphrase))))

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (wallet-reinitialize old-passphrase new-passphrase) (gpg-wallet-reinitialize old-passphrase new-passphrase)))
    => ((quote wallet-reinitialize) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote wallet-reinitialize) #:interactive (list #t)) ((quote wallet-reinitialize) (quote (#:argument old-passphrase)) (quote ("password" "Current wallet passphrase"))) ((quote wallet-reinitialize) #:arguments (quote (old-passphrase new-passphrase))) ((quote wallet-reinitialize) (quote (#:argument new-passphrase)) (quote ("password" "New wallet passphrase"))) ((quote wallet-reinitialize) #:arguments (quote (old-passphrase new-passphrase))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Reinitialize wallet") (tm-define-overloaded (wallet-reinitialize old-passphrase new-passphrase) (gpg-wallet-reinitialize old-passphrase new-passphrase)))
   => ((quote wallet-reinitialize) #:synopsis (quote ("Reinitialize wallet")))
 => cons <> cur-props
   => cur-props => (((quote wallet-reinitialize) #:synopsis (quote ("Reinitialize wallet"))) ((quote wallet-reinitialize) #:interactive (list #t)) ((quote wallet-reinitialize) (quote (#:argument old-passphrase)) (quote ("password" "Current wallet passphrase"))) ((quote wallet-reinitialize) #:arguments (quote (old-passphrase new-passphrase))) ((quote wallet-reinitialize) (quote (#:argument new-passphrase)) (quote ("password" "New wallet passphrase"))) ((quote wallet-reinitialize) #:arguments (quote (old-passphrase new-passphrase))))

(property-set! var prop what conds*)
  <= (wallet-reinitialize #:synopsis ("Reinitialize wallet") ())

(property-set! var prop what conds*)
  <= (wallet-reinitialize #:interactive (#t) ())

(property-set! var prop what conds*)
  <= (wallet-reinitialize (#:argument old-passphrase) ("password" "Current wallet passphrase") ())

(property-set! var prop what conds*)
  <= (wallet-reinitialize #:arguments (old-passphrase new-passphrase) ())

(property-set! var prop what conds*)
  <= (wallet-reinitialize (#:argument new-passphrase) ("password" "New wallet passphrase") ())

(property-set! var prop what conds*)
  <= (wallet-reinitialize #:arguments (old-passphrase new-passphrase) ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Destroy wallet") (tm-define-overloaded (wallet-destroy) (gpg-wallet-destroy)))
   => ((quote wallet-destroy) #:synopsis (quote ("Destroy wallet")))
 => cons <> cur-props
   => cur-props => (((quote wallet-destroy) #:synopsis (quote ("Destroy wallet"))))

(property-set! var prop what conds*)
  <= (wallet-destroy #:synopsis ("Destroy wallet") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Tells if wallet is turned on") (tm-define-overloaded (wallet-on?) (gpg-wallet-on?)))
   => ((quote wallet-on?) #:synopsis (quote ("Tells if wallet is turned on")))
 => cons <> cur-props
   => cur-props => (((quote wallet-on?) #:synopsis (quote ("Tells if wallet is turned on"))))

(property-set! var prop what conds*)
  <= (wallet-on? #:synopsis ("Tells if wallet is turned on") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Tells if wallet is turned off") (tm-define-overloaded (wallet-off?) (not (wallet-on?))))
   => ((quote wallet-off?) #:synopsis (quote ("Tells if wallet is turned off")))
 => cons <> cur-props
   => cur-props => (((quote wallet-off?) #:synopsis (quote ("Tells if wallet is turned off"))))

(property-set! var prop what conds*)
  <= (wallet-off? #:synopsis ("Tells if wallet is turned off") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Tells if @passphrase is correct") (tm-define-overloaded (wallet-correct-passphrase? passphrase) (gpg-wallet-correct-passphrase? passphrase)))
   => ((quote wallet-correct-passphrase?) #:synopsis (quote ("Tells if @passphrase is correct")))
 => cons <> cur-props
   => cur-props => (((quote wallet-correct-passphrase?) #:synopsis (quote ("Tells if @passphrase is correct"))))

(property-set! var prop what conds*)
  <= (wallet-correct-passphrase? #:synopsis ("Tells if @passphrase is correct") ())

  (define-option-argument opt decl)
    <= ((passphrase "password" "Wallet passphrase") (tm-define-overloaded (wallet-turn-on passphrase) (gpg-wallet-turn-on passphrase) (set-preference "wallet persistent status" "on")))
    => cons <> cur-props <= ((quote wallet-turn-on) #:arguments (quote (passphrase)))
    => cons <> cur-props <= ((quote wallet-turn-on) (quote (#:argument passphrase)) (quote ("password" "Wallet passphrase")))
    => cur-props => (((quote wallet-turn-on) (quote (#:argument passphrase)) (quote ("password" "Wallet passphrase"))) ((quote wallet-turn-on) #:arguments (quote (passphrase))))

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (wallet-turn-on passphrase) (gpg-wallet-turn-on passphrase) (set-preference "wallet persistent status" "on")))
    => ((quote wallet-turn-on) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote wallet-turn-on) #:interactive (list #t)) ((quote wallet-turn-on) (quote (#:argument passphrase)) (quote ("password" "Wallet passphrase"))) ((quote wallet-turn-on) #:arguments (quote (passphrase))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Turn wallet on using @passphrase") (tm-define-overloaded (wallet-turn-on passphrase) (gpg-wallet-turn-on passphrase) (set-preference "wallet persistent status" "on")))
   => ((quote wallet-turn-on) #:synopsis (quote ("Turn wallet on using @passphrase")))
 => cons <> cur-props
   => cur-props => (((quote wallet-turn-on) #:synopsis (quote ("Turn wallet on using @passphrase"))) ((quote wallet-turn-on) #:interactive (list #t)) ((quote wallet-turn-on) (quote (#:argument passphrase)) (quote ("password" "Wallet passphrase"))) ((quote wallet-turn-on) #:arguments (quote (passphrase))))

(property-set! var prop what conds*)
  <= (wallet-turn-on #:synopsis ("Turn wallet on using @passphrase") ())

(property-set! var prop what conds*)
  <= (wallet-turn-on #:interactive (#t) ())

(property-set! var prop what conds*)
  <= (wallet-turn-on (#:argument passphrase) ("password" "Wallet passphrase") ())

(property-set! var prop what conds*)
  <= (wallet-turn-on #:arguments (passphrase) ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Turn wallet off") (tm-define-overloaded (wallet-turn-off) (gpg-wallet-turn-off) (set-preference "wallet persistent status" "off")))
   => ((quote wallet-turn-off) #:synopsis (quote ("Turn wallet off")))
 => cons <> cur-props
   => cur-props => (((quote wallet-turn-off) #:synopsis (quote ("Turn wallet off"))))

(property-set! var prop what conds*)
  <= (wallet-turn-off #:synopsis ("Turn wallet off") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Insert binding @key ~> @val into wallet") (tm-define-overloaded (wallet-set key val) (gpg-wallet-set key val)))
   => ((quote wallet-set) #:synopsis (quote ("Insert binding @key ~> @val into wallet")))
 => cons <> cur-props
   => cur-props => (((quote wallet-set) #:synopsis (quote ("Insert binding @key ~> @val into wallet"))))

(property-set! var prop what conds*)
  <= (wallet-set #:synopsis ("Insert binding @key ~> @val into wallet") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Get value for @key from the wallet") (tm-define-overloaded (wallet-get key) (gpg-wallet-get key)))
   => ((quote wallet-get) #:synopsis (quote ("Get value for @key from the wallet")))
 => cons <> cur-props
   => cur-props => (((quote wallet-get) #:synopsis (quote ("Get value for @key from the wallet"))))

(property-set! var prop what conds*)
  <= (wallet-get #:synopsis ("Get value for @key from the wallet") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Delete binding for @key in the wallet") (tm-define-overloaded (wallet-delete key) (gpg-wallet-delete key)))
   => ((quote wallet-delete) #:synopsis (quote ("Delete binding for @key in the wallet")))
 => cons <> cur-props
   => cur-props => (((quote wallet-delete) #:synopsis (quote ("Delete binding for @key in the wallet"))))

(property-set! var prop what conds*)
  <= (wallet-delete #:synopsis ("Delete binding for @key in the wallet") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("List all entries of the wallet") (tm-define-overloaded (wallet-entries) (gpg-wallet-entries)))
   => ((quote wallet-entries) #:synopsis (quote ("List all entries of the wallet")))
 => cons <> cur-props
   => cur-props => (((quote wallet-entries) #:synopsis (quote ("List all entries of the wallet"))))

(property-set! var prop what conds*)
  <= (wallet-entries #:synopsis ("List all entries of the wallet") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Get default key fingerprint") (tm-define-overloaded (gpg-get-default-key-fingerprint) (if (or (gpg-secret-key-fingerprint? gpg-default-key-fingerprint) (== gpg-default-key-fingerprint "")) gpg-default-key-fingerprint (begin (set-user-info "gpg-key-fingerprint" "") ""))))
   => ((quote gpg-get-default-key-fingerprint) #:synopsis (quote ("Get default key fingerprint")))
 => cons <> cur-props
   => cur-props => (((quote gpg-get-default-key-fingerprint) #:synopsis (quote ("Get default key fingerprint"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (gpg-get-default-key-fingerprint) (if (or (gpg-secret-key-fingerprint? gpg-default-key-fingerprint) (== gpg-default-key-fingerprint "")) gpg-default-key-fingerprint (begin (set-user-info "gpg-key-fingerprint" "") ""))))
    => ((quote gpg-get-default-key-fingerprint) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote gpg-get-default-key-fingerprint) #:secure (list #t)) ((quote gpg-get-default-key-fingerprint) #:synopsis (quote ("Get default key fingerprint"))))

(property-set! var prop what conds*)
  <= (gpg-get-default-key-fingerprint #:secure (#t) ())

(property-set! var prop what conds*)
  <= (gpg-get-default-key-fingerprint #:synopsis ("Get default key fingerprint") ())

  (define-option-argument opt decl)
    <= ((fingerprint "Key fingerprint") (tm-define-overloaded (gpg-set-default-key-fingerprint fingerprint) (when (or (gpg-secret-key-fingerprint? fingerprint) (== fingerprint "")) (refresh-now "identity-info") (set-preference "gpg default key fingerprint" fingerprint))))
    => cons <> cur-props <= ((quote gpg-set-default-key-fingerprint) #:arguments (quote (fingerprint)))
    => cons <> cur-props <= ((quote gpg-set-default-key-fingerprint) (quote (#:argument fingerprint)) (quote ("Key fingerprint")))
    => cur-props => (((quote gpg-set-default-key-fingerprint) (quote (#:argument fingerprint)) (quote ("Key fingerprint"))) ((quote gpg-set-default-key-fingerprint) #:arguments (quote (fingerprint))))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Set default key fingerprint") (tm-define-overloaded (gpg-set-default-key-fingerprint fingerprint) (when (or (gpg-secret-key-fingerprint? fingerprint) (== fingerprint "")) (refresh-now "identity-info") (set-preference "gpg default key fingerprint" fingerprint))))
   => ((quote gpg-set-default-key-fingerprint) #:synopsis (quote ("Set default key fingerprint")))
 => cons <> cur-props
   => cur-props => (((quote gpg-set-default-key-fingerprint) #:synopsis (quote ("Set default key fingerprint"))) ((quote gpg-set-default-key-fingerprint) (quote (#:argument fingerprint)) (quote ("Key fingerprint"))) ((quote gpg-set-default-key-fingerprint) #:arguments (quote (fingerprint))))

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (gpg-set-default-key-fingerprint fingerprint) (when (or (gpg-secret-key-fingerprint? fingerprint) (== fingerprint "")) (refresh-now "identity-info") (set-preference "gpg default key fingerprint" fingerprint))))
    => ((quote gpg-set-default-key-fingerprint) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote gpg-set-default-key-fingerprint) #:interactive (list #t)) ((quote gpg-set-default-key-fingerprint) #:synopsis (quote ("Set default key fingerprint"))) ((quote gpg-set-default-key-fingerprint) (quote (#:argument fingerprint)) (quote ("Key fingerprint"))) ((quote gpg-set-default-key-fingerprint) #:arguments (quote (fingerprint))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (gpg-set-default-key-fingerprint fingerprint) (when (or (gpg-secret-key-fingerprint? fingerprint) (== fingerprint "")) (refresh-now "identity-info") (set-preference "gpg default key fingerprint" fingerprint))))
    => ((quote gpg-set-default-key-fingerprint) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote gpg-set-default-key-fingerprint) #:secure (list #t)) ((quote gpg-set-default-key-fingerprint) #:interactive (list #t)) ((quote gpg-set-default-key-fingerprint) #:synopsis (quote ("Set default key fingerprint"))) ((quote gpg-set-default-key-fingerprint) (quote (#:argument fingerprint)) (quote ("Key fingerprint"))) ((quote gpg-set-default-key-fingerprint) #:arguments (quote (fingerprint))))

(property-set! var prop what conds*)
  <= (gpg-set-default-key-fingerprint #:secure (#t) ())

(property-set! var prop what conds*)
  <= (gpg-set-default-key-fingerprint #:interactive (#t) ())

(property-set! var prop what conds*)
  <= (gpg-set-default-key-fingerprint #:synopsis ("Set default key fingerprint") ())

(property-set! var prop what conds*)
  <= (gpg-set-default-key-fingerprint (#:argument fingerprint) ("Key fingerprint") ())

(property-set! var prop what conds*)
  <= (gpg-set-default-key-fingerprint #:arguments (fingerprint) ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Generate GnuPG key") (tm-define-overloaded (gpg-dialogue-gen-key . callback) (with cb (if (null? callback) noop (car callback)) (dialogue-window (gpg-widget-gen-key cb) noop "Generate GnuPG key"))))
   => ((quote gpg-dialogue-gen-key) #:synopsis (quote ("Generate GnuPG key")))
 => cons <> cur-props
   => cur-props => (((quote gpg-dialogue-gen-key) #:synopsis (quote ("Generate GnuPG key"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (gpg-dialogue-gen-key . callback) (with cb (if (null? callback) noop (car callback)) (dialogue-window (gpg-widget-gen-key cb) noop "Generate GnuPG key"))))
    => ((quote gpg-dialogue-gen-key) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote gpg-dialogue-gen-key) #:secure (list #t)) ((quote gpg-dialogue-gen-key) #:synopsis (quote ("Generate GnuPG key"))))

(property-set! var prop what conds*)
  <= (gpg-dialogue-gen-key #:secure (#t) ())

(property-set! var prop what conds*)
  <= (gpg-dialogue-gen-key #:synopsis ("Generate GnuPG key") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Interactive GnuPG encryption") (tm-define-overloaded (gpg-dialogue-encrypt data callback) (dialogue-window gpg-widget-select-public-key-fingerprints (lambda (x) (gpg-command-encrypt data callback x)) "Select GnuPG recipients")))
   => ((quote gpg-dialogue-encrypt) #:synopsis (quote ("Interactive GnuPG encryption")))
 => cons <> cur-props
   => cur-props => (((quote gpg-dialogue-encrypt) #:synopsis (quote ("Interactive GnuPG encryption"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (gpg-dialogue-encrypt data callback) (dialogue-window gpg-widget-select-public-key-fingerprints (lambda (x) (gpg-command-encrypt data callback x)) "Select GnuPG recipients")))
    => ((quote gpg-dialogue-encrypt) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote gpg-dialogue-encrypt) #:secure (list #t)) ((quote gpg-dialogue-encrypt) #:synopsis (quote ("Interactive GnuPG encryption"))))

(property-set! var prop what conds*)
  <= (gpg-dialogue-encrypt #:secure (#t) ())

(property-set! var prop what conds*)
  <= (gpg-dialogue-encrypt #:synopsis ("Interactive GnuPG encryption") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Interactive GnuPG decryption") (tm-define-overloaded (gpg-dialogue-decrypt data fingerprint callback) (with-wallet (with passphrase (wallet-get (list "gpg" fingerprint)) (if passphrase (gpg-command-decrypt data callback (list "Ok" passphrase)) (with key (gpg-search-secret-key-by-fingerprint fingerprint) (if key (dialogue-window (gpg-widget-ask-passphrase fingerprint) (lambda (x) (gpg-command-decrypt data callback x)) "Decryption") (dialogue-window (gpg-widget-wrong-fingerprint fingerprint) noop "Decryption"))))))))
   => ((quote gpg-dialogue-decrypt) #:synopsis (quote ("Interactive GnuPG decryption")))
 => cons <> cur-props
   => cur-props => (((quote gpg-dialogue-decrypt) #:synopsis (quote ("Interactive GnuPG decryption"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (gpg-dialogue-decrypt data fingerprint callback) (with-wallet (with passphrase (wallet-get (list "gpg" fingerprint)) (if passphrase (gpg-command-decrypt data callback (list "Ok" passphrase)) (with key (gpg-search-secret-key-by-fingerprint fingerprint) (if key (dialogue-window (gpg-widget-ask-passphrase fingerprint) (lambda (x) (gpg-command-decrypt data callback x)) "Decryption") (dialogue-window (gpg-widget-wrong-fingerprint fingerprint) noop "Decryption"))))))))
    => ((quote gpg-dialogue-decrypt) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote gpg-dialogue-decrypt) #:secure (list #t)) ((quote gpg-dialogue-decrypt) #:synopsis (quote ("Interactive GnuPG decryption"))))

(property-set! var prop what conds*)
  <= (gpg-dialogue-decrypt #:secure (#t) ())

(property-set! var prop what conds*)
  <= (gpg-dialogue-decrypt #:synopsis ("Interactive GnuPG decryption") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Interactive GnuPG passphrase encryption") (tm-define-overloaded (gpg-dialogue-passphrase-encrypt data callback) (dialogue-window gpg-widget-ask-new-passphrase (lambda (x) (gpg-command-passphrase-encrypt data callback x)) "Passphrase encryption")))
   => ((quote gpg-dialogue-passphrase-encrypt) #:synopsis (quote ("Interactive GnuPG passphrase encryption")))
 => cons <> cur-props
   => cur-props => (((quote gpg-dialogue-passphrase-encrypt) #:synopsis (quote ("Interactive GnuPG passphrase encryption"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (gpg-dialogue-passphrase-encrypt data callback) (dialogue-window gpg-widget-ask-new-passphrase (lambda (x) (gpg-command-passphrase-encrypt data callback x)) "Passphrase encryption")))
    => ((quote gpg-dialogue-passphrase-encrypt) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote gpg-dialogue-passphrase-encrypt) #:secure (list #t)) ((quote gpg-dialogue-passphrase-encrypt) #:synopsis (quote ("Interactive GnuPG passphrase encryption"))))

(property-set! var prop what conds*)
  <= (gpg-dialogue-passphrase-encrypt #:secure (#t) ())

(property-set! var prop what conds*)
  <= (gpg-dialogue-passphrase-encrypt #:synopsis ("Interactive GnuPG passphrase encryption") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Interactive GnuPG passphrase decryption") (tm-define-overloaded (gpg-dialogue-passphrase-decrypt data callback) (dialogue-window (gpg-widget-ask-standalone-passphrase (lambda (x) (gpg-decryptable? data x))) (lambda (x) (gpg-command-passphrase-decrypt data callback x)) "Passphrase encryption")))
   => ((quote gpg-dialogue-passphrase-decrypt) #:synopsis (quote ("Interactive GnuPG passphrase decryption")))
 => cons <> cur-props
   => cur-props => (((quote gpg-dialogue-passphrase-decrypt) #:synopsis (quote ("Interactive GnuPG passphrase decryption"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (gpg-dialogue-passphrase-decrypt data callback) (dialogue-window (gpg-widget-ask-standalone-passphrase (lambda (x) (gpg-decryptable? data x))) (lambda (x) (gpg-command-passphrase-decrypt data callback x)) "Passphrase encryption")))
    => ((quote gpg-dialogue-passphrase-decrypt) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote gpg-dialogue-passphrase-decrypt) #:secure (list #t)) ((quote gpg-dialogue-passphrase-decrypt) #:synopsis (quote ("Interactive GnuPG passphrase decryption"))))

(property-set! var prop what conds*)
  <= (gpg-dialogue-passphrase-decrypt #:secure (#t) ())

(property-set! var prop what conds*)
  <= (gpg-dialogue-passphrase-decrypt #:synopsis ("Interactive GnuPG passphrase decryption") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Retrieve user id from fingerprint @t") (tm-define-overloaded (tm-gpg-get-key-user-id t) (with fingerprint (tree->string t) (with l (gpg-get-ahash-ref-attachment "gpg" fingerprint) (if l (string->tree (first l)) t)))))
   => ((quote tm-gpg-get-key-user-id) #:synopsis (quote ("Retrieve user id from fingerprint @t")))
 => cons <> cur-props
   => cur-props => (((quote tm-gpg-get-key-user-id) #:synopsis (quote ("Retrieve user id from fingerprint @t"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tm-gpg-get-key-user-id t) (with fingerprint (tree->string t) (with l (gpg-get-ahash-ref-attachment "gpg" fingerprint) (if l (string->tree (first l)) t)))))
    => ((quote tm-gpg-get-key-user-id) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tm-gpg-get-key-user-id) #:secure (list #t)) ((quote tm-gpg-get-key-user-id) #:synopsis (quote ("Retrieve user id from fingerprint @t"))))

(property-set! var prop what conds*)
  <= (tm-gpg-get-key-user-id #:secure (#t) ())

(property-set! var prop what conds*)
  <= (tm-gpg-get-key-user-id #:synopsis ("Retrieve user id from fingerprint @t") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Retrieve key data from fingerprint @t") (tm-define-overloaded (tm-gpg-get-key-data t) (with fingerprint (tree->string t) (with l (gpg-get-ahash-ref-attachment "gpg" fingerprint) (string->tree (if l (second l) ""))))))
   => ((quote tm-gpg-get-key-data) #:synopsis (quote ("Retrieve key data from fingerprint @t")))
 => cons <> cur-props
   => cur-props => (((quote tm-gpg-get-key-data) #:synopsis (quote ("Retrieve key data from fingerprint @t"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tm-gpg-get-key-data t) (with fingerprint (tree->string t) (with l (gpg-get-ahash-ref-attachment "gpg" fingerprint) (string->tree (if l (second l) ""))))))
    => ((quote tm-gpg-get-key-data) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tm-gpg-get-key-data) #:secure (list #t)) ((quote tm-gpg-get-key-data) #:synopsis (quote ("Retrieve key data from fingerprint @t"))))

(property-set! var prop what conds*)
  <= (tm-gpg-get-key-data #:secure (#t) ())

(property-set! var prop what conds*)
  <= (tm-gpg-get-key-data #:synopsis ("Retrieve key data from fingerprint @t") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Insert GnuPG decrypted block") (tm-define-overloaded (tm-gpg-dialogue-insert-decrypted-block) (with fpr (gpg-get-default-key-fingerprint) (when (!= fpr "") (ahash-set! gpg-widget-selected-public-key-fingerprints fpr #t))) (dialogue-window gpg-widget-select-public-key-fingerprints (lambda (x) (gpg-command-make-gpg-decrypted x #t)) "Select GnuPG recipients")))
   => ((quote tm-gpg-dialogue-insert-decrypted-block) #:synopsis (quote ("Insert GnuPG decrypted block")))
 => cons <> cur-props
   => cur-props => (((quote tm-gpg-dialogue-insert-decrypted-block) #:synopsis (quote ("Insert GnuPG decrypted block"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tm-gpg-dialogue-insert-decrypted-block) (with fpr (gpg-get-default-key-fingerprint) (when (!= fpr "") (ahash-set! gpg-widget-selected-public-key-fingerprints fpr #t))) (dialogue-window gpg-widget-select-public-key-fingerprints (lambda (x) (gpg-command-make-gpg-decrypted x #t)) "Select GnuPG recipients")))
    => ((quote tm-gpg-dialogue-insert-decrypted-block) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tm-gpg-dialogue-insert-decrypted-block) #:secure (list #t)) ((quote tm-gpg-dialogue-insert-decrypted-block) #:synopsis (quote ("Insert GnuPG decrypted block"))))

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-insert-decrypted-block #:secure (#t) ())

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-insert-decrypted-block #:synopsis ("Insert GnuPG decrypted block") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Insert inline GnuPG decrypted region") (tm-define-overloaded (tm-gpg-dialogue-insert-decrypted) (with fpr (gpg-get-default-key-fingerprint) (when (!= fpr "") (ahash-set! gpg-widget-selected-public-key-fingerprints fpr #t))) (dialogue-window gpg-widget-select-public-key-fingerprints (lambda (x) (gpg-command-make-gpg-decrypted x #f)) "Select GnuPG recipients")))
   => ((quote tm-gpg-dialogue-insert-decrypted) #:synopsis (quote ("Insert inline GnuPG decrypted region")))
 => cons <> cur-props
   => cur-props => (((quote tm-gpg-dialogue-insert-decrypted) #:synopsis (quote ("Insert inline GnuPG decrypted region"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tm-gpg-dialogue-insert-decrypted) (with fpr (gpg-get-default-key-fingerprint) (when (!= fpr "") (ahash-set! gpg-widget-selected-public-key-fingerprints fpr #t))) (dialogue-window gpg-widget-select-public-key-fingerprints (lambda (x) (gpg-command-make-gpg-decrypted x #f)) "Select GnuPG recipients")))
    => ((quote tm-gpg-dialogue-insert-decrypted) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tm-gpg-dialogue-insert-decrypted) #:secure (list #t)) ((quote tm-gpg-dialogue-insert-decrypted) #:synopsis (quote ("Insert inline GnuPG decrypted region"))))

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-insert-decrypted #:secure (#t) ())

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-insert-decrypted #:synopsis ("Insert inline GnuPG decrypted region") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Edit list of recipients") (tm-define-overloaded (tm-gpg-dialogue-replace-decrypted t) (let* ((block? (symbol-ends? (tree-label t) (quote -block))) (fingerprints (map tree->string (cdr (tree-children t))))) (set! gpg-widget-selected-public-key-fingerprints (make-ahash-table)) (for (fpr fingerprints) (ahash-set! gpg-widget-selected-public-key-fingerprints fpr #t)) (dialogue-window gpg-widget-select-public-key-fingerprints (lambda (x) (tm-gpg-command-replace-gpg-decrypted t x block?)) "Select GnuPG recipients"))))
   => ((quote tm-gpg-dialogue-replace-decrypted) #:synopsis (quote ("Edit list of recipients")))
 => cons <> cur-props
   => cur-props => (((quote tm-gpg-dialogue-replace-decrypted) #:synopsis (quote ("Edit list of recipients"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  () (tm-define-overloaded (tm-gpg-dialogue-replace-decrypted t) (let* ((block? (symbol-ends? (tree-label t) (quote -block))) (fingerprints (map tree->string (cdr (tree-children t))))) (set! gpg-widget-selected-public-key-fingerprints (make-ahash-table)) (for (fpr fingerprints) (ahash-set! gpg-widget-selected-public-key-fingerprints fpr #t)) (dialogue-window gpg-widget-select-public-key-fingerprints (lambda (x) (tm-gpg-command-replace-gpg-decrypted t x block?)) "Select GnuPG recipients"))))
    => ((quote tm-gpg-dialogue-replace-decrypted) #:secure (list))
 => cons <> cur-props
    => cur-props => (((quote tm-gpg-dialogue-replace-decrypted) #:secure (list)) ((quote tm-gpg-dialogue-replace-decrypted) #:synopsis (quote ("Edit list of recipients"))))

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-replace-decrypted #:secure () ())

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-replace-decrypted #:synopsis ("Edit list of recipients") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Insert GnuPG passphrase decrypted block") (tm-define-overloaded (tm-gpg-insert-passphrase-decrypted-block) (make (quasiquote gpg-passphrase-decrypted-block))))
   => ((quote tm-gpg-insert-passphrase-decrypted-block) #:synopsis (quote ("Insert GnuPG passphrase decrypted block")))
 => cons <> cur-props
   => cur-props => (((quote tm-gpg-insert-passphrase-decrypted-block) #:synopsis (quote ("Insert GnuPG passphrase decrypted block"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tm-gpg-insert-passphrase-decrypted-block) (make (quasiquote gpg-passphrase-decrypted-block))))
    => ((quote tm-gpg-insert-passphrase-decrypted-block) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tm-gpg-insert-passphrase-decrypted-block) #:secure (list #t)) ((quote tm-gpg-insert-passphrase-decrypted-block) #:synopsis (quote ("Insert GnuPG passphrase decrypted block"))))

(property-set! var prop what conds*)
  <= (tm-gpg-insert-passphrase-decrypted-block #:secure (#t) ())

(property-set! var prop what conds*)
  <= (tm-gpg-insert-passphrase-decrypted-block #:synopsis ("Insert GnuPG passphrase decrypted block") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Insert inline GnuPG passphrase decrypted region") (tm-define-overloaded (tm-gpg-insert-passphrase-decrypted) (make (quasiquote gpg-passphrase-decrypted))))
   => ((quote tm-gpg-insert-passphrase-decrypted) #:synopsis (quote ("Insert inline GnuPG passphrase decrypted region")))
 => cons <> cur-props
   => cur-props => (((quote tm-gpg-insert-passphrase-decrypted) #:synopsis (quote ("Insert inline GnuPG passphrase decrypted region"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tm-gpg-insert-passphrase-decrypted) (make (quasiquote gpg-passphrase-decrypted))))
    => ((quote tm-gpg-insert-passphrase-decrypted) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tm-gpg-insert-passphrase-decrypted) #:secure (list #t)) ((quote tm-gpg-insert-passphrase-decrypted) #:synopsis (quote ("Insert inline GnuPG passphrase decrypted region"))))

(property-set! var prop what conds*)
  <= (tm-gpg-insert-passphrase-decrypted #:secure (#t) ())

(property-set! var prop what conds*)
  <= (tm-gpg-insert-passphrase-decrypted #:synopsis ("Insert inline GnuPG passphrase decrypted region") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Encrypt @t") (tm-define-overloaded (tm-gpg-encrypt t) (let* ((block? (symbol-ends? (tree-label t) (quote -block))) (newtag (if block? (quote gpg-encrypted-block) (quote gpg-encrypted))) (data (serialize-texmacs (tree-ref t 0))) (fingerprints (cdr (tree-children t)))) (and-with enc (gpg-encrypt data (map tree->string fingerprints)) (tree-set! t (quasiquote ((unquote newtag) (unquote enc) (unquote-splicing (cdr (tree-children t)))))) (tree-go-to t #:end) (autosave-buffer (current-buffer))))))
   => ((quote tm-gpg-encrypt) #:synopsis (quote ("Encrypt @t")))
 => cons <> cur-props
   => cur-props => (((quote tm-gpg-encrypt) #:synopsis (quote ("Encrypt @t"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tm-gpg-encrypt t) (let* ((block? (symbol-ends? (tree-label t) (quote -block))) (newtag (if block? (quote gpg-encrypted-block) (quote gpg-encrypted))) (data (serialize-texmacs (tree-ref t 0))) (fingerprints (cdr (tree-children t)))) (and-with enc (gpg-encrypt data (map tree->string fingerprints)) (tree-set! t (quasiquote ((unquote newtag) (unquote enc) (unquote-splicing (cdr (tree-children t)))))) (tree-go-to t #:end) (autosave-buffer (current-buffer))))))
    => ((quote tm-gpg-encrypt) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tm-gpg-encrypt) #:secure (list #t)) ((quote tm-gpg-encrypt) #:synopsis (quote ("Encrypt @t"))))

(property-set! var prop what conds*)
  <= (tm-gpg-encrypt #:secure (#t) ())

(property-set! var prop what conds*)
  <= (tm-gpg-encrypt #:synopsis ("Encrypt @t") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Encrypt current block") (tm-define-overloaded (tm-gpg-encrypt-block!) (with-innermost t (quote gpg-decrypted-block) (tm-gpg-encrypt t))))
   => ((quote tm-gpg-encrypt-block!) #:synopsis (quote ("Encrypt current block")))
 => cons <> cur-props
   => cur-props => (((quote tm-gpg-encrypt-block!) #:synopsis (quote ("Encrypt current block"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tm-gpg-encrypt-block!) (with-innermost t (quote gpg-decrypted-block) (tm-gpg-encrypt t))))
    => ((quote tm-gpg-encrypt-block!) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tm-gpg-encrypt-block!) #:secure (list #t)) ((quote tm-gpg-encrypt-block!) #:synopsis (quote ("Encrypt current block"))))

(property-set! var prop what conds*)
  <= (tm-gpg-encrypt-block! #:secure (#t) ())

(property-set! var prop what conds*)
  <= (tm-gpg-encrypt-block! #:synopsis ("Encrypt current block") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Encrypt current inline region") (tm-define-overloaded (tm-gpg-encrypt!) (with-innermost t (quote gpg-decrypted) (tm-gpg-encrypt t))))
   => ((quote tm-gpg-encrypt!) #:synopsis (quote ("Encrypt current inline region")))
 => cons <> cur-props
   => cur-props => (((quote tm-gpg-encrypt!) #:synopsis (quote ("Encrypt current inline region"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tm-gpg-encrypt!) (with-innermost t (quote gpg-decrypted) (tm-gpg-encrypt t))))
    => ((quote tm-gpg-encrypt!) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tm-gpg-encrypt!) #:secure (list #t)) ((quote tm-gpg-encrypt!) #:synopsis (quote ("Encrypt current inline region"))))

(property-set! var prop what conds*)
  <= (tm-gpg-encrypt! #:secure (#t) ())

(property-set! var prop what conds*)
  <= (tm-gpg-encrypt! #:synopsis ("Encrypt current inline region") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Encrypt buffer") (tm-define-overloaded (tm-gpg-dialogue-encrypt-all) (map tm-gpg-encrypt (select (root-tree) (quote (#:* gpg-decrypted-block)))) (map tm-gpg-encrypt (select (root-tree) (quote (#:* gpg-decrypted))))))
   => ((quote tm-gpg-dialogue-encrypt-all) #:synopsis (quote ("Encrypt buffer")))
 => cons <> cur-props
   => cur-props => (((quote tm-gpg-dialogue-encrypt-all) #:synopsis (quote ("Encrypt buffer"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tm-gpg-dialogue-encrypt-all) (map tm-gpg-encrypt (select (root-tree) (quote (#:* gpg-decrypted-block)))) (map tm-gpg-encrypt (select (root-tree) (quote (#:* gpg-decrypted))))))
    => ((quote tm-gpg-dialogue-encrypt-all) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tm-gpg-dialogue-encrypt-all) #:secure (list #t)) ((quote tm-gpg-dialogue-encrypt-all) #:synopsis (quote ("Encrypt buffer"))))

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-encrypt-all #:secure (#t) ())

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-encrypt-all #:synopsis ("Encrypt buffer") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Passphrase encrypt @t with @passphrase") (tm-define-overloaded (tm-gpg-passphrase-encrypt t passphrase) (let* ((block? (symbol-ends? (tree-label t) (quote -block))) (newtag (if block? (quote gpg-passphrase-encrypted-block) (quote gpg-passphrase-encrypted))) (data (serialize-texmacs (tree-ref t 0))) (enc (gpg-passphrase-encrypt data passphrase))) (when enc (tree-set! t (quasiquote ((unquote newtag) (unquote enc)))) (tree-go-to t #:end) (autosave-buffer (current-buffer))))))
   => ((quote tm-gpg-passphrase-encrypt) #:synopsis (quote ("Passphrase encrypt @t with @passphrase")))
 => cons <> cur-props
   => cur-props => (((quote tm-gpg-passphrase-encrypt) #:synopsis (quote ("Passphrase encrypt @t with @passphrase"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tm-gpg-passphrase-encrypt t passphrase) (let* ((block? (symbol-ends? (tree-label t) (quote -block))) (newtag (if block? (quote gpg-passphrase-encrypted-block) (quote gpg-passphrase-encrypted))) (data (serialize-texmacs (tree-ref t 0))) (enc (gpg-passphrase-encrypt data passphrase))) (when enc (tree-set! t (quasiquote ((unquote newtag) (unquote enc)))) (tree-go-to t #:end) (autosave-buffer (current-buffer))))))
    => ((quote tm-gpg-passphrase-encrypt) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tm-gpg-passphrase-encrypt) #:secure (list #t)) ((quote tm-gpg-passphrase-encrypt) #:synopsis (quote ("Passphrase encrypt @t with @passphrase"))))

(property-set! var prop what conds*)
  <= (tm-gpg-passphrase-encrypt #:secure (#t) ())

(property-set! var prop what conds*)
  <= (tm-gpg-passphrase-encrypt #:synopsis ("Passphrase encrypt @t with @passphrase") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Interactive passphrase encryption") (tm-define-overloaded (tm-gpg-dialogue-passphrase-encrypt t) (with cb (lambda (x) (tm-gpg-passphrase-encrypt t x)) (dialogue-window gpg-widget-ask-new-passphrase (lambda (action) (tm-gpg-command-passphrase-encrypt cb action)) "Passphrase encryption"))))
   => ((quote tm-gpg-dialogue-passphrase-encrypt) #:synopsis (quote ("Interactive passphrase encryption")))
 => cons <> cur-props
   => cur-props => (((quote tm-gpg-dialogue-passphrase-encrypt) #:synopsis (quote ("Interactive passphrase encryption"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tm-gpg-dialogue-passphrase-encrypt t) (with cb (lambda (x) (tm-gpg-passphrase-encrypt t x)) (dialogue-window gpg-widget-ask-new-passphrase (lambda (action) (tm-gpg-command-passphrase-encrypt cb action)) "Passphrase encryption"))))
    => ((quote tm-gpg-dialogue-passphrase-encrypt) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tm-gpg-dialogue-passphrase-encrypt) #:secure (list #t)) ((quote tm-gpg-dialogue-passphrase-encrypt) #:synopsis (quote ("Interactive passphrase encryption"))))

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-passphrase-encrypt #:secure (#t) ())

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-passphrase-encrypt #:synopsis ("Interactive passphrase encryption") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Passphrase encrypt current block") (tm-define-overloaded (tm-gpg-dialogue-passphrase-encrypt-block!) (with-innermost t (quote gpg-passphrase-decrypted-block) (tm-gpg-dialogue-passphrase-encrypt t))))
   => ((quote tm-gpg-dialogue-passphrase-encrypt-block!) #:synopsis (quote ("Passphrase encrypt current block")))
 => cons <> cur-props
   => cur-props => (((quote tm-gpg-dialogue-passphrase-encrypt-block!) #:synopsis (quote ("Passphrase encrypt current block"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tm-gpg-dialogue-passphrase-encrypt-block!) (with-innermost t (quote gpg-passphrase-decrypted-block) (tm-gpg-dialogue-passphrase-encrypt t))))
    => ((quote tm-gpg-dialogue-passphrase-encrypt-block!) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tm-gpg-dialogue-passphrase-encrypt-block!) #:secure (list #t)) ((quote tm-gpg-dialogue-passphrase-encrypt-block!) #:synopsis (quote ("Passphrase encrypt current block"))))

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-passphrase-encrypt-block! #:secure (#t) ())

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-passphrase-encrypt-block! #:synopsis ("Passphrase encrypt current block") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Passphrase encrypt current inline region") (tm-define-overloaded (tm-gpg-dialogue-passphrase-encrypt!) (with-innermost t (quote gpg-passphrase-decrypted) (tm-gpg-dialogue-passphrase-encrypt t))))
   => ((quote tm-gpg-dialogue-passphrase-encrypt!) #:synopsis (quote ("Passphrase encrypt current inline region")))
 => cons <> cur-props
   => cur-props => (((quote tm-gpg-dialogue-passphrase-encrypt!) #:synopsis (quote ("Passphrase encrypt current inline region"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tm-gpg-dialogue-passphrase-encrypt!) (with-innermost t (quote gpg-passphrase-decrypted) (tm-gpg-dialogue-passphrase-encrypt t))))
    => ((quote tm-gpg-dialogue-passphrase-encrypt!) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tm-gpg-dialogue-passphrase-encrypt!) #:secure (list #t)) ((quote tm-gpg-dialogue-passphrase-encrypt!) #:synopsis (quote ("Passphrase encrypt current inline region"))))

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-passphrase-encrypt! #:secure (#t) ())

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-passphrase-encrypt! #:synopsis ("Passphrase encrypt current inline region") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Encrypt all passphrase decrypted regions") (tm-define-overloaded (tm-gpg-passphrase-encrypt-all passphrase) (with f (lambda (x) (tm-gpg-passphrase-encrypt x passphrase)) (map f (select (root-tree) (quote (#:* gpg-passphrase-decrypted-block)))) (map f (select (root-tree) (quote (#:* gpg-passphrase-decrypted)))))))
   => ((quote tm-gpg-passphrase-encrypt-all) #:synopsis (quote ("Encrypt all passphrase decrypted regions")))
 => cons <> cur-props
   => cur-props => (((quote tm-gpg-passphrase-encrypt-all) #:synopsis (quote ("Encrypt all passphrase decrypted regions"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tm-gpg-passphrase-encrypt-all passphrase) (with f (lambda (x) (tm-gpg-passphrase-encrypt x passphrase)) (map f (select (root-tree) (quote (#:* gpg-passphrase-decrypted-block)))) (map f (select (root-tree) (quote (#:* gpg-passphrase-decrypted)))))))
    => ((quote tm-gpg-passphrase-encrypt-all) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tm-gpg-passphrase-encrypt-all) #:secure (list #t)) ((quote tm-gpg-passphrase-encrypt-all) #:synopsis (quote ("Encrypt all passphrase decrypted regions"))))

(property-set! var prop what conds*)
  <= (tm-gpg-passphrase-encrypt-all #:secure (#t) ())

(property-set! var prop what conds*)
  <= (tm-gpg-passphrase-encrypt-all #:synopsis ("Encrypt all passphrase decrypted regions") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Interactive passphrase encryption") (tm-define-overloaded (tm-gpg-dialogue-passphrase-encrypt-all) (dialogue-window gpg-widget-ask-new-passphrase (lambda (action) (tm-gpg-command-passphrase-encrypt tm-gpg-passphrase-encrypt-all action)) "Passphrase encryption")))
   => ((quote tm-gpg-dialogue-passphrase-encrypt-all) #:synopsis (quote ("Interactive passphrase encryption")))
 => cons <> cur-props
   => cur-props => (((quote tm-gpg-dialogue-passphrase-encrypt-all) #:synopsis (quote ("Interactive passphrase encryption"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tm-gpg-dialogue-passphrase-encrypt-all) (dialogue-window gpg-widget-ask-new-passphrase (lambda (action) (tm-gpg-command-passphrase-encrypt tm-gpg-passphrase-encrypt-all action)) "Passphrase encryption")))
    => ((quote tm-gpg-dialogue-passphrase-encrypt-all) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tm-gpg-dialogue-passphrase-encrypt-all) #:secure (list #t)) ((quote tm-gpg-dialogue-passphrase-encrypt-all) #:synopsis (quote ("Interactive passphrase encryption"))))

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-passphrase-encrypt-all #:secure (#t) ())

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-passphrase-encrypt-all #:synopsis ("Interactive passphrase encryption") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Interactive decryption") (tm-define-overloaded (tm-gpg-dialogue-decrypt t . callback) (let* ((argcb (if (null? callback) noop (car callback))) (keys (gpg-secret-keys)) (rcps (map tree->string (cdr (tree-children t)))) (todo (filter (lambda (x) (gpg-search-key-by-fingerprint x keys)) rcps)) (enc (tree->string (tree-ref t 0))) (block? (symbol-ends? (tree-label t) (quote -block))) (newtag (if block? (quote gpg-decrypted-block) (quote gpg-decrypted))) (cb (lambda (dec) (with data (parse-texmacs-snippet dec) (tree-set! t (quasiquote ((unquote newtag) (unquote data) (unquote-splicing (cdr (tree-children t))))))) (tree-go-to t 0 #:end) (argcb)))) (gpg-try-decrypt enc todo cb))))
   => ((quote tm-gpg-dialogue-decrypt) #:synopsis (quote ("Interactive decryption")))
 => cons <> cur-props
   => cur-props => (((quote tm-gpg-dialogue-decrypt) #:synopsis (quote ("Interactive decryption"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tm-gpg-dialogue-decrypt t . callback) (let* ((argcb (if (null? callback) noop (car callback))) (keys (gpg-secret-keys)) (rcps (map tree->string (cdr (tree-children t)))) (todo (filter (lambda (x) (gpg-search-key-by-fingerprint x keys)) rcps)) (enc (tree->string (tree-ref t 0))) (block? (symbol-ends? (tree-label t) (quote -block))) (newtag (if block? (quote gpg-decrypted-block) (quote gpg-decrypted))) (cb (lambda (dec) (with data (parse-texmacs-snippet dec) (tree-set! t (quasiquote ((unquote newtag) (unquote data) (unquote-splicing (cdr (tree-children t))))))) (tree-go-to t 0 #:end) (argcb)))) (gpg-try-decrypt enc todo cb))))
    => ((quote tm-gpg-dialogue-decrypt) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tm-gpg-dialogue-decrypt) #:secure (list #t)) ((quote tm-gpg-dialogue-decrypt) #:synopsis (quote ("Interactive decryption"))))

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-decrypt #:secure (#t) ())

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-decrypt #:synopsis ("Interactive decryption") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Interactive decryption") (tm-define-overloaded (tm-gpg-dialogue-decrypt-block!) (with-innermost t (quote gpg-encrypted-block) (tm-gpg-dialogue-decrypt t))))
   => ((quote tm-gpg-dialogue-decrypt-block!) #:synopsis (quote ("Interactive decryption")))
 => cons <> cur-props
   => cur-props => (((quote tm-gpg-dialogue-decrypt-block!) #:synopsis (quote ("Interactive decryption"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tm-gpg-dialogue-decrypt-block!) (with-innermost t (quote gpg-encrypted-block) (tm-gpg-dialogue-decrypt t))))
    => ((quote tm-gpg-dialogue-decrypt-block!) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tm-gpg-dialogue-decrypt-block!) #:secure (list #t)) ((quote tm-gpg-dialogue-decrypt-block!) #:synopsis (quote ("Interactive decryption"))))

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-decrypt-block! #:secure (#t) ())

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-decrypt-block! #:synopsis ("Interactive decryption") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Interactive decryption") (tm-define-overloaded (tm-gpg-dialogue-decrypt!) (with-innermost t (quote gpg-encrypted) (tm-gpg-dialogue-decrypt t))))
   => ((quote tm-gpg-dialogue-decrypt!) #:synopsis (quote ("Interactive decryption")))
 => cons <> cur-props
   => cur-props => (((quote tm-gpg-dialogue-decrypt!) #:synopsis (quote ("Interactive decryption"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tm-gpg-dialogue-decrypt!) (with-innermost t (quote gpg-encrypted) (tm-gpg-dialogue-decrypt t))))
    => ((quote tm-gpg-dialogue-decrypt!) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tm-gpg-dialogue-decrypt!) #:secure (list #t)) ((quote tm-gpg-dialogue-decrypt!) #:synopsis (quote ("Interactive decryption"))))

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-decrypt! #:secure (#t) ())

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-decrypt! #:synopsis ("Interactive decryption") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Interactive decryption of all encrypted regions") (tm-define-overloaded (tm-gpg-dialogue-decrypt-all) (with s (append (select (root-tree) (quote (#:* gpg-encrypted-block))) (select (root-tree) (quote (#:* gpg-encrypted)))) (when (nnull? s) (tm-gpg-dialogue-decrypt (car s) tm-gpg-dialogue-decrypt-all)))))
   => ((quote tm-gpg-dialogue-decrypt-all) #:synopsis (quote ("Interactive decryption of all encrypted regions")))
 => cons <> cur-props
   => cur-props => (((quote tm-gpg-dialogue-decrypt-all) #:synopsis (quote ("Interactive decryption of all encrypted regions"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tm-gpg-dialogue-decrypt-all) (with s (append (select (root-tree) (quote (#:* gpg-encrypted-block))) (select (root-tree) (quote (#:* gpg-encrypted)))) (when (nnull? s) (tm-gpg-dialogue-decrypt (car s) tm-gpg-dialogue-decrypt-all)))))
    => ((quote tm-gpg-dialogue-decrypt-all) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tm-gpg-dialogue-decrypt-all) #:secure (list #t)) ((quote tm-gpg-dialogue-decrypt-all) #:synopsis (quote ("Interactive decryption of all encrypted regions"))))

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-decrypt-all #:secure (#t) ())

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-decrypt-all #:synopsis ("Interactive decryption of all encrypted regions") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Passphrase decrypt @t with @passphrase") (tm-define-overloaded (tm-gpg-passphrase-decrypt t passphrase) (let* ((block? (symbol-ends? (tree-label t) (quote -block))) (newtag (if block? (quote gpg-passphrase-decrypted-block) (quote gpg-passphrase-decrypted))) (data (tree->string (tree-ref t 0))) (dec (gpg-passphrase-decrypt data passphrase))) (when dec (with data (parse-texmacs-snippet dec) (tree-set! t (quasiquote ((unquote newtag) (unquote data)))) (tree-go-to t 0 #:end))))))
   => ((quote tm-gpg-passphrase-decrypt) #:synopsis (quote ("Passphrase decrypt @t with @passphrase")))
 => cons <> cur-props
   => cur-props => (((quote tm-gpg-passphrase-decrypt) #:synopsis (quote ("Passphrase decrypt @t with @passphrase"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tm-gpg-passphrase-decrypt t passphrase) (let* ((block? (symbol-ends? (tree-label t) (quote -block))) (newtag (if block? (quote gpg-passphrase-decrypted-block) (quote gpg-passphrase-decrypted))) (data (tree->string (tree-ref t 0))) (dec (gpg-passphrase-decrypt data passphrase))) (when dec (with data (parse-texmacs-snippet dec) (tree-set! t (quasiquote ((unquote newtag) (unquote data)))) (tree-go-to t 0 #:end))))))
    => ((quote tm-gpg-passphrase-decrypt) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tm-gpg-passphrase-decrypt) #:secure (list #t)) ((quote tm-gpg-passphrase-decrypt) #:synopsis (quote ("Passphrase decrypt @t with @passphrase"))))

(property-set! var prop what conds*)
  <= (tm-gpg-passphrase-decrypt #:secure (#t) ())

(property-set! var prop what conds*)
  <= (tm-gpg-passphrase-decrypt #:synopsis ("Passphrase decrypt @t with @passphrase") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Interactive passphrase decryption") (tm-define-overloaded (tm-gpg-dialogue-passphrase-decrypt t) (with cb (lambda (x) (tm-gpg-passphrase-decrypt t x)) (dialogue-window (gpg-widget-ask-standalone-passphrase (lambda (x) (gpg-decryptable? (tree->string (tree-ref t 0)) x))) (lambda (action) (tm-gpg-command-passphrase-decrypt cb action)) "Passphrase decryption"))))
   => ((quote tm-gpg-dialogue-passphrase-decrypt) #:synopsis (quote ("Interactive passphrase decryption")))
 => cons <> cur-props
   => cur-props => (((quote tm-gpg-dialogue-passphrase-decrypt) #:synopsis (quote ("Interactive passphrase decryption"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tm-gpg-dialogue-passphrase-decrypt t) (with cb (lambda (x) (tm-gpg-passphrase-decrypt t x)) (dialogue-window (gpg-widget-ask-standalone-passphrase (lambda (x) (gpg-decryptable? (tree->string (tree-ref t 0)) x))) (lambda (action) (tm-gpg-command-passphrase-decrypt cb action)) "Passphrase decryption"))))
    => ((quote tm-gpg-dialogue-passphrase-decrypt) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tm-gpg-dialogue-passphrase-decrypt) #:secure (list #t)) ((quote tm-gpg-dialogue-passphrase-decrypt) #:synopsis (quote ("Interactive passphrase decryption"))))

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-passphrase-decrypt #:secure (#t) ())

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-passphrase-decrypt #:synopsis ("Interactive passphrase decryption") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Passphrase decrypt current block") (tm-define-overloaded (tm-gpg-dialogue-passphrase-decrypt-block!) (with-innermost t (quote gpg-passphrase-encrypted-block) (tm-gpg-dialogue-passphrase-decrypt t))))
   => ((quote tm-gpg-dialogue-passphrase-decrypt-block!) #:synopsis (quote ("Passphrase decrypt current block")))
 => cons <> cur-props
   => cur-props => (((quote tm-gpg-dialogue-passphrase-decrypt-block!) #:synopsis (quote ("Passphrase decrypt current block"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tm-gpg-dialogue-passphrase-decrypt-block!) (with-innermost t (quote gpg-passphrase-encrypted-block) (tm-gpg-dialogue-passphrase-decrypt t))))
    => ((quote tm-gpg-dialogue-passphrase-decrypt-block!) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tm-gpg-dialogue-passphrase-decrypt-block!) #:secure (list #t)) ((quote tm-gpg-dialogue-passphrase-decrypt-block!) #:synopsis (quote ("Passphrase decrypt current block"))))

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-passphrase-decrypt-block! #:secure (#t) ())

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-passphrase-decrypt-block! #:synopsis ("Passphrase decrypt current block") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Passphrase decrypt current inline region") (tm-define-overloaded (tm-gpg-dialogue-passphrase-decrypt!) (with-innermost t (quote gpg-passphrase-encrypted) (tm-gpg-dialogue-passphrase-decrypt t))))
   => ((quote tm-gpg-dialogue-passphrase-decrypt!) #:synopsis (quote ("Passphrase decrypt current inline region")))
 => cons <> cur-props
   => cur-props => (((quote tm-gpg-dialogue-passphrase-decrypt!) #:synopsis (quote ("Passphrase decrypt current inline region"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tm-gpg-dialogue-passphrase-decrypt!) (with-innermost t (quote gpg-passphrase-encrypted) (tm-gpg-dialogue-passphrase-decrypt t))))
    => ((quote tm-gpg-dialogue-passphrase-decrypt!) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tm-gpg-dialogue-passphrase-decrypt!) #:secure (list #t)) ((quote tm-gpg-dialogue-passphrase-decrypt!) #:synopsis (quote ("Passphrase decrypt current inline region"))))

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-passphrase-decrypt! #:secure (#t) ())

(property-set! var prop what conds*)
  <= (tm-gpg-dialogue-passphrase-decrypt! #:synopsis ("Passphrase decrypt current inline region") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Passphrase decrypt all regions in buffer") (tm-define-overloaded (tm-gpg-passphrase-decrypt-all passphrase) (with f (lambda (x) (tm-gpg-passphrase-decrypt x passphrase)) (map f (select (root-tree) (quote (#:* gpg-passphrase-encrypted-block)))) (map f (select (root-tree) (quote (#:* gpg-passphrase-encrypted)))))))
   => ((quote tm-gpg-passphrase-decrypt-all) #:synopsis (quote ("Passphrase decrypt all regions in buffer")))
 => cons <> cur-props
   => cur-props => (((quote tm-gpg-passphrase-decrypt-all) #:synopsis (quote ("Passphrase decrypt all regions in buffer"))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (tm-gpg-passphrase-decrypt-all passphrase) (with f (lambda (x) (tm-gpg-passphrase-decrypt x passphrase)) (map f (select (root-tree) (quote (#:* gpg-passphrase-encrypted-block)))) (map f (select (root-tree) (quote (#:* gpg-passphrase-encrypted)))))))
    => ((quote tm-gpg-passphrase-decrypt-all) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote tm-gpg-passphrase-decrypt-all) #:secure (list #t)) ((quote tm-gpg-passphrase-decrypt-all) #:synopsis (quote ("Passphrase decrypt all regions in buffer"))))

(property-set! var prop what conds*)
  <= (tm-gpg-passphrase-decrypt-all #:secure (#t) ())

(property-set! var prop what conds*)
  <= (tm-gpg-passphrase-decrypt-all #:synopsis ("Passphrase decrypt all regions in buffer") ())

  (define-option-require opt decl)
    <= (((or (tm-gpg-decrypted? t) (tm-gpg-encrypted? t) (tm-gpg-passphrase-decrypted? t) (tm-gpg-passphrase-encrypted? t))) (tm-define-overloaded (structured-insert-horizontal t forwards?) (noop)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (or (tm-gpg-decrypted? t) (tm-gpg-encrypted? t) (tm-gpg-passphrase-decrypted? t) (tm-gpg-passphrase-encrypted? t))) (tm-define-overloaded (structured-insert-horizontal t forwards?) (noop)))

  (define-option-require opt decl)
    <= (((or (tm-gpg-decrypted? t) (tm-gpg-encrypted? t) (tm-gpg-passphrase-decrypted? t) (tm-gpg-passphrase-encrypted? t))) (tm-define-overloaded (structured-remove-horizontal t forwards?) (noop)))
    => (define-option-match opt decl) <= ((lambda (t forwards?) (or (tm-gpg-decrypted? t) (tm-gpg-encrypted? t) (tm-gpg-passphrase-decrypted? t) (tm-gpg-passphrase-encrypted? t))) (tm-define-overloaded (structured-remove-horizontal t forwards?) (noop)))

  (define-option-require opt decl)
    <= (((== (with-buffer name (get-init "encryption")) "gpg-passphrase")) (tm-define-overloaded (tree-export-encrypted name t) (let* ((err (lambda () (set-message (quasiquote (concat "Could not save " (unquote (url->system name)))) "Save file") (dialogue-window (gpg-widget-error-export-tree-texmacs-hook name) noop "Encryption error"))) (dec (serialize-texmacs t)) (passphrase (gpg-get-buffer-passphrase name))) (if (and dec passphrase) (with enc (gpg-passphrase-encrypt dec passphrase) (if enc (stree->tree (quasiquote (document (TeXmacs (unquote (texmacs-version))) (style (tuple "generic")) (body (document (gpg-passphrase-encrypted-buffer (unquote enc))))))) (begin (err) t))) (begin (err) t)))))
    => (define-option-match opt decl) <= ((lambda (name t) (== (with-buffer name (get-init "encryption")) "gpg-passphrase")) (tm-define-overloaded (tree-export-encrypted name t) (let* ((err (lambda () (set-message (quasiquote (concat "Could not save " (unquote (url->system name)))) "Save file") (dialogue-window (gpg-widget-error-export-tree-texmacs-hook name) noop "Encryption error"))) (dec (serialize-texmacs t)) (passphrase (gpg-get-buffer-passphrase name))) (if (and dec passphrase) (with enc (gpg-passphrase-encrypt dec passphrase) (if enc (stree->tree (quasiquote (document (TeXmacs (unquote (texmacs-version))) (style (tuple "generic")) (body (document (gpg-passphrase-encrypted-buffer (unquote enc))))))) (begin (err) t))) (begin (err) t)))))

  (define-option-require opt decl)
    <= (((== (get-init "encryption") "gpg-passphrase")) (tm-define-overloaded (save-buffer-as-main new-name . args) (gpg-copy-buffer-passphrase (current-buffer) new-name) (former new-name args)))
    => (define-option-match opt decl) <= ((lambda (new-name . args) (== (get-init "encryption") "gpg-passphrase")) (tm-define-overloaded (save-buffer-as-main new-name . args) (gpg-copy-buffer-passphrase (current-buffer) new-name) (former new-name args)))

  (define-option-require opt decl)
    <= (((or (tm-gpg-decrypted? t) (tm-gpg-encrypted? t) (tm-gpg-passphrase-decrypted? t) (tm-gpg-passphrase-encrypted? t))) (tm-define-overloaded (focus-can-insert? t) #f))
    => (define-option-match opt decl) <= ((lambda (t) (or (tm-gpg-decrypted? t) (tm-gpg-encrypted? t) (tm-gpg-passphrase-decrypted? t) (tm-gpg-passphrase-encrypted? t))) (tm-define-overloaded (focus-can-insert? t) #f))

  (define-option-require opt decl)
    <= (((or (tm-gpg-decrypted? t) (tm-gpg-encrypted? t) (tm-gpg-passphrase-decrypted? t) (tm-gpg-passphrase-encrypted? t))) (tm-define-overloaded (focus-can-remove? t) #f))
    => (define-option-match opt decl) <= ((lambda (t) (or (tm-gpg-decrypted? t) (tm-gpg-encrypted? t) (tm-gpg-passphrase-decrypted? t) (tm-gpg-passphrase-encrypted? t))) (tm-define-overloaded (focus-can-remove? t) #f))

  (define-option-require opt decl)
    <= (((or (tm-gpg-decrypted? t) (tm-gpg-encrypted? t) (tm-gpg-passphrase-decrypted? t) (tm-gpg-passphrase-encrypted? t))) (tm-define-overloaded (focus-can-insert-remove? t) #f))
    => (define-option-match opt decl) <= ((lambda (t) (or (tm-gpg-decrypted? t) (tm-gpg-encrypted? t) (tm-gpg-passphrase-decrypted? t) (tm-gpg-passphrase-encrypted? t))) (tm-define-overloaded (focus-can-insert-remove? t) #f))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (gpg-decrypted-block gpg-decrypted)))) (tm-define-overloaded (focus-variants-of t) (list (quote gpg-decrypted) (quote gpg-decrypted-block))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (gpg-decrypted-block gpg-decrypted)))) (tm-define-overloaded (focus-variants-of t) (list (quote gpg-decrypted) (quote gpg-decrypted-block))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (gpg-passphrase-decrypted-block gpg-passphrase-decrypted)))) (tm-define-overloaded (focus-variants-of t) (list (quote gpg-passphrase-decrypted) (quote gpg-passphrase-decrypted-block))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (gpg-passphrase-decrypted-block gpg-passphrase-decrypted)))) (tm-define-overloaded (focus-variants-of t) (list (quote gpg-passphrase-decrypted) (quote gpg-passphrase-decrypted-block))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (gpg-encrypted-block gpg-encrypted)))) (tm-define-overloaded (focus-variants-of t) (list (quote gpg-encrypted) (quote gpg-encrypted-block))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (gpg-encrypted-block gpg-encrypted)))) (tm-define-overloaded (focus-variants-of t) (list (quote gpg-encrypted) (quote gpg-encrypted-block))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (gpg-passphrase-encrypted-block gpg-passphrase-encrypted)))) (tm-define-overloaded (focus-variants-of t) (list (quote gpg-passphrase-encrypted) (quote gpg-passphrase-encrypted-block))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (gpg-passphrase-encrypted-block gpg-passphrase-encrypted)))) (tm-define-overloaded (focus-variants-of t) (list (quote gpg-passphrase-encrypted) (quote gpg-passphrase-encrypted-block))))

  (define-option-require opt decl)
    <= (((or (tm-gpg-symbol-decrypted? l) (tm-gpg-symbol-passphrase-decrypted? l))) (tm-define-overloaded (standard-options l) (list "gpg-info-level-none" "gpg-info-level-short" "gpg-info-level-detailed")))
    => (define-option-match opt decl) <= ((lambda (l) (or (tm-gpg-symbol-decrypted? l) (tm-gpg-symbol-passphrase-decrypted? l))) (tm-define-overloaded (standard-options l) (list "gpg-info-level-none" "gpg-info-level-short" "gpg-info-level-detailed")))

  (define-option-require opt decl)
    <= (((== l "gpg-info-level")) (tm-define-overloaded (parameter-show-in-menu? l) #f))
    => (define-option-match opt decl) <= ((lambda (l) (== l "gpg-info-level")) (tm-define-overloaded (parameter-show-in-menu? l) #f))

  (define-option-require opt decl)
    <= (((in? p (list "gpg-info-level-none" "gpg-info-level-short" "gpg-info-level-detailed"))) (tm-define-overloaded (style-category p) #:gpg-decrypted-style))
    => (define-option-match opt decl) <= ((lambda (p) (in? p (list "gpg-info-level-none" "gpg-info-level-short" "gpg-info-level-detailed"))) (tm-define-overloaded (style-category p) #:gpg-decrypted-style))

  (define-option-require opt decl)
    <= (((tm-gpg-decrypted? t)) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic ("Encrypt" (tm-gpg-encrypt (focus-tree))))))
    => (define-option-match opt decl) <= ((lambda (t) (tm-gpg-decrypted? t)) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic ("Encrypt" (tm-gpg-encrypt (focus-tree))))))

  (define-option-require opt decl)
    <= (((tm-gpg-passphrase-decrypted? t)) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic ("Encrypt" (tm-gpg-dialogue-passphrase-encrypt (focus-tree))))))
    => (define-option-match opt decl) <= ((lambda (t) (tm-gpg-passphrase-decrypted? t)) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic ("Encrypt" (tm-gpg-dialogue-passphrase-encrypt (focus-tree))))))

  (define-option-require opt decl)
    <= (((tm-gpg-encrypted? t)) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic ("Decrypt" (tm-gpg-dialogue-decrypt (focus-tree))))))
    => (define-option-match opt decl) <= ((lambda (t) (tm-gpg-encrypted? t)) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic ("Decrypt" (tm-gpg-dialogue-decrypt (focus-tree))))))

  (define-option-require opt decl)
    <= (((tm-gpg-passphrase-encrypted? t)) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic ("Decrypt" (tm-gpg-dialogue-passphrase-decrypt (focus-tree))))))
    => (define-option-match opt decl) <= ((lambda (t) (tm-gpg-passphrase-encrypted? t)) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic ("Decrypt" (tm-gpg-dialogue-passphrase-decrypt (focus-tree))))))

  (define-option-require opt decl)
    <= (((tm-gpg-decrypted? t)) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic ((check (balloon (icon "tm_lock_open.xpm") "Decrypted") "v" (alternate-second? (focus-tree))) (tm-gpg-encrypt (focus-tree))))))
    => (define-option-match opt decl) <= ((lambda (t) (tm-gpg-decrypted? t)) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic ((check (balloon (icon "tm_lock_open.xpm") "Decrypted") "v" (alternate-second? (focus-tree))) (tm-gpg-encrypt (focus-tree))))))

  (define-option-require opt decl)
    <= (((tm-gpg-passphrase-decrypted? t)) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic ((check (balloon (icon "tm_lock_open.xpm") "Decrypted") "v" (alternate-second? (focus-tree))) (tm-gpg-dialogue-passphrase-encrypt (focus-tree))))))
    => (define-option-match opt decl) <= ((lambda (t) (tm-gpg-passphrase-decrypted? t)) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic ((check (balloon (icon "tm_lock_open.xpm") "Decrypted") "v" (alternate-second? (focus-tree))) (tm-gpg-dialogue-passphrase-encrypt (focus-tree))))))

  (define-option-require opt decl)
    <= (((tm-gpg-encrypted? t)) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic ((check (balloon (icon "tm_lock_closed.xpm") "Encrypted") "v" (alternate-second? (focus-tree))) (tm-gpg-dialogue-decrypt (focus-tree))))))
    => (define-option-match opt decl) <= ((lambda (t) (tm-gpg-encrypted? t)) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic ((check (balloon (icon "tm_lock_closed.xpm") "Encrypted") "v" (alternate-second? (focus-tree))) (tm-gpg-dialogue-decrypt (focus-tree))))))

  (define-option-require opt decl)
    <= (((tm-gpg-passphrase-encrypted? t)) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic ((check (balloon (icon "tm_lock_closed.xpm") "Encrypted") "v" (alternate-second? (focus-tree))) (tm-gpg-dialogue-passphrase-decrypt (focus-tree))))))
    => (define-option-match opt decl) <= ((lambda (t) (tm-gpg-passphrase-encrypted? t)) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic ((check (balloon (icon "tm_lock_closed.xpm") "Encrypted") "v" (alternate-second? (focus-tree))) (tm-gpg-dialogue-passphrase-decrypt (focus-tree))))))

  (define-option-require opt decl)
    <= (((tm-gpg-decrypted? t)) (tm-define-overloaded (alternate-toggle t) (tm-gpg-encrypt t)))
    => (define-option-match opt decl) <= ((lambda (t) (tm-gpg-decrypted? t)) (tm-define-overloaded (alternate-toggle t) (tm-gpg-encrypt t)))

  (define-option-require opt decl)
    <= (((tm-gpg-encrypted? t)) (tm-define-overloaded (alternate-toggle t) (tm-gpg-dialogue-decrypt t)))
    => (define-option-match opt decl) <= ((lambda (t) (tm-gpg-encrypted? t)) (tm-define-overloaded (alternate-toggle t) (tm-gpg-dialogue-decrypt t)))

  (define-option-require opt decl)
    <= (((tm-gpg-passphrase-decrypted? t)) (tm-define-overloaded (alternate-toggle t) (tm-gpg-dialogue-passphrase-encrypt t)))
    => (define-option-match opt decl) <= ((lambda (t) (tm-gpg-passphrase-decrypted? t)) (tm-define-overloaded (alternate-toggle t) (tm-gpg-dialogue-passphrase-encrypt t)))

  (define-option-require opt decl)
    <= (((tm-gpg-passphrase-encrypted? t)) (tm-define-overloaded (alternate-toggle t) (tm-gpg-dialogue-passphrase-decrypt t)))
    => (define-option-match opt decl) <= ((lambda (t) (tm-gpg-passphrase-encrypted? t)) (tm-define-overloaded (alternate-toggle t) (tm-gpg-dialogue-passphrase-decrypt t)))

  (define-option-require opt decl)
    <= (((tm-gpg-decrypted? t)) (tm-define-overloaded (focus-hidden-icons t) (menu-dynamic)))
    => (define-option-match opt decl) <= ((lambda (t) (tm-gpg-decrypted? t)) (tm-define-overloaded (focus-hidden-icons t) (menu-dynamic)))

  (define-option-require opt decl)
    <= (((tm-gpg-encrypted? t)) (tm-define-overloaded (focus-hidden-icons t) (menu-dynamic)))
    => (define-option-match opt decl) <= ((lambda (t) (tm-gpg-encrypted? t)) (tm-define-overloaded (focus-hidden-icons t) (menu-dynamic)))

  (define-option-require opt decl)
    <= (((tm-gpg-passphrase-decrypted? t)) (tm-define-overloaded (focus-hidden-icons t) (menu-dynamic)))
    => (define-option-match opt decl) <= ((lambda (t) (tm-gpg-passphrase-decrypted? t)) (tm-define-overloaded (focus-hidden-icons t) (menu-dynamic)))

  (define-option-require opt decl)
    <= (((tm-gpg-passphrase-encrypted? t)) (tm-define-overloaded (focus-hidden-icons t) (menu-dynamic)))
    => (define-option-match opt decl) <= ((lambda (t) (tm-gpg-passphrase-encrypted? t)) (tm-define-overloaded (focus-hidden-icons t) (menu-dynamic)))

  (define-option-require opt decl)
    <= (((tm-gpg-decrypted? t)) (tm-define-overloaded (focus-extra-menu t) (menu-dynamic --- ("Recipients" (tm-gpg-dialogue-replace-decrypted (focus-tree))))))
    => (define-option-match opt decl) <= ((lambda (t) (tm-gpg-decrypted? t)) (tm-define-overloaded (focus-extra-menu t) (menu-dynamic --- ("Recipients" (tm-gpg-dialogue-replace-decrypted (focus-tree))))))

  (define-option-require opt decl)
    <= (((tm-gpg-decrypted? t)) (tm-define-overloaded (focus-extra-icons t) (menu-dynamic // ("Recipients" (tm-gpg-dialogue-replace-decrypted (focus-tree))))))
    => (define-option-match opt decl) <= ((lambda (t) (tm-gpg-decrypted? t)) (tm-define-overloaded (focus-extra-icons t) (menu-dynamic // ("Recipients" (tm-gpg-dialogue-replace-decrypted (focus-tree))))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (gpg-passphrase-encrypted-buffer)))) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic ((check (balloon (icon "tm_lock_closed.xpm") "Encrypted buffer") "v" (alternate-second? (focus-tree))) (tm-gpg-dialogue-passphrase-decrypt-buffer (current-buffer))))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (gpg-passphrase-encrypted-buffer)))) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic ((check (balloon (icon "tm_lock_closed.xpm") "Encrypted buffer") "v" (alternate-second? (focus-tree))) (tm-gpg-dialogue-passphrase-decrypt-buffer (current-buffer))))))

  (define-option-proposals opt decl)
    <= ((admin (quote ("no" "yes"))) (tm-define-overloaded (server-set-user-information pseudo name passwd email admin) (with uid (or (server-find-user pseudo) (pseudo->user pseudo)) (server-set-user-info uid pseudo name passwd email (== admin "yes")))))
    => cons <> cur-props <= ((quote server-set-user-information) (quote (#:proposals admin)) (lambda () (quote ("no" "yes"))))
    => cur-props => (((quote server-set-user-information) (quote (#:proposals admin)) (lambda () (quote ("no" "yes")))))

  (define-option-argument opt decl)
    <= ((admin "Administrive rights?") (tm-define-overloaded (server-set-user-information pseudo name passwd email admin) (with uid (or (server-find-user pseudo) (pseudo->user pseudo)) (server-set-user-info uid pseudo name passwd email (== admin "yes")))))
    => cons <> cur-props <= ((quote server-set-user-information) #:arguments (quote (pseudo name passwd email admin)))
    => cons <> cur-props <= ((quote server-set-user-information) (quote (#:argument admin)) (quote ("Administrive rights?")))
    => cur-props => (((quote server-set-user-information) (quote (#:argument admin)) (quote ("Administrive rights?"))) ((quote server-set-user-information) #:arguments (quote (pseudo name passwd email admin))) ((quote server-set-user-information) (quote (#:proposals admin)) (lambda () (quote ("no" "yes")))))

  (define-option-argument opt decl)
    <= ((email "Email address") (tm-define-overloaded (server-set-user-information pseudo name passwd email admin) (with uid (or (server-find-user pseudo) (pseudo->user pseudo)) (server-set-user-info uid pseudo name passwd email (== admin "yes")))))
    => cons <> cur-props <= ((quote server-set-user-information) #:arguments (quote (pseudo name passwd email admin)))
    => cons <> cur-props <= ((quote server-set-user-information) (quote (#:argument email)) (quote ("Email address")))
    => cur-props => (((quote server-set-user-information) (quote (#:argument email)) (quote ("Email address"))) ((quote server-set-user-information) #:arguments (quote (pseudo name passwd email admin))) ((quote server-set-user-information) (quote (#:argument admin)) (quote ("Administrive rights?"))) ((quote server-set-user-information) #:arguments (quote (pseudo name passwd email admin))) ((quote server-set-user-information) (quote (#:proposals admin)) (lambda () (quote ("no" "yes")))))

  (define-option-argument opt decl)
    <= ((passwd "password" "Password") (tm-define-overloaded (server-set-user-information pseudo name passwd email admin) (with uid (or (server-find-user pseudo) (pseudo->user pseudo)) (server-set-user-info uid pseudo name passwd email (== admin "yes")))))
    => cons <> cur-props <= ((quote server-set-user-information) #:arguments (quote (pseudo name passwd email admin)))
    => cons <> cur-props <= ((quote server-set-user-information) (quote (#:argument passwd)) (quote ("password" "Password")))
    => cur-props => (((quote server-set-user-information) (quote (#:argument passwd)) (quote ("password" "Password"))) ((quote server-set-user-information) #:arguments (quote (pseudo name passwd email admin))) ((quote server-set-user-information) (quote (#:argument email)) (quote ("Email address"))) ((quote server-set-user-information) #:arguments (quote (pseudo name passwd email admin))) ((quote server-set-user-information) (quote (#:argument admin)) (quote ("Administrive rights?"))) ((quote server-set-user-information) #:arguments (quote (pseudo name passwd email admin))) ((quote server-set-user-information) (quote (#:proposals admin)) (lambda () (quote ("no" "yes")))))

  (define-option-argument opt decl)
    <= ((name "Full name") (tm-define-overloaded (server-set-user-information pseudo name passwd email admin) (with uid (or (server-find-user pseudo) (pseudo->user pseudo)) (server-set-user-info uid pseudo name passwd email (== admin "yes")))))
    => cons <> cur-props <= ((quote server-set-user-information) #:arguments (quote (pseudo name passwd email admin)))
    => cons <> cur-props <= ((quote server-set-user-information) (quote (#:argument name)) (quote ("Full name")))
    => cur-props => (((quote server-set-user-information) (quote (#:argument name)) (quote ("Full name"))) ((quote server-set-user-information) #:arguments (quote (pseudo name passwd email admin))) ((quote server-set-user-information) (quote (#:argument passwd)) (quote ("password" "Password"))) ((quote server-set-user-information) #:arguments (quote (pseudo name passwd email admin))) ((quote server-set-user-information) (quote (#:argument email)) (quote ("Email address"))) ((quote server-set-user-information) #:arguments (quote (pseudo name passwd email admin))) ((quote server-set-user-information) (quote (#:argument admin)) (quote ("Administrive rights?"))) ((quote server-set-user-information) #:arguments (quote (pseudo name passwd email admin))) ((quote server-set-user-information) (quote (#:proposals admin)) (lambda () (quote ("no" "yes")))))

  (define-option-argument opt decl)
    <= ((pseudo "User pseudo") (tm-define-overloaded (server-set-user-information pseudo name passwd email admin) (with uid (or (server-find-user pseudo) (pseudo->user pseudo)) (server-set-user-info uid pseudo name passwd email (== admin "yes")))))
    => cons <> cur-props <= ((quote server-set-user-information) #:arguments (quote (pseudo name passwd email admin)))
    => cons <> cur-props <= ((quote server-set-user-information) (quote (#:argument pseudo)) (quote ("User pseudo")))
    => cur-props => (((quote server-set-user-information) (quote (#:argument pseudo)) (quote ("User pseudo"))) ((quote server-set-user-information) #:arguments (quote (pseudo name passwd email admin))) ((quote server-set-user-information) (quote (#:argument name)) (quote ("Full name"))) ((quote server-set-user-information) #:arguments (quote (pseudo name passwd email admin))) ((quote server-set-user-information) (quote (#:argument passwd)) (quote ("password" "Password"))) ((quote server-set-user-information) #:arguments (quote (pseudo name passwd email admin))) ((quote server-set-user-information) (quote (#:argument email)) (quote ("Email address"))) ((quote server-set-user-information) #:arguments (quote (pseudo name passwd email admin))) ((quote server-set-user-information) (quote (#:argument admin)) (quote ("Administrive rights?"))) ((quote server-set-user-information) #:arguments (quote (pseudo name passwd email admin))) ((quote server-set-user-information) (quote (#:proposals admin)) (lambda () (quote ("no" "yes")))))

(property-set! var prop what conds*)
  <= (server-set-user-information (#:argument pseudo) ("User pseudo") ())

(property-set! var prop what conds*)
  <= (server-set-user-information #:arguments (pseudo name passwd email admin) ())

(property-set! var prop what conds*)
  <= (server-set-user-information (#:argument name) ("Full name") ())

(property-set! var prop what conds*)
  <= (server-set-user-information #:arguments (pseudo name passwd email admin) ())

(property-set! var prop what conds*)
  <= (server-set-user-information (#:argument passwd) ("password" "Password") ())

(property-set! var prop what conds*)
  <= (server-set-user-information #:arguments (pseudo name passwd email admin) ())

(property-set! var prop what conds*)
  <= (server-set-user-information (#:argument email) ("Email address") ())

(property-set! var prop what conds*)
  <= (server-set-user-information #:arguments (pseudo name passwd email admin) ())

(property-set! var prop what conds*)
  <= (server-set-user-information (#:argument admin) ("Administrive rights?") ())

(property-set! var prop what conds*)
  <= (server-set-user-information #:arguments (pseudo name passwd email admin) ())

(property-set! var prop what conds*)
  <= (server-set-user-information (#:proposals admin) #<procedure #f ()> ())

  (define-option-argument opt decl)
    <= ((agreed "Licence agreement") (tm-define-overloaded (client-new-account server-name pseudo name passwd email agreed) (with uid (pseudo->user pseudo) (when (== uid (get-default-user)) (when (== (get-user-info "name") "") (set-user-info "name" name)) (when (== (get-user-info "email") "") (set-user-info "email" email)))) (with server (client-start server-name) (when (!= server -1) (enter-secure-mode server) (client-remote-eval* server (quasiquote (new-account (unquote pseudo) (unquote name) (unquote passwd) (unquote email) (unquote agreed))) (lambda (msg) (set-message msg "creating new account") (when (== msg "done") (notify-account server-name pseudo passwd)) (client-stop server)))))))
    => cons <> cur-props <= ((quote client-new-account) #:arguments (quote (server-name pseudo name passwd email agreed)))
    => cons <> cur-props <= ((quote client-new-account) (quote (#:argument agreed)) (quote ("Licence agreement")))
    => cur-props => (((quote client-new-account) (quote (#:argument agreed)) (quote ("Licence agreement"))) ((quote client-new-account) #:arguments (quote (server-name pseudo name passwd email agreed))))

  (define-option-argument opt decl)
    <= ((email "Email address") (tm-define-overloaded (client-new-account server-name pseudo name passwd email agreed) (with uid (pseudo->user pseudo) (when (== uid (get-default-user)) (when (== (get-user-info "name") "") (set-user-info "name" name)) (when (== (get-user-info "email") "") (set-user-info "email" email)))) (with server (client-start server-name) (when (!= server -1) (enter-secure-mode server) (client-remote-eval* server (quasiquote (new-account (unquote pseudo) (unquote name) (unquote passwd) (unquote email) (unquote agreed))) (lambda (msg) (set-message msg "creating new account") (when (== msg "done") (notify-account server-name pseudo passwd)) (client-stop server)))))))
    => cons <> cur-props <= ((quote client-new-account) #:arguments (quote (server-name pseudo name passwd email agreed)))
    => cons <> cur-props <= ((quote client-new-account) (quote (#:argument email)) (quote ("Email address")))
    => cur-props => (((quote client-new-account) (quote (#:argument email)) (quote ("Email address"))) ((quote client-new-account) #:arguments (quote (server-name pseudo name passwd email agreed))) ((quote client-new-account) (quote (#:argument agreed)) (quote ("Licence agreement"))) ((quote client-new-account) #:arguments (quote (server-name pseudo name passwd email agreed))))

  (define-option-argument opt decl)
    <= ((passwd "password" "Password") (tm-define-overloaded (client-new-account server-name pseudo name passwd email agreed) (with uid (pseudo->user pseudo) (when (== uid (get-default-user)) (when (== (get-user-info "name") "") (set-user-info "name" name)) (when (== (get-user-info "email") "") (set-user-info "email" email)))) (with server (client-start server-name) (when (!= server -1) (enter-secure-mode server) (client-remote-eval* server (quasiquote (new-account (unquote pseudo) (unquote name) (unquote passwd) (unquote email) (unquote agreed))) (lambda (msg) (set-message msg "creating new account") (when (== msg "done") (notify-account server-name pseudo passwd)) (client-stop server)))))))
    => cons <> cur-props <= ((quote client-new-account) #:arguments (quote (server-name pseudo name passwd email agreed)))
    => cons <> cur-props <= ((quote client-new-account) (quote (#:argument passwd)) (quote ("password" "Password")))
    => cur-props => (((quote client-new-account) (quote (#:argument passwd)) (quote ("password" "Password"))) ((quote client-new-account) #:arguments (quote (server-name pseudo name passwd email agreed))) ((quote client-new-account) (quote (#:argument email)) (quote ("Email address"))) ((quote client-new-account) #:arguments (quote (server-name pseudo name passwd email agreed))) ((quote client-new-account) (quote (#:argument agreed)) (quote ("Licence agreement"))) ((quote client-new-account) #:arguments (quote (server-name pseudo name passwd email agreed))))

  (define-option-argument opt decl)
    <= ((name "Full name") (tm-define-overloaded (client-new-account server-name pseudo name passwd email agreed) (with uid (pseudo->user pseudo) (when (== uid (get-default-user)) (when (== (get-user-info "name") "") (set-user-info "name" name)) (when (== (get-user-info "email") "") (set-user-info "email" email)))) (with server (client-start server-name) (when (!= server -1) (enter-secure-mode server) (client-remote-eval* server (quasiquote (new-account (unquote pseudo) (unquote name) (unquote passwd) (unquote email) (unquote agreed))) (lambda (msg) (set-message msg "creating new account") (when (== msg "done") (notify-account server-name pseudo passwd)) (client-stop server)))))))
    => cons <> cur-props <= ((quote client-new-account) #:arguments (quote (server-name pseudo name passwd email agreed)))
    => cons <> cur-props <= ((quote client-new-account) (quote (#:argument name)) (quote ("Full name")))
    => cur-props => (((quote client-new-account) (quote (#:argument name)) (quote ("Full name"))) ((quote client-new-account) #:arguments (quote (server-name pseudo name passwd email agreed))) ((quote client-new-account) (quote (#:argument passwd)) (quote ("password" "Password"))) ((quote client-new-account) #:arguments (quote (server-name pseudo name passwd email agreed))) ((quote client-new-account) (quote (#:argument email)) (quote ("Email address"))) ((quote client-new-account) #:arguments (quote (server-name pseudo name passwd email agreed))) ((quote client-new-account) (quote (#:argument agreed)) (quote ("Licence agreement"))) ((quote client-new-account) #:arguments (quote (server-name pseudo name passwd email agreed))))

  (define-option-argument opt decl)
    <= ((pseudo "User pseudo") (tm-define-overloaded (client-new-account server-name pseudo name passwd email agreed) (with uid (pseudo->user pseudo) (when (== uid (get-default-user)) (when (== (get-user-info "name") "") (set-user-info "name" name)) (when (== (get-user-info "email") "") (set-user-info "email" email)))) (with server (client-start server-name) (when (!= server -1) (enter-secure-mode server) (client-remote-eval* server (quasiquote (new-account (unquote pseudo) (unquote name) (unquote passwd) (unquote email) (unquote agreed))) (lambda (msg) (set-message msg "creating new account") (when (== msg "done") (notify-account server-name pseudo passwd)) (client-stop server)))))))
    => cons <> cur-props <= ((quote client-new-account) #:arguments (quote (server-name pseudo name passwd email agreed)))
    => cons <> cur-props <= ((quote client-new-account) (quote (#:argument pseudo)) (quote ("User pseudo")))
    => cur-props => (((quote client-new-account) (quote (#:argument pseudo)) (quote ("User pseudo"))) ((quote client-new-account) #:arguments (quote (server-name pseudo name passwd email agreed))) ((quote client-new-account) (quote (#:argument name)) (quote ("Full name"))) ((quote client-new-account) #:arguments (quote (server-name pseudo name passwd email agreed))) ((quote client-new-account) (quote (#:argument passwd)) (quote ("password" "Password"))) ((quote client-new-account) #:arguments (quote (server-name pseudo name passwd email agreed))) ((quote client-new-account) (quote (#:argument email)) (quote ("Email address"))) ((quote client-new-account) #:arguments (quote (server-name pseudo name passwd email agreed))) ((quote client-new-account) (quote (#:argument agreed)) (quote ("Licence agreement"))) ((quote client-new-account) #:arguments (quote (server-name pseudo name passwd email agreed))))

  (define-option-argument opt decl)
    <= ((server-name "Server") (tm-define-overloaded (client-new-account server-name pseudo name passwd email agreed) (with uid (pseudo->user pseudo) (when (== uid (get-default-user)) (when (== (get-user-info "name") "") (set-user-info "name" name)) (when (== (get-user-info "email") "") (set-user-info "email" email)))) (with server (client-start server-name) (when (!= server -1) (enter-secure-mode server) (client-remote-eval* server (quasiquote (new-account (unquote pseudo) (unquote name) (unquote passwd) (unquote email) (unquote agreed))) (lambda (msg) (set-message msg "creating new account") (when (== msg "done") (notify-account server-name pseudo passwd)) (client-stop server)))))))
    => cons <> cur-props <= ((quote client-new-account) #:arguments (quote (server-name pseudo name passwd email agreed)))
    => cons <> cur-props <= ((quote client-new-account) (quote (#:argument server-name)) (quote ("Server")))
    => cur-props => (((quote client-new-account) (quote (#:argument server-name)) (quote ("Server"))) ((quote client-new-account) #:arguments (quote (server-name pseudo name passwd email agreed))) ((quote client-new-account) (quote (#:argument pseudo)) (quote ("User pseudo"))) ((quote client-new-account) #:arguments (quote (server-name pseudo name passwd email agreed))) ((quote client-new-account) (quote (#:argument name)) (quote ("Full name"))) ((quote client-new-account) #:arguments (quote (server-name pseudo name passwd email agreed))) ((quote client-new-account) (quote (#:argument passwd)) (quote ("password" "Password"))) ((quote client-new-account) #:arguments (quote (server-name pseudo name passwd email agreed))) ((quote client-new-account) (quote (#:argument email)) (quote ("Email address"))) ((quote client-new-account) #:arguments (quote (server-name pseudo name passwd email agreed))) ((quote client-new-account) (quote (#:argument agreed)) (quote ("Licence agreement"))) ((quote client-new-account) #:arguments (quote (server-name pseudo name passwd email agreed))))

(property-set! var prop what conds*)
  <= (client-new-account (#:argument server-name) ("Server") ())

(property-set! var prop what conds*)
  <= (client-new-account #:arguments (server-name pseudo name passwd email agreed) ())

(property-set! var prop what conds*)
  <= (client-new-account (#:argument pseudo) ("User pseudo") ())

(property-set! var prop what conds*)
  <= (client-new-account #:arguments (server-name pseudo name passwd email agreed) ())

(property-set! var prop what conds*)
  <= (client-new-account (#:argument name) ("Full name") ())

(property-set! var prop what conds*)
  <= (client-new-account #:arguments (server-name pseudo name passwd email agreed) ())

(property-set! var prop what conds*)
  <= (client-new-account (#:argument passwd) ("password" "Password") ())

(property-set! var prop what conds*)
  <= (client-new-account #:arguments (server-name pseudo name passwd email agreed) ())

(property-set! var prop what conds*)
  <= (client-new-account (#:argument email) ("Email address") ())

(property-set! var prop what conds*)
  <= (client-new-account #:arguments (server-name pseudo name passwd email agreed) ())

(property-set! var prop what conds*)
  <= (client-new-account (#:argument agreed) ("Licence agreement") ())

(property-set! var prop what conds*)
  <= (client-new-account #:arguments (server-name pseudo name passwd email agreed) ())

  (define-option-argument opt decl)
    <= ((passwd "password" "Password") (tm-define-overloaded (client-login server-name pseudo passwd) (client-login-then server-name pseudo passwd (lambda (ret) (set-message ret "logging in")))))
    => cons <> cur-props <= ((quote client-login) #:arguments (quote (server-name pseudo passwd)))
    => cons <> cur-props <= ((quote client-login) (quote (#:argument passwd)) (quote ("password" "Password")))
    => cur-props => (((quote client-login) (quote (#:argument passwd)) (quote ("password" "Password"))) ((quote client-login) #:arguments (quote (server-name pseudo passwd))))

  (define-option-argument opt decl)
    <= ((pseudo "User pseudo") (tm-define-overloaded (client-login server-name pseudo passwd) (client-login-then server-name pseudo passwd (lambda (ret) (set-message ret "logging in")))))
    => cons <> cur-props <= ((quote client-login) #:arguments (quote (server-name pseudo passwd)))
    => cons <> cur-props <= ((quote client-login) (quote (#:argument pseudo)) (quote ("User pseudo")))
    => cur-props => (((quote client-login) (quote (#:argument pseudo)) (quote ("User pseudo"))) ((quote client-login) #:arguments (quote (server-name pseudo passwd))) ((quote client-login) (quote (#:argument passwd)) (quote ("password" "Password"))) ((quote client-login) #:arguments (quote (server-name pseudo passwd))))

  (define-option-argument opt decl)
    <= ((server-name "Server") (tm-define-overloaded (client-login server-name pseudo passwd) (client-login-then server-name pseudo passwd (lambda (ret) (set-message ret "logging in")))))
    => cons <> cur-props <= ((quote client-login) #:arguments (quote (server-name pseudo passwd)))
    => cons <> cur-props <= ((quote client-login) (quote (#:argument server-name)) (quote ("Server")))
    => cur-props => (((quote client-login) (quote (#:argument server-name)) (quote ("Server"))) ((quote client-login) #:arguments (quote (server-name pseudo passwd))) ((quote client-login) (quote (#:argument pseudo)) (quote ("User pseudo"))) ((quote client-login) #:arguments (quote (server-name pseudo passwd))) ((quote client-login) (quote (#:argument passwd)) (quote ("password" "Password"))) ((quote client-login) #:arguments (quote (server-name pseudo passwd))))

(property-set! var prop what conds*)
  <= (client-login (#:argument server-name) ("Server") ())

(property-set! var prop what conds*)
  <= (client-login #:arguments (server-name pseudo passwd) ())

(property-set! var prop what conds*)
  <= (client-login (#:argument pseudo) ("User pseudo") ())

(property-set! var prop what conds*)
  <= (client-login #:arguments (server-name pseudo passwd) ())

(property-set! var prop what conds*)
  <= (client-login (#:argument passwd) ("password" "Password") ())

(property-set! var prop what conds*)
  <= (client-login #:arguments (server-name pseudo passwd) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (version-interactive-update name) (save-buffer name #:update)))
    => ((quote version-interactive-update) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote version-interactive-update) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (version-interactive-update #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (version-interactive-commit name) (save-buffer name #:commit)))
    => ((quote version-interactive-commit) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote version-interactive-commit) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (version-interactive-commit #:interactive (#t) ())

  (define-option-require opt decl)
    <= (((== (version-tool name) "wrap")) (tm-define-overloaded (version-status name) (version-status (url-wrap name))))
    => (define-option-match opt decl) <= ((lambda (name) (== (version-tool name) "wrap")) (tm-define-overloaded (version-status name) (version-status (url-wrap name))))

  (define-option-require opt decl)
    <= (((== (version-tool name) "wrap")) (tm-define-overloaded (version-history name) (version-history (url-wrap name))))
    => (define-option-match opt decl) <= ((lambda (name) (== (version-tool name) "wrap")) (tm-define-overloaded (version-history name) (version-history (url-wrap name))))

  (define-option-require opt decl)
    <= (((== (version-tool name) "wrap")) (tm-define-overloaded (version-revision name rev) (version-revision (url-wrap name) rev)))
    => (define-option-match opt decl) <= ((lambda (name rev) (== (version-tool name) "wrap")) (tm-define-overloaded (version-revision name rev) (version-revision (url-wrap name) rev)))

  (define-option-require opt decl)
    <= (((== (version-tool name) "wrap")) (tm-define-overloaded (version-update name) (version-update (url-wrap name))))
    => (define-option-match opt decl) <= ((lambda (name) (== (version-tool name) "wrap")) (tm-define-overloaded (version-update name) (version-update (url-wrap name))))

  (define-option-require opt decl)
    <= (((== (version-tool name) "wrap")) (tm-define-overloaded (version-register name) (version-register (url-wrap name))))
    => (define-option-match opt decl) <= ((lambda (name) (== (version-tool name) "wrap")) (tm-define-overloaded (version-register name) (version-register (url-wrap name))))

  (define-option-require opt decl)
    <= (((== (version-tool name) "wrap")) (tm-define-overloaded (version-commit name msg) (version-commit (url-wrap name) msg)))
    => (define-option-match opt decl) <= ((lambda (name msg) (== (version-tool name) "wrap")) (tm-define-overloaded (version-commit name msg) (version-commit (url-wrap name) msg)))

  (define-option-require opt decl)
    <= (((url-wrap u)) (tm-define-overloaded (version-revision-url u rev) (version-revision-url (url-wrap u) rev)))
    => (define-option-match opt decl) <= ((lambda (u rev) (url-wrap u)) (tm-define-overloaded (version-revision-url u rev) (version-revision-url (url-wrap u) rev)))

  (define-option-require opt decl)
    <= (((url-wrap u)) (tm-define-overloaded (version-revision? u) (version-revision? (url-wrap u))))
    => (define-option-match opt decl) <= ((lambda (u) (url-wrap u)) (tm-define-overloaded (version-revision? u) (version-revision? (url-wrap u))))

  (define-option-require opt decl)
    <= (((url-wrap u)) (tm-define-overloaded (version-head u) (version-head (url-wrap u))))
    => (define-option-match opt decl) <= ((lambda (u) (url-wrap u)) (tm-define-overloaded (version-head u) (version-head (url-wrap u))))

  (define-option-require opt decl)
    <= (((url-rooted-tmfs-protocol? u "part")) (tm-define-overloaded (version-revision-url u rev) (import-from (part part-tmfs)) (let* ((name (part-open-name u)) (m (part-master name)) (f (part-file name))) (part-url (version-revision-url m rev) (version-revision-url f rev)))))
    => (define-option-match opt decl) <= ((lambda (u rev) (url-rooted-tmfs-protocol? u "part")) (tm-define-overloaded (version-revision-url u rev) (import-from (part part-tmfs)) (let* ((name (part-open-name u)) (m (part-master name)) (f (part-file name))) (part-url (version-revision-url m rev) (version-revision-url f rev)))))

  (define-option-require opt decl)
    <= (((url-rooted-tmfs-protocol? u "part")) (tm-define-overloaded (version-head u) (import-from (part part-tmfs)) (let* ((name (part-open-name u)) (m (part-master name)) (f (part-file name))) (part-url (version-head m) (version-head f)))))
    => (define-option-match opt decl) <= ((lambda (u) (url-rooted-tmfs-protocol? u "part")) (tm-define-overloaded (version-head u) (import-from (part part-tmfs)) (let* ((name (part-open-name u)) (m (part-master name)) (f (part-file name))) (part-url (version-head m) (version-head f)))))

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (remote-create-file-interactive server) (interactive (lambda (name) (with fname (prepend-dir server name "remote-file") (remote-create-file server fname (empty-document)))) (list "Name" "string" (quote ())))))
    => ((quote remote-create-file-interactive) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote remote-create-file-interactive) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (remote-create-file-interactive #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (remote-create-dir-interactive server) (interactive (lambda (name) (with fname (prepend-dir server name "remote-dir") (remote-create-dir server fname))) (list "Name" "string" (quote ())))))
    => ((quote remote-create-dir-interactive) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote remote-create-dir-interactive) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (remote-create-dir-interactive #:interactive (#t) ())

  (define-option-require opt decl)
    <= (((remote-file? name)) (tm-define-overloaded (versioned? name) #t))
    => (define-option-match opt decl) <= ((lambda (name) (remote-file? name)) (tm-define-overloaded (versioned? name) #t))

  (define-option-require opt decl)
    <= (((remote-file? name)) (tm-define-overloaded (version-status name) (if (buffer-modified? name) "modified" "unmodified")))
    => (define-option-match opt decl) <= ((lambda (name) (remote-file? name)) (tm-define-overloaded (version-status name) (if (buffer-modified? name) "modified" "unmodified")))

  (define-option-require opt decl)
    <= (((remote-file? u)) (tm-define-overloaded (version-history u) (compute-remote-versions u) (list)))
    => (define-option-match opt decl) <= ((lambda (u) (remote-file? u)) (tm-define-overloaded (version-history u) (compute-remote-versions u) (list)))

  (define-option-require opt decl)
    <= (((remote-file? name)) (tm-define-overloaded (update-buffer name) (revert-buffer name)))
    => (define-option-match opt decl) <= ((lambda (name) (remote-file? name)) (tm-define-overloaded (update-buffer name) (revert-buffer name)))

  (define-option-require opt decl)
    <= (((remote-file? name)) (tm-define-overloaded (commit-buffer-message name msg) (with-global remote-commit-message msg (save-buffer name))))
    => (define-option-match opt decl) <= ((lambda (name msg) (remote-file? name)) (tm-define-overloaded (commit-buffer-message name msg) (with-global remote-commit-message msg (save-buffer name))))

  (define-option-require opt decl)
    <= (((remote-file? name)) (tm-define-overloaded (version-interactive-commit name) (commit-buffer name)))
    => (define-option-match opt decl) <= ((lambda (name) (remote-file? name)) (tm-define-overloaded (version-interactive-commit name) (commit-buffer name)))

  (define-option-require opt decl)
    <= (((remote-file? name)) (tm-define-overloaded (version-revision? name) (nin? (remote-get-time name) (list #f #:now))))
    => (define-option-match opt decl) <= ((lambda (name) (remote-file? name)) (tm-define-overloaded (version-revision? name) (nin? (remote-get-time name) (list #f #:now))))

  (define-option-require opt decl)
    <= (((remote-file? name)) (tm-define-overloaded (version-head name) (string->url (remote-strip-time name))))
    => (define-option-match opt decl) <= ((lambda (name) (remote-file? name)) (tm-define-overloaded (version-head name) (string->url (remote-strip-time name))))

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (open-error s) (dialogue-window (error-widget s) noop "Error")))
    => ((quote open-error) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-error) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-error #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (open-remote-account-creator) (dialogue-window remote-account-widget noop "Create remote account")))
    => ((quote open-remote-account-creator) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-remote-account-creator) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-remote-account-creator #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (open-remote-login server-name pseudo) (with-wallet (with passwd (wallet-get (list "remote" server-name pseudo)) (if passwd (client-login-home server-name pseudo passwd) (dialogue-window (remote-login-widget server-name pseudo #f) noop "Remote login"))))))
    => ((quote open-remote-login) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-remote-login) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-remote-login #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (open-remote-file-browser server initial type title cmd) (dialogue-window (remote-file-browser server initial type) cmd title)))
    => ((quote open-remote-file-browser) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-remote-file-browser) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-remote-file-browser #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (remote-rename-interactive server) (with dir? (remote-directory? (current-buffer)) (open-remote-file-browser server (current-buffer) (list (if dir? #:save-directory #:save-file) "Rename as:") (if dir? "Rename directory" "Rename file") (lambda (new-name) (when (url? new-name) (remote-rename (current-buffer) new-name)))))))
    => ((quote remote-rename-interactive) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote remote-rename-interactive) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (remote-rename-interactive #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (remote-remove-interactive server) (with msg (if (remote-directory? (current-buffer)) "Really remove directory and its recursive contents?" "Really remove file?") (user-confirm msg #f (lambda (answ) (when answ (remote-remove (current-buffer))))))))
    => ((quote remote-remove-interactive) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote remote-remove-interactive) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (remote-remove-interactive #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (open-entry-permissions-editor server id attrs) (with-remote-search-user users server (list) (let* ((perms (make-ahash-table)) (enc (make-ahash-table)) (dec (make-ahash-table))) (with-remote-get-entry entry server id (for (attr attrs) (with vals (or (assoc-ref entry attr) (list)) (ahash-set! perms attr vals) (set! users (list-union users vals)))) (with-remote-get-user-pseudo pseudos server users (with-remote-get-user-name names server users (ahash-set! dec "all" "all") (ahash-set! enc "all" "all") (for-each (lambda (user pseudo name) (when (and (string? pseudo) (string? name)) (with full (string-append pseudo " (" name ")") (ahash-set! dec user full) (ahash-set! enc full user)))) users pseudos names) (set! users (list-difference users (list "all"))) (dialogue-window (entry-permissions-editor server id attrs users enc dec perms) noop "Change permissions"))))))))
    => ((quote open-entry-permissions-editor) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-entry-permissions-editor) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-entry-permissions-editor #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (open-file-permissions-editor server u) (with-remote-identifier rid server u (when rid (with attrs (list "readable" "writable" "owner") (open-entry-permissions-editor server rid attrs))))))
    => ((quote open-file-permissions-editor) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-file-permissions-editor) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-file-permissions-editor #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (open-sync-widget server l dbl ltime rtime) (if (and (null? l) (null? dbl)) (begin (set-message "up to date" "synchronize with remote server") (show-message "Local client is in sync with the remote server" "Synchronize with remote server")) (dialogue-window (client-sync-widget server l dbl ltime rtime) noop "Synchronization status"))))
    => ((quote open-sync-widget) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-sync-widget) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-sync-widget #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (remote-interactive-sync server) (dialogue-window (client-auto-sync-widget server) noop "Synchronize with remote server")))
    => ((quote remote-interactive-sync) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote remote-interactive-sync) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (remote-interactive-sync #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (remote-interactive-upload server) (dialogue-window (upload-widget server) noop "Upload file or directory")))
    => ((quote remote-interactive-upload) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote remote-interactive-upload) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (remote-interactive-upload #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (remote-interactive-download server) (dialogue-window (download-widget server) noop "Download file or directory")))
    => ((quote remote-interactive-download) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote remote-interactive-download) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (remote-interactive-download #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" test-locus-rendering?) (tm-define-overloaded (change-locus-rendering var val) (set-locus-rendering var val) (update-all-buffers)))
    => ((quote change-locus-rendering) #:check-mark (list "v" test-locus-rendering?))
 => cons <> cur-props
    => cur-props => (((quote change-locus-rendering) #:check-mark (list "v" test-locus-rendering?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Change global locus rendering property @var to @val.") (tm-define-overloaded (change-locus-rendering var val) (set-locus-rendering var val) (update-all-buffers)))
   => ((quote change-locus-rendering) #:synopsis (quote ("Change global locus rendering property @var to @val.")))
 => cons <> cur-props
   => cur-props => (((quote change-locus-rendering) #:synopsis (quote ("Change global locus rendering property @var to @val."))) ((quote change-locus-rendering) #:check-mark (list "v" test-locus-rendering?)))

(property-set! var prop what conds*)
  <= (change-locus-rendering #:synopsis ("Change global locus rendering property @var to @val.") ())

(property-set! var prop what conds*)
  <= (change-locus-rendering #:check-mark ("v" #<procedure test-locus-rendering? (var val)>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" test-locus-preserve-on-paper?) (tm-define-overloaded (toggle-locus-preserve-on-paper) (with val (if (test-locus-preserve-on-paper?) "change" "preserve") (change-locus-rendering "locus-on-paper" val))))
    => ((quote toggle-locus-preserve-on-paper) #:check-mark (list "v" test-locus-preserve-on-paper?))
 => cons <> cur-props
    => cur-props => (((quote toggle-locus-preserve-on-paper) #:check-mark (list "v" test-locus-preserve-on-paper?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle whether loci are colored when rendering on paper.") (tm-define-overloaded (toggle-locus-preserve-on-paper) (with val (if (test-locus-preserve-on-paper?) "change" "preserve") (change-locus-rendering "locus-on-paper" val))))
   => ((quote toggle-locus-preserve-on-paper) #:synopsis (quote ("Toggle whether loci are colored when rendering on paper.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-locus-preserve-on-paper) #:synopsis (quote ("Toggle whether loci are colored when rendering on paper."))) ((quote toggle-locus-preserve-on-paper) #:check-mark (list "v" test-locus-preserve-on-paper?)))

(property-set! var prop what conds*)
  <= (toggle-locus-preserve-on-paper #:synopsis ("Toggle whether loci are colored when rendering on paper.") ())

(property-set! var prop what conds*)
  <= (toggle-locus-preserve-on-paper #:check-mark ("v" #<procedure test-locus-preserve-on-paper? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (interactive-change-locus-rendering var) (interactive (lambda (val) (change-locus-rendering var val)) (list (logic-ref env-var-description% var) "string" (get-locus-rendering var)))))
    => ((quote interactive-change-locus-rendering) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote interactive-change-locus-rendering) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (interactive-change-locus-rendering #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" debug-backtrace-errors?) (tm-define-overloaded (debug-toggle-backtrace-errors) (if (debug-backtrace-errors?) (debug-disable (quote backtrace) (quote debug)) (debug-enable (quote backtrace) (quote debug)))))
    => ((quote debug-toggle-backtrace-errors) #:check-mark (list "v" debug-backtrace-errors?))
 => cons <> cur-props
    => cur-props => (((quote debug-toggle-backtrace-errors) #:check-mark (list "v" debug-backtrace-errors?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle scheme backtracing of errors.") (tm-define-overloaded (debug-toggle-backtrace-errors) (if (debug-backtrace-errors?) (debug-disable (quote backtrace) (quote debug)) (debug-enable (quote backtrace) (quote debug)))))
   => ((quote debug-toggle-backtrace-errors) #:synopsis (quote ("Toggle scheme backtracing of errors.")))
 => cons <> cur-props
   => cur-props => (((quote debug-toggle-backtrace-errors) #:synopsis (quote ("Toggle scheme backtracing of errors."))) ((quote debug-toggle-backtrace-errors) #:check-mark (list "v" debug-backtrace-errors?)))

(property-set! var prop what conds*)
  <= (debug-toggle-backtrace-errors #:synopsis ("Toggle scheme backtracing of errors.") ())

(property-set! var prop what conds*)
  <= (debug-toggle-backtrace-errors #:check-mark ("v" #<procedure debug-backtrace-errors? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" debug-get) (tm-define-overloaded (debug-toggle s) (debug-set s (not (debug-get s)))))
    => ((quote debug-toggle) #:check-mark (list "v" debug-get))
 => cons <> cur-props
    => cur-props => (((quote debug-toggle) #:check-mark (list "v" debug-get)))

(property-set! var prop what conds*)
  <= (debug-toggle #:check-mark ("v" #<primitive-procedure debug-get>) ())

  (define-option-require opt decl)
    <= (((in-prog-scheme?)) (tm-define-overloaded (texmacs-alternative-popup-menu) (menu-dynamic (-> "File" (link file-menu)) (-> "Edit" (link edit-menu)) (-> "View" (link view-menu)) (-> "Go" (link go-menu)) (if (detailed-menus?) (-> "Tools" (link tools-menu))) (if (with-remote-tool?) (-> "Remote" (link remote-menu))) (if (with-debugging-tool?) (-> "Debug" (link debug-menu))) (if (nnull? (test-menu)) (-> "Test" (link test-menu))) (-> "Scheme" (link scheme-menu)) --- (-> "Help" (link help-menu)))))
    => (define-option-match opt decl) <= ((lambda () (in-prog-scheme?)) (tm-define-overloaded (texmacs-alternative-popup-menu) (menu-dynamic (-> "File" (link file-menu)) (-> "Edit" (link edit-menu)) (-> "View" (link view-menu)) (-> "Go" (link go-menu)) (if (detailed-menus?) (-> "Tools" (link tools-menu))) (if (with-remote-tool?) (-> "Remote" (link remote-menu))) (if (with-debugging-tool?) (-> "Debug" (link debug-menu))) (if (nnull? (test-menu)) (-> "Test" (link test-menu))) (-> "Scheme" (link scheme-menu)) --- (-> "Help" (link help-menu)))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (doc-module-synopsis tname) (quasiquote (concat (unquote (string-append "synopsis for " (tree->string tname)))))))
    => ((quote doc-module-synopsis) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote doc-module-synopsis) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (doc-module-synopsis #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (doc-module-family tname) (quasiquote (concat (unquote (module->string (cDr (string->module (tree->string tname)))))))))
    => ((quote doc-module-family) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote doc-module-family) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (doc-module-family #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (doc-module-dependencies tname) ($module-dependencies (string->module (tree->string tname)))))
    => ((quote doc-module-dependencies) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote doc-module-dependencies) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (doc-module-dependencies #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (doc-module-source-link tname) ($module-source-link (string->module (tree->string tname)))))
    => ((quote doc-module-source-link) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote doc-module-source-link) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (doc-module-source-link #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (doc-module-doc-link tname) ($module-doc-link (string->module (tree->string tname)))))
    => ((quote doc-module-doc-link) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote doc-module-doc-link) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (doc-module-doc-link #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (doc-module-count-exported tname) (number->string (module-count-exported (string->module (tree->string tname))))))
    => ((quote doc-module-count-exported) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote doc-module-count-exported) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (doc-module-count-exported #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (doc-module-count-undocumented tname) (number->string (module-count-undocumented (string->module (tree->string tname))))))
    => ((quote doc-module-count-undocumented) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote doc-module-count-undocumented) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (doc-module-count-undocumented #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (doc-module-traverse troot) ($doc-module-traverse (string->module (tree->string troot)))))
    => ((quote doc-module-traverse) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote doc-module-traverse) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (doc-module-traverse #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (doc-symbol-symbol tsym) (tree->string tsym)))
    => ((quote doc-symbol-symbol) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote doc-symbol-symbol) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (doc-symbol-symbol #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (doc-symbol-synopsis tsym) (doc-symbol-synopsis* (tree->symbol tsym))))
    => ((quote doc-symbol-synopsis) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote doc-symbol-synopsis) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (doc-symbol-synopsis #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (doc-symbol-code tsym) (doc-symbol-code* (tree->symbol tsym))))
    => ((quote doc-symbol-code) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote doc-symbol-code) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (doc-symbol-code #:secure (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (doc-symbol-template tsym) ($doc-symbol-template (tree->symbol tsym) #t "")))
    => ((quote doc-symbol-template) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote doc-symbol-template) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (doc-symbol-template #:secure (#t) ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Opens a help buffer with a list of all tm-defined symbols") (tm-define-overloaded (apidoc-all-symbols) (cursor-history-add (cursor-path)) (load-buffer "tmfs://apidoc/type=symbol&what=")))
   => ((quote apidoc-all-symbols) #:synopsis (quote ("Opens a help buffer with a list of all tm-defined symbols")))
 => cons <> cur-props
   => cur-props => (((quote apidoc-all-symbols) #:synopsis (quote ("Opens a help buffer with a list of all tm-defined symbols"))))

(property-set! var prop what conds*)
  <= (apidoc-all-symbols #:synopsis ("Opens a help buffer with a list of all tm-defined symbols") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Opens a help buffer with a list of all TeXmacs modules") (tm-define-overloaded (apidoc-all-modules) (cursor-history-add (cursor-path)) (load-buffer "tmfs://apidoc/type=module&what=")))
   => ((quote apidoc-all-modules) #:synopsis (quote ("Opens a help buffer with a list of all TeXmacs modules")))
 => cons <> cur-props
   => cur-props => (((quote apidoc-all-modules) #:synopsis (quote ("Opens a help buffer with a list of all TeXmacs modules"))))

(property-set! var prop what conds*)
  <= (apidoc-all-modules #:synopsis ("Opens a help buffer with a list of all TeXmacs modules") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Translate a string with arguments") (tm-define-overloaded (replace origstr . vals) (tm->stree (translate (stree->tree (quasiquote (replace (unquote origstr) (unquote-splicing (map reformat-arg vals)))))))))
   => ((quote replace) #:synopsis (quote ("Translate a string with arguments")))
 => cons <> cur-props
   => cur-props => (((quote replace) #:synopsis (quote ("Translate a string with arguments"))))

(property-set! var prop what conds*)
  <= (replace #:synopsis ("Translate a string with arguments") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Returns the path to the dictionary file for @language") (tm-define-overloaded (tr-file language) (url-concretize (string-append "$TEXMACS_PATH/langs/natural/dic/english-" language ".scm"))))
   => ((quote tr-file) #:synopsis (quote ("Returns the path to the dictionary file for @language")))
 => cons <> cur-props
   => cur-props => (((quote tr-file) #:synopsis (quote ("Returns the path to the dictionary file for @language"))))

(property-set! var prop what conds*)
  <= (tr-file #:synopsis ("Returns the path to the dictionary file for @language") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Rebuild translations file adding the missing ones (up to now)") (tm-define-overloaded (tr-rebuild language) (tr-parse language) (user-confirm (quasiquote (replace "This will overwrite the dictionary %1 with %2 entries. Are you sure?" (verbatim (unquote (tr-file language))) (unquote (ahash-size (tr-hash language))))) #f (lambda (answ) (if answ (begin (with-output-to-file (tr-file language) (lambda () (tr-write (map (lambda (str) (tr-match language str)) (tr-all language))))) (set-message (quasiquote (replace "Wrote file %1" (verbatim (unquote (tr-file language))))) "")) (set-message (quote (replace "Rebuild cancelled")) language))))))
   => ((quote tr-rebuild) #:synopsis (quote ("Rebuild translations file adding the missing ones (up to now)")))
 => cons <> cur-props
   => cur-props => (((quote tr-rebuild) #:synopsis (quote ("Rebuild translations file adding the missing ones (up to now)"))))

(property-set! var prop what conds*)
  <= (tr-rebuild #:synopsis ("Rebuild translations file adding the missing ones (up to now)") ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Translations missing in the dictionary (up to now)") (tm-define-overloaded (tr-missing language) (if (== 0 (ahash-size (tr-hash language))) (tr-parse language)) (list-fold (lambda (cur res) (if (or (ahash-ref (tr-hash language) cur) (ahash-ref (tr-hash language) (locase-all cur))) res (cons cur res))) (quote ()) (tr-current))))
   => ((quote tr-missing) #:synopsis (quote ("Translations missing in the dictionary (up to now)")))
 => cons <> cur-props
   => cur-props => (((quote tr-missing) #:synopsis (quote ("Translations missing in the dictionary (up to now)"))))

(property-set! var prop what conds*)
  <= (tr-missing #:synopsis ("Translations missing in the dictionary (up to now)") ())

  (define-option-require opt decl)
    <= (((or (in-asymptote?) (and (not-in-session?) (asymptote-scripts?)))) (tm-define-overloaded (plugin-menu) (menu-dynamic (=> "Asymptote" (link asymptote-functions-menu)))))
    => (define-option-match opt decl) <= ((lambda () (or (in-asymptote?) (and (not-in-session?) (asymptote-scripts?)))) (tm-define-overloaded (plugin-menu) (menu-dynamic (=> "Asymptote" (link asymptote-functions-menu)))))

  (define-option-require opt decl)
    <= (((== name "maxima")) (tm-define-overloaded (plugin-output-simplify name t) (if (func? t (quote document)) (with u (list-find (cdr t) maxima-contains-prompt?) (if u (maxima-output-simplify u) "")) (maxima-output-simplify t))))
    => (define-option-match opt decl) <= ((lambda (name t) (== name "maxima")) (tm-define-overloaded (plugin-output-simplify name t) (if (func? t (quote document)) (with u (list-find (cdr t) maxima-contains-prompt?) (if u (maxima-output-simplify u) "")) (maxima-output-simplify t))))

  (define-option-require opt decl)
    <= (((and (in-maxima?) (in-session?))) (tm-define-overloaded (session-help-icons) (menu-dynamic (link maxima-help-icons))))
    => (define-option-match opt decl) <= ((lambda () (and (in-maxima?) (in-session?))) (tm-define-overloaded (session-help-icons) (menu-dynamic (link maxima-help-icons))))

  (define-option-require opt decl)
    <= (((or (in-maxima?) (and (not-in-session?) (maxima-scripts?)))) (tm-define-overloaded (plugin-menu) (menu-dynamic (=> "Maxima" (link maxima-menu)))))
    => (define-option-match opt decl) <= ((lambda () (or (in-maxima?) (and (not-in-session?) (maxima-scripts?)))) (tm-define-overloaded (plugin-menu) (menu-dynamic (=> "Maxima" (link maxima-menu)))))

  (define-option-require opt decl)
    <= (((and (in-python?) (in-session?))) (tm-define-overloaded (session-help-icons) (menu-dynamic / ((balloon (icon "tm_help.xpm") "Python plugin help") (load-help-article "python")))))
    => (define-option-match opt decl) <= ((lambda () (and (in-python?) (in-session?))) (tm-define-overloaded (session-help-icons) (menu-dynamic / ((balloon (icon "tm_help.xpm") "Python plugin help") (load-help-article "python")))))

  (define-option-require opt decl)
    <= (((in-r?)) (tm-define-overloaded (plugin-menu) (menu-dynamic (=> "R" (link r-menu)))))
    => (define-option-match opt decl) <= ((lambda () (in-r?)) (tm-define-overloaded (plugin-menu) (menu-dynamic (=> "R" (link r-menu)))))

  ((define-property* which)  opt decl)
    <= ((#:secure)  (#t) (tm-define-overloaded (scilab-verbatim->tree t) (let* ((t (tree->stree t)) (s (if (string? t) t "")) (s (string-replace s "\\\\\\\\" "\\")) (s (string-replace s "<gtr>" ">")) (s (string-replace s "<less>" "<")) (s (convert s "verbatim-snippet" "stm-snippet")) (s (string-replace s "\\\\" "\\"))) (stree->tree (string->object s)))))
    => ((quote scilab-verbatim->tree) #:secure (list #t))
 => cons <> cur-props
    => cur-props => (((quote scilab-verbatim->tree) #:secure (list #t)))

(property-set! var prop what conds*)
  <= (scilab-verbatim->tree #:secure (#t) ())

  (define-option-require opt decl)
    <= (((in-tm-zotero-style?)) (tm-define-overloaded (update-document what) (delayed (#:idle 1) (cursor-after (cond ((or (== what "all") (== what "bibliography")) (tm-zotero-refresh) (wait-update-current-buffer))) (former what)))))
    => (define-option-match opt decl) <= ((lambda (what) (in-tm-zotero-style?)) (tm-define-overloaded (update-document what) (delayed (#:idle 1) (cursor-after (cond ((or (== what "all") (== what "bibliography")) (tm-zotero-refresh) (wait-update-current-buffer))) (former what)))))

  (define-option-require opt decl)
    <= (((in-tm-zotero-style?)) (tm-define-overloaded (buffer-set-part-mode mode) (clear-<document-data>! (get-documentID)) (former mode) (wait-update-current-buffer)))
    => (define-option-match opt decl) <= ((lambda (mode) (in-tm-zotero-style?)) (tm-define-overloaded (buffer-set-part-mode mode) (clear-<document-data>! (get-documentID)) (former mode) (wait-update-current-buffer)))

  (define-option-require opt decl)
    <= (((and (in-tm-zotero-style?) (is-zfield? zfield))) (tm-define-overloaded (notify-activated zfield) (tm-zotero-set-message "zcite reactivated! Checking for modification...") (let* ((documentID (get-documentID)) (dd (get-<document-data> documentID)) (zfieldID (zfield-zfieldID zfield)) (zfd (hash-ref documentID+zfieldID-><zfield-data>-ht (string-append documentID zfieldID))) (origText (zfd-Code-code-properties-plainCitation zfd)) (newText (zfield-Text zfield)) (is-modified? (if (string=? newText origText) "false" "true"))) (set! (zfield-Code-is-modified?-flag zfield) is-modified?) (tm-zotero-set-message (string-append "zcite reactivated! Checking for modification... is-modified? => " is-modified? ". Done.")) (enqueue-delayed-integration-commands documentID (list zfield) tm-zotero-affirmCitation)) #t))
    => (define-option-match opt decl) <= ((lambda (zfield) (and (in-tm-zotero-style?) (is-zfield? zfield))) (tm-define-overloaded (notify-activated zfield) (tm-zotero-set-message "zcite reactivated! Checking for modification...") (let* ((documentID (get-documentID)) (dd (get-<document-data> documentID)) (zfieldID (zfield-zfieldID zfield)) (zfd (hash-ref documentID+zfieldID-><zfield-data>-ht (string-append documentID zfieldID))) (origText (zfd-Code-code-properties-plainCitation zfd)) (newText (zfield-Text zfield)) (is-modified? (if (string=? newText origText) "false" "true"))) (set! (zfield-Code-is-modified?-flag zfield) is-modified?) (tm-zotero-set-message (string-append "zcite reactivated! Checking for modification... is-modified? => " is-modified? ". Done.")) (enqueue-delayed-integration-commands documentID (list zfield) tm-zotero-affirmCitation)) #t))

  ((define-property* which)  opt decl)
    <= ((#:secure)  () (tm-define-overloaded (toggle-focus-zcite-suppress-trailing-punctuation . ign) (when (and (in-tm-zotero-style?) (focus-is-zcite?)) (toggle-zfield-suppress-trailing-punctuation (focus-tree)))))
    => ((quote toggle-focus-zcite-suppress-trailing-punctuation) #:secure (list))
 => cons <> cur-props
    => cur-props => (((quote toggle-focus-zcite-suppress-trailing-punctuation) #:secure (list)))

(property-set! var prop what conds*)
  <= (toggle-focus-zcite-suppress-trailing-punctuation #:secure () ())

  (define-option-require opt decl)
    <= (((and (in-tm-zotero-style?) (not (is-during-tm-zotero-clipboard-cut?)) (has-zfield? (selection-tree)))) (tm-define-overloaded (clipboard-copy which) (with-fluids ((fluid/is-during-tm-zotero-clipboard-cut? #t)) (let* ((selection-t (selection-tree)) (documentID (get-documentID)) (dd (get-<document-data> documentID)) (zfd-ls (document-zfield-zfd-ls dd)) (zb-zfd-ls (document-zbibliography-zfd-ls dd)) (new-zfield-zfd (document-new-zfield-zfd dd)) (copy-t (tree-copy selection-t)) (c-zfields (tm-search copy-t is-zfield?))) (map (lambda (zfield) (let* ((zfieldID (zfield-zfieldID zfield)) (zfd (hash-ref documentID+zfieldID-><zfield-data>-ht (string-append documentID zfieldID)))) (cond ((and zfd (not (eq? zfd new-zfield-zfd))) (unintern-ztHrefFromCiteToBib-for-cut documentID zfield)) (zfd (let ((tp (tree-pointer zfd))) (tm-zotero-format-error "_BOLD__RED_clipboard-copy_RESET_: _RED_Copying new zfield!_RESET_ _BOLD__RED_Fixme:_RESET_ Probably protocol breakdown; Restart Firefox and TeXmacs.") (tree-assign! zfield (stree->tree (quote (strong "{?? New Citation ??}")))) (clear-tree-pointer zfd) (set! (document-new-zfield-zfd dd) #f)))))) c-zfields) (clipboard-set which copy-t)))))
    => (define-option-match opt decl) <= ((lambda (which) (and (in-tm-zotero-style?) (not (is-during-tm-zotero-clipboard-cut?)) (has-zfield? (selection-tree)))) (tm-define-overloaded (clipboard-copy which) (with-fluids ((fluid/is-during-tm-zotero-clipboard-cut? #t)) (let* ((selection-t (selection-tree)) (documentID (get-documentID)) (dd (get-<document-data> documentID)) (zfd-ls (document-zfield-zfd-ls dd)) (zb-zfd-ls (document-zbibliography-zfd-ls dd)) (new-zfield-zfd (document-new-zfield-zfd dd)) (copy-t (tree-copy selection-t)) (c-zfields (tm-search copy-t is-zfield?))) (map (lambda (zfield) (let* ((zfieldID (zfield-zfieldID zfield)) (zfd (hash-ref documentID+zfieldID-><zfield-data>-ht (string-append documentID zfieldID)))) (cond ((and zfd (not (eq? zfd new-zfield-zfd))) (unintern-ztHrefFromCiteToBib-for-cut documentID zfield)) (zfd (let ((tp (tree-pointer zfd))) (tm-zotero-format-error "_BOLD__RED_clipboard-copy_RESET_: _RED_Copying new zfield!_RESET_ _BOLD__RED_Fixme:_RESET_ Probably protocol breakdown; Restart Firefox and TeXmacs.") (tree-assign! zfield (stree->tree (quote (strong "{?? New Citation ??}")))) (clear-tree-pointer zfd) (set! (document-new-zfield-zfd dd) #f)))))) c-zfields) (clipboard-set which copy-t)))))

  (define-option-require opt decl)
    <= (((and (in-tm-zotero-style?) (not (is-during-tm-zotero-clipboard-cut?)) (has-zfield? (selection-tree)))) (tm-define-overloaded (clipboard-cut which) (with-fluids ((fluid/is-during-tm-zotero-clipboard-cut? #t)) (let* ((selection-t (selection-tree)) (zfields (tm-search selection-t is-zfield?)) (documentID (get-documentID)) (dd (get-<document-data> documentID)) (zfd-ls (document-zfield-zfd-ls dd)) (zb-zfd-ls (document-zbibliography-zfd-ls dd)) (new-zfield-zfd (document-new-zfield-zfd dd))) (map (lambda (zfield) (let* ((zfieldID (zfield-zfieldID zfield)) (zfd-key (string-append documentID zfieldID)) (zfd (hash-ref documentID+zfieldID-><zfield-data>-ht zfd-key))) (cond ((and zfd (not (eq? zfd new-zfield-zfd))) (hash-remove! documentID+zfieldID-><zfield-data>-ht zfd-key) (set! (document-zfield-zfd-ls dd) (list-filter zfd-ls (lambda (elt) (not (eq? elt zfd))))) (when (is-zbibliography? zfield) (set! (document-zbibliography-zfd-ls dd) (list-filter zb-zfd-ls (lambda (elt) (not (eq? elt zfd)))))) (clear-tree-pointer zfd) (unintern-ztHrefFromCiteToBib-for-cut documentID zfield)) (zfd (let ((tp (tree-pointer zfd))) (tm-zotero-format-error "_BOLD__RED_clipboard-cut_RESET_: _RED_Cutting new zfield!_RESET_ _BOLD__RED_Fixme:_RESET_ Probably protocol breakdown; Restart Firefox and TeXmacs.") (tree-assign! zfield (stree->tree (quote (strong "{?? New Citation ??}")))) (clear-tree-pointer zfd) (set! (document-new-zfield-zfd dd) #f)))))) zfields) (cpp-clipboard-cut "none") (when (not (== which "none")) (clipboard-set which selection-t))))))
    => (define-option-match opt decl) <= ((lambda (which) (and (in-tm-zotero-style?) (not (is-during-tm-zotero-clipboard-cut?)) (has-zfield? (selection-tree)))) (tm-define-overloaded (clipboard-cut which) (with-fluids ((fluid/is-during-tm-zotero-clipboard-cut? #t)) (let* ((selection-t (selection-tree)) (zfields (tm-search selection-t is-zfield?)) (documentID (get-documentID)) (dd (get-<document-data> documentID)) (zfd-ls (document-zfield-zfd-ls dd)) (zb-zfd-ls (document-zbibliography-zfd-ls dd)) (new-zfield-zfd (document-new-zfield-zfd dd))) (map (lambda (zfield) (let* ((zfieldID (zfield-zfieldID zfield)) (zfd-key (string-append documentID zfieldID)) (zfd (hash-ref documentID+zfieldID-><zfield-data>-ht zfd-key))) (cond ((and zfd (not (eq? zfd new-zfield-zfd))) (hash-remove! documentID+zfieldID-><zfield-data>-ht zfd-key) (set! (document-zfield-zfd-ls dd) (list-filter zfd-ls (lambda (elt) (not (eq? elt zfd))))) (when (is-zbibliography? zfield) (set! (document-zbibliography-zfd-ls dd) (list-filter zb-zfd-ls (lambda (elt) (not (eq? elt zfd)))))) (clear-tree-pointer zfd) (unintern-ztHrefFromCiteToBib-for-cut documentID zfield)) (zfd (let ((tp (tree-pointer zfd))) (tm-zotero-format-error "_BOLD__RED_clipboard-cut_RESET_: _RED_Cutting new zfield!_RESET_ _BOLD__RED_Fixme:_RESET_ Probably protocol breakdown; Restart Firefox and TeXmacs.") (tree-assign! zfield (stree->tree (quote (strong "{?? New Citation ??}")))) (clear-tree-pointer zfd) (set! (document-new-zfield-zfd dd) #f)))))) zfields) (cpp-clipboard-cut "none") (when (not (== which "none")) (clipboard-set which selection-t))))))

  (define-option-require opt decl)
    <= (((let ((st (selection-tree))) (and (in-tm-zotero-style?) (not (is-during-tm-zotero-clipboard-cut?)) (inside-zcite? (cursor-tree)) (inside-inactive? (cursor-tree)) (not (has-zfield? st)) (has-zsubCite? st)))) (tm-define-overloaded (clipboard-copy which) (with-fluids ((fluid/is-during-tm-zotero-clipboard-cut? #t)) (let* ((selection-t (selection-tree)) (sel-zsubCite-ls (tm-search selection-t is-zsubCite?)) (zfield (tree-search-upwards (path->tree (cDr (selection-get-start))) (quote (zcite)))) (zfieldID (zfield-zfieldID zfield)) (zfield-new-ID (generate-unique-zfieldID)) (zfield-copy (tree-copy zfield)) (zfield-copy-ID (generate-unique-zfieldID)) (zsubCite-t-ls (tm-search (zfield-Text-t zfield-copy) is-zsubCite?)) (documentID (get-documentID)) (dd (get-<document-data> documentID)) (zfd-ls (document-zfield-zfd-ls dd)) (zfd-key (string-append documentID zfieldID)) (zfd (hash-ref documentID+zfieldID-><zfield-data>-ht zfd-key #f)) (layout-prefix (or (zotero-style-citation-layout-prefix) "")) (layout-delimiter (or (zotero-style-citation-layout-delimiter) "")) (layout-suffix (or (zotero-style-citation-layout-suffix) "")) (suppress? (and zfd (zfd-Code-code-properties-suppress-trailing-punctuation zfd))) (is-note? (zfield-IsNote? zfield)) (formattedCitation (and zfd (zfd-Code-code-properties-formattedCitation zfd))) (formattedCitation (if (string? formattedCitation) formattedCitation "")) (formattedCitation (if (string-prefix? "{\\rtf " formattedCitation) (substring formattedCitation 6 (1- (string-length formattedCitation))))) (formattedCitation (if (string-prefix? layout-prefix formattedCitation) (substring formattedCitation (string-length layout-prefix) (string-length formattedCitation)) formattedCitation)) (formattedCitation (if (string-suffix? layout-suffix formattedCitation) (substring formattedCitation 0 (- (string-length formattedCitation) (string-length layout-suffix))) formattedCitation)) (formattedSubCite-ls (split-string-by-substr formattedCitation layout-delimiter)) (code-citationItems-ls (or (and zfd (zfd-Code-code-citationItems-ls zfd)) (quote ()))) (zsubCite->*-alist (if (and (== (length zsubCite-t-ls) (length formattedSubCite-ls)) (== (length zsubCite-t-ls) (length code-citationItems-ls))) (map (lambda (a b c) (list a b c)) zsubCite-t-ls formattedSubCite-ls code-citationItems-ls) (quote ()))) (copy-alist (list-filter zsubCite->*-alist (lambda (elt) (member (car elt) sel-zsubCite-ls)))) (b (buffer-new)) (copy-zfd #f)) (selection-cancel) (when zfd (buffer-set-body b zfield-copy) (buffer-pretend-autosaved b) (buffer-pretend-saved b) (unintern-ztHrefFromCiteToBib-for-cut documentID zfield) (set! (zfield-zfieldID zfield-copy) zfield-copy-ID) (set! copy-zfd (make-instance <zfield-data> #:zfd-tree zfield-copy)) (set! (zfd-Code-code-citationID copy-zfd) (tm-zotero-random-string)) (set! (zfd-Code-code-properties-formattedCitation copy-zfd) (string-append "{\\rtf " (string-join (map cadr copy-alist) layout-delimiter) (if suppress? "" layout-suffix) "}")) (set! (zfield-Text-t zfield-copy) (tm-zotero-UTF-8-str_text->texmacs (zfd-Code-code-properties-formattedCitation copy-zfd) is-note? #f)) (set! (zfd-Code-code-citationItems-ls copy-zfd) (map caddr copy-alist)) (set! (zfd-Code-code-properties-plainCitation copy-zfd) (zfield-Text zfield-copy)) (set! (zfield-Code-is-modified?-flag zfield-copy) "false") (clipboard-set which zfield-copy) (clear-tree-pointer copy-zfd) (buffer-pretend-autosaved b) (buffer-pretend-saved b) (buffer-close b))))))
    => (define-option-match opt decl) <= ((lambda (which) (let ((st (selection-tree))) (and (in-tm-zotero-style?) (not (is-during-tm-zotero-clipboard-cut?)) (inside-zcite? (cursor-tree)) (inside-inactive? (cursor-tree)) (not (has-zfield? st)) (has-zsubCite? st)))) (tm-define-overloaded (clipboard-copy which) (with-fluids ((fluid/is-during-tm-zotero-clipboard-cut? #t)) (let* ((selection-t (selection-tree)) (sel-zsubCite-ls (tm-search selection-t is-zsubCite?)) (zfield (tree-search-upwards (path->tree (cDr (selection-get-start))) (quote (zcite)))) (zfieldID (zfield-zfieldID zfield)) (zfield-new-ID (generate-unique-zfieldID)) (zfield-copy (tree-copy zfield)) (zfield-copy-ID (generate-unique-zfieldID)) (zsubCite-t-ls (tm-search (zfield-Text-t zfield-copy) is-zsubCite?)) (documentID (get-documentID)) (dd (get-<document-data> documentID)) (zfd-ls (document-zfield-zfd-ls dd)) (zfd-key (string-append documentID zfieldID)) (zfd (hash-ref documentID+zfieldID-><zfield-data>-ht zfd-key #f)) (layout-prefix (or (zotero-style-citation-layout-prefix) "")) (layout-delimiter (or (zotero-style-citation-layout-delimiter) "")) (layout-suffix (or (zotero-style-citation-layout-suffix) "")) (suppress? (and zfd (zfd-Code-code-properties-suppress-trailing-punctuation zfd))) (is-note? (zfield-IsNote? zfield)) (formattedCitation (and zfd (zfd-Code-code-properties-formattedCitation zfd))) (formattedCitation (if (string? formattedCitation) formattedCitation "")) (formattedCitation (if (string-prefix? "{\\rtf " formattedCitation) (substring formattedCitation 6 (1- (string-length formattedCitation))))) (formattedCitation (if (string-prefix? layout-prefix formattedCitation) (substring formattedCitation (string-length layout-prefix) (string-length formattedCitation)) formattedCitation)) (formattedCitation (if (string-suffix? layout-suffix formattedCitation) (substring formattedCitation 0 (- (string-length formattedCitation) (string-length layout-suffix))) formattedCitation)) (formattedSubCite-ls (split-string-by-substr formattedCitation layout-delimiter)) (code-citationItems-ls (or (and zfd (zfd-Code-code-citationItems-ls zfd)) (quote ()))) (zsubCite->*-alist (if (and (== (length zsubCite-t-ls) (length formattedSubCite-ls)) (== (length zsubCite-t-ls) (length code-citationItems-ls))) (map (lambda (a b c) (list a b c)) zsubCite-t-ls formattedSubCite-ls code-citationItems-ls) (quote ()))) (copy-alist (list-filter zsubCite->*-alist (lambda (elt) (member (car elt) sel-zsubCite-ls)))) (b (buffer-new)) (copy-zfd #f)) (selection-cancel) (when zfd (buffer-set-body b zfield-copy) (buffer-pretend-autosaved b) (buffer-pretend-saved b) (unintern-ztHrefFromCiteToBib-for-cut documentID zfield) (set! (zfield-zfieldID zfield-copy) zfield-copy-ID) (set! copy-zfd (make-instance <zfield-data> #:zfd-tree zfield-copy)) (set! (zfd-Code-code-citationID copy-zfd) (tm-zotero-random-string)) (set! (zfd-Code-code-properties-formattedCitation copy-zfd) (string-append "{\\rtf " (string-join (map cadr copy-alist) layout-delimiter) (if suppress? "" layout-suffix) "}")) (set! (zfield-Text-t zfield-copy) (tm-zotero-UTF-8-str_text->texmacs (zfd-Code-code-properties-formattedCitation copy-zfd) is-note? #f)) (set! (zfd-Code-code-citationItems-ls copy-zfd) (map caddr copy-alist)) (set! (zfd-Code-code-properties-plainCitation copy-zfd) (zfield-Text zfield-copy)) (set! (zfield-Code-is-modified?-flag zfield-copy) "false") (clipboard-set which zfield-copy) (clear-tree-pointer copy-zfd) (buffer-pretend-autosaved b) (buffer-pretend-saved b) (buffer-close b))))))

  (define-option-require opt decl)
    <= (((let ((st (selection-tree))) (and (in-tm-zotero-style?) (not (is-during-tm-zotero-clipboard-cut?)) (inside-zcite? (cursor-tree)) (inside-inactive? (cursor-tree)) (not (has-zfield? st)) (has-zsubCite? st)))) (tm-define-overloaded (clipboard-cut which) (with-fluids ((fluid/is-during-tm-zotero-clipboard-cut? #t)) (let* ((selection-t (selection-tree)) (sel-zsubCite-ls (tm-search selection-t is-zsubCite?)) (zfield (tree-search-upwards (path->tree (cDr (selection-get-start))) (quote (zcite)))) (zfieldID (zfield-zfieldID zfield)) (zfield-new-ID (generate-unique-zfieldID)) (zfield-copy (tree-copy zfield)) (zfield-copy-ID (generate-unique-zfieldID)) (zsubCite-t-ls (tm-search (zfield-Text-t zfield-copy) is-zsubCite?)) (documentID (get-documentID)) (dd (get-<document-data> documentID)) (zfd-ls (document-zfield-zfd-ls dd)) (zfd-key (string-append documentID zfieldID)) (zfd (hash-ref documentID+zfieldID-><zfield-data>-ht zfd-key #f)) (layout-prefix (or (zotero-style-citation-layout-prefix) "")) (layout-delimiter (or (zotero-style-citation-layout-delimiter) "")) (layout-suffix (or (zotero-style-citation-layout-suffix) "")) (suppress? (and zfd (zfd-Code-code-properties-suppress-trailing-punctuation zfd))) (is-note? (zfield-IsNote? zfield)) (formattedCitation (and zfd (zfd-Code-code-properties-formattedCitation zfd))) (formattedCitation (if (string? formattedCitation) formattedCitation "")) (formattedCitation (if (string-prefix? "{\\rtf " formattedCitation) (substring formattedCitation 6 (1- (string-length formattedCitation))))) (formattedCitation (if (string-prefix? layout-prefix formattedCitation) (substring formattedCitation (string-length layout-prefix) (string-length formattedCitation)) formattedCitation)) (formattedCitation (if (string-suffix? layout-suffix formattedCitation) (substring formattedCitation 0 (- (string-length formattedCitation) (string-length layout-suffix))) formattedCitation)) (formattedSubCite-ls (split-string-by-substr formattedCitation layout-delimiter)) (code-citationItems-ls (or (and zfd (zfd-Code-code-citationItems-ls zfd)) (quote ()))) (zsubCite->*-alist (if (and (== (length zsubCite-t-ls) (length formattedSubCite-ls)) (== (length zsubCite-t-ls) (length code-citationItems-ls))) (map (lambda (a b c) (list a b c)) zsubCite-t-ls formattedSubCite-ls code-citationItems-ls) (quote ()))) (keep-alist (list-filter zsubCite->*-alist (lambda (elt) (not (member (car elt) sel-zsubCite-ls))))) (cut-alist (list-filter zsubCite->*-alist (lambda (elt) (member (car elt) sel-zsubCite-ls)))) (b (buffer-new)) (copy-zfd #f)) (selection-cancel) (when zfd (buffer-set-body b zfield-copy) (buffer-pretend-autosaved b) (buffer-pretend-saved b) (unintern-ztHrefFromCiteToBib-for-cut documentID zfield) (set! (zfield-zfieldID zfield-copy) zfield-copy-ID) (set! copy-zfd (make-instance <zfield-data> #:zfd-tree zfield-copy)) (set! (zfd-Code-code-citationID zfd) (tm-zotero-random-string)) (set! (zfd-Code-code-citationID copy-zfd) (tm-zotero-random-string)) (set! (zfd-Code-code-properties-formattedCitation zfd) (string-append "{\\rtf " (string-join (map cadr keep-alist) layout-delimiter) (if suppress? "" layout-suffix) "}")) (set! (zfd-Code-code-properties-formattedCitation copy-zfd) (string-append "{\\rtf " (string-join (map cadr cut-alist) layout-delimiter) (if suppress? "" layout-suffix) "}")) (set! (zfield-Text-t zfield) (tm-zotero-UTF-8-str_text->texmacs (zfd-Code-code-properties-formattedCitation zfd) is-note? #f)) (set! (zfield-Text-t zfield-copy) (tm-zotero-UTF-8-str_text->texmacs (zfd-Code-code-properties-formattedCitation copy-zfd) is-note? #f)) (set! (zfd-Code-code-citationItems-ls zfd) (map caddr keep-alist)) (set! (zfd-Code-code-citationItems-ls copy-zfd) (map caddr cut-alist)) (set! (zfd-Code-code-properties-plainCitation zfd) (zfield-Text zfield)) (set! (zfd-Code-code-properties-plainCitation copy-zfd) (zfield-Text zfield-copy)) (set! (zfield-Code-is-modified?-flag zfield) "false") (set! (zfield-Code-is-modified?-flag zfield-copy) "false") (clipboard-set which zfield-copy) (clear-tree-pointer copy-zfd) (if (null? keep-alist) (begin (hash-remove! documentID+zfieldID-><zfield-data>-ht zfd-key) (set! (document-zfield-zfd-ls dd) (list-filter zfd-ls (lambda (elt) (not (eq? elt zfd))))) (tree-assign! zfield "") (and-with inactive (tree-search-upwards zfield (quote inactive)) (tree-assign! inactive ""))) (begin (enqueue-delayed-integration-commands documentID (list zfield) tm-zotero-affirmCitation))) (buffer-pretend-autosaved b) (buffer-pretend-saved b) (buffer-close b))))))
    => (define-option-match opt decl) <= ((lambda (which) (let ((st (selection-tree))) (and (in-tm-zotero-style?) (not (is-during-tm-zotero-clipboard-cut?)) (inside-zcite? (cursor-tree)) (inside-inactive? (cursor-tree)) (not (has-zfield? st)) (has-zsubCite? st)))) (tm-define-overloaded (clipboard-cut which) (with-fluids ((fluid/is-during-tm-zotero-clipboard-cut? #t)) (let* ((selection-t (selection-tree)) (sel-zsubCite-ls (tm-search selection-t is-zsubCite?)) (zfield (tree-search-upwards (path->tree (cDr (selection-get-start))) (quote (zcite)))) (zfieldID (zfield-zfieldID zfield)) (zfield-new-ID (generate-unique-zfieldID)) (zfield-copy (tree-copy zfield)) (zfield-copy-ID (generate-unique-zfieldID)) (zsubCite-t-ls (tm-search (zfield-Text-t zfield-copy) is-zsubCite?)) (documentID (get-documentID)) (dd (get-<document-data> documentID)) (zfd-ls (document-zfield-zfd-ls dd)) (zfd-key (string-append documentID zfieldID)) (zfd (hash-ref documentID+zfieldID-><zfield-data>-ht zfd-key #f)) (layout-prefix (or (zotero-style-citation-layout-prefix) "")) (layout-delimiter (or (zotero-style-citation-layout-delimiter) "")) (layout-suffix (or (zotero-style-citation-layout-suffix) "")) (suppress? (and zfd (zfd-Code-code-properties-suppress-trailing-punctuation zfd))) (is-note? (zfield-IsNote? zfield)) (formattedCitation (and zfd (zfd-Code-code-properties-formattedCitation zfd))) (formattedCitation (if (string? formattedCitation) formattedCitation "")) (formattedCitation (if (string-prefix? "{\\rtf " formattedCitation) (substring formattedCitation 6 (1- (string-length formattedCitation))))) (formattedCitation (if (string-prefix? layout-prefix formattedCitation) (substring formattedCitation (string-length layout-prefix) (string-length formattedCitation)) formattedCitation)) (formattedCitation (if (string-suffix? layout-suffix formattedCitation) (substring formattedCitation 0 (- (string-length formattedCitation) (string-length layout-suffix))) formattedCitation)) (formattedSubCite-ls (split-string-by-substr formattedCitation layout-delimiter)) (code-citationItems-ls (or (and zfd (zfd-Code-code-citationItems-ls zfd)) (quote ()))) (zsubCite->*-alist (if (and (== (length zsubCite-t-ls) (length formattedSubCite-ls)) (== (length zsubCite-t-ls) (length code-citationItems-ls))) (map (lambda (a b c) (list a b c)) zsubCite-t-ls formattedSubCite-ls code-citationItems-ls) (quote ()))) (keep-alist (list-filter zsubCite->*-alist (lambda (elt) (not (member (car elt) sel-zsubCite-ls))))) (cut-alist (list-filter zsubCite->*-alist (lambda (elt) (member (car elt) sel-zsubCite-ls)))) (b (buffer-new)) (copy-zfd #f)) (selection-cancel) (when zfd (buffer-set-body b zfield-copy) (buffer-pretend-autosaved b) (buffer-pretend-saved b) (unintern-ztHrefFromCiteToBib-for-cut documentID zfield) (set! (zfield-zfieldID zfield-copy) zfield-copy-ID) (set! copy-zfd (make-instance <zfield-data> #:zfd-tree zfield-copy)) (set! (zfd-Code-code-citationID zfd) (tm-zotero-random-string)) (set! (zfd-Code-code-citationID copy-zfd) (tm-zotero-random-string)) (set! (zfd-Code-code-properties-formattedCitation zfd) (string-append "{\\rtf " (string-join (map cadr keep-alist) layout-delimiter) (if suppress? "" layout-suffix) "}")) (set! (zfd-Code-code-properties-formattedCitation copy-zfd) (string-append "{\\rtf " (string-join (map cadr cut-alist) layout-delimiter) (if suppress? "" layout-suffix) "}")) (set! (zfield-Text-t zfield) (tm-zotero-UTF-8-str_text->texmacs (zfd-Code-code-properties-formattedCitation zfd) is-note? #f)) (set! (zfield-Text-t zfield-copy) (tm-zotero-UTF-8-str_text->texmacs (zfd-Code-code-properties-formattedCitation copy-zfd) is-note? #f)) (set! (zfd-Code-code-citationItems-ls zfd) (map caddr keep-alist)) (set! (zfd-Code-code-citationItems-ls copy-zfd) (map caddr cut-alist)) (set! (zfd-Code-code-properties-plainCitation zfd) (zfield-Text zfield)) (set! (zfd-Code-code-properties-plainCitation copy-zfd) (zfield-Text zfield-copy)) (set! (zfield-Code-is-modified?-flag zfield) "false") (set! (zfield-Code-is-modified?-flag zfield-copy) "false") (clipboard-set which zfield-copy) (clear-tree-pointer copy-zfd) (if (null? keep-alist) (begin (hash-remove! documentID+zfieldID-><zfield-data>-ht zfd-key) (set! (document-zfield-zfd-ls dd) (list-filter zfd-ls (lambda (elt) (not (eq? elt zfd))))) (tree-assign! zfield "") (and-with inactive (tree-search-upwards zfield (quote inactive)) (tree-assign! inactive ""))) (begin (enqueue-delayed-integration-commands documentID (list zfield) tm-zotero-affirmCitation))) (buffer-pretend-autosaved b) (buffer-pretend-saved b) (buffer-close b))))))

  (define-option-require opt decl)
    <= (((and (in-tm-zotero-style?) (not (is-during-tm-zotero-clipboard-cut?)) (inside-zfield? (cursor-tree)) (inside-which (quote (zsubCite zciteLayoutPrefix zciteLayoutDelimiter zciteLayoutSuffix))) (has-zfield? (tree-ref (clipboard-get which) 1)))) (tm-define-overloaded (clipboard-paste which) (noop)))
    => (define-option-match opt decl) <= ((lambda (which) (and (in-tm-zotero-style?) (not (is-during-tm-zotero-clipboard-cut?)) (inside-zfield? (cursor-tree)) (inside-which (quote (zsubCite zciteLayoutPrefix zciteLayoutDelimiter zciteLayoutSuffix))) (has-zfield? (tree-ref (clipboard-get which) 1)))) (tm-define-overloaded (clipboard-paste which) (noop)))

  (define-option-require opt decl)
    <= (((and (in-tm-zotero-style?) (not (is-during-tm-zotero-clipboard-cut?)) (not (inside-zfield? (cursor-tree))) (not (inside-inactive? (cursor-tree))) (has-zfield? (clipboard-get which)))) (tm-define-overloaded (clipboard-paste which) (let ((documentID (get-documentID)) (clipboard-t (clipboard-get which))) (with-fluids ((fluid/is-during-tm-zotero-clipboard-cut? #t)) (insert (tree-ref clipboard-t 1) 1) (map (lambda (zfield) (set! (zfield-zfieldID zfield) (generate-unique-zfieldID))) (tm-search clipboard-t is-zfield?))) (enqueue-delayed-integration-commands documentID (tm-search clipboard-t is-zfield?) tm-zotero-affirmCitation))))
    => (define-option-match opt decl) <= ((lambda (which) (and (in-tm-zotero-style?) (not (is-during-tm-zotero-clipboard-cut?)) (not (inside-zfield? (cursor-tree))) (not (inside-inactive? (cursor-tree))) (has-zfield? (clipboard-get which)))) (tm-define-overloaded (clipboard-paste which) (let ((documentID (get-documentID)) (clipboard-t (clipboard-get which))) (with-fluids ((fluid/is-during-tm-zotero-clipboard-cut? #t)) (insert (tree-ref clipboard-t 1) 1) (map (lambda (zfield) (set! (zfield-zfieldID zfield) (generate-unique-zfieldID))) (tm-search clipboard-t is-zfield?))) (enqueue-delayed-integration-commands documentID (tm-search clipboard-t is-zfield?) tm-zotero-affirmCitation))))

  (define-option-require opt decl)
    <= (((and (in-tm-zotero-style?) (not (is-during-tm-zotero-clipboard-cut?)) (focus-is-zfield?) (not (selection-active-any?)) (not (inside-which (quote (zsubCite zciteLayoutPrefix zciteLayoutDelimiter zciteLayoutSuffix)))) (is-zcite? (tree-ref (clipboard-get which) 1)))) (tm-define-overloaded (clipboard-paste which) (with-fluids ((fluid/is-during-tm-zotero-clipboard-cut? #t)) (let* ((clipboard-t (clipboard-get which)) (zcite-clip (tm-find clipboard-t (cut tm-is? <> (quote zcite)))) (b (buffer-new)) (clip-zfd #f)) (buffer-set-body b zcite-clip) (buffer-pretend-autosaved b) (buffer-pretend-saved b) (set! clip-zfd (make-instance <zfield-data> #:zfd-tree zcite-clip)) (let* ((documentID (get-documentID)) (dd (get-<document-data> documentID)) (zfield (tree-search-upwards (cursor-tree) (quote (zcite)))) (zfieldID (zfield-zfieldID zfield)) (zfield-new-ID (generate-unique-zfieldID)) (zsubCite-t-ls (tm-search zfield is-zsubCite?)) (clip-zsubCite-t-ls (tm-search zcite-clip is-zsubCite?)) (zfd-key (string-append documentID zfieldID)) (zfd (hash-ref documentID+zfieldID-><zfield-data>-ht zfd-key)) (layout-prefix (or (zotero-style-citation-layout-prefix) "")) (layout-delimiter (or (zotero-style-citation-layout-delimiter) "")) (layout-suffix (or (zotero-style-citation-layout-suffix) "")) (suppress? (zfd-Code-code-properties-suppress-trailing-punctuation zfd)) (is-note? (zfield-IsNote? zfield)) (formattedCitation (zfd-Code-code-properties-formattedCitation zfd)) (formattedCitation (if (string-prefix? "{\\rtf " formattedCitation) (substring formattedCitation 6 (1- (string-length formattedCitation))))) (formattedCitation (if (string-prefix? layout-prefix formattedCitation) (substring formattedCitation (string-length layout-prefix) (string-length formattedCitation)) formattedCitation)) (formattedCitation (if (string-suffix? layout-suffix formattedCitation) (substring formattedCitation 0 (- (string-length formattedCitation) (string-length layout-suffix))) formattedCitation)) (formattedSubCite-ls (split-string-by-substr formattedCitation layout-delimiter)) (clip-formattedCitation (zfd-Code-code-properties-formattedCitation clip-zfd)) (clip-formattedCitation (if (string-prefix? "{\\rtf " clip-formattedCitation) (substring clip-formattedCitation 6 (1- (string-length clip-formattedCitation))))) (clip-formattedCitation (if (string-prefix? layout-prefix clip-formattedCitation) (substring clip-formattedCitation (string-length layout-prefix) (string-length clip-formattedCitation)) clip-formattedCitation)) (clip-formattedCitation (if (string-suffix? layout-suffix clip-formattedCitation) (substring clip-formattedCitation 0 (- (string-length clip-formattedCitation) (string-length layout-suffix))) clip-formattedCitation)) (clip-formattedSubCite-ls (split-string-by-substr clip-formattedCitation layout-delimiter)) (code-citationItems-ls (zfd-Code-code-citationItems-ls zfd)) (clip-code-citationItems-ls (zfd-Code-code-citationItems-ls clip-zfd)) (zcite-zsubCite->*-alist (map (lambda (a b c) (list a b c)) zsubCite-t-ls formattedSubCite-ls code-citationItems-ls)) (clip-zsubCite->*-alist (map (lambda (a b c) (list a b c)) clip-zsubCite-t-ls clip-formattedSubCite-ls clip-code-citationItems-ls)) (cp (cDr (cursor-path))) (before-cursor (list-filter zcite-zsubCite->*-alist (lambda (elt) (path-less? (tree->path (car elt)) cp)))) (after-cursor (list-filter zcite-zsubCite->*-alist (lambda (elt) (not (path-less? (tree->path (car elt)) cp))))) (zsubCite->*alist (append! before-cursor clip-zsubCite->*-alist after-cursor))) (unintern-ztHrefFromCiteToBib-for-cut documentID zfield) (set! (zfd-Code-code-citationID zfd) (tm-zotero-random-string)) (set! (zfd-Code-code-properties-formattedCitation zfd) (string-append "{\\rtf " (string-join (map cadr zsubCite->*alist) layout-delimiter) (if suppress? "" layout-suffix) "}")) (set! (zfield-Text-t zfield) (tm-zotero-UTF-8-str_text->texmacs (zfd-Code-code-properties-formattedCitation zfd) is-note? #f)) (set! (zfd-Code-code-citationItems-ls zfd) (map caddr zsubCite->*alist)) (set! (zfd-Code-code-properties-plainCitation zfd) (zfield-Text zfield)) (set! (zfield-Code-is-modified?-flag zfield) "false") (clear-tree-pointer clip-zfd) (buffer-pretend-autosaved b) (buffer-pretend-saved b) (buffer-close b))))))
    => (define-option-match opt decl) <= ((lambda (which) (and (in-tm-zotero-style?) (not (is-during-tm-zotero-clipboard-cut?)) (focus-is-zfield?) (not (selection-active-any?)) (not (inside-which (quote (zsubCite zciteLayoutPrefix zciteLayoutDelimiter zciteLayoutSuffix)))) (is-zcite? (tree-ref (clipboard-get which) 1)))) (tm-define-overloaded (clipboard-paste which) (with-fluids ((fluid/is-during-tm-zotero-clipboard-cut? #t)) (let* ((clipboard-t (clipboard-get which)) (zcite-clip (tm-find clipboard-t (cut tm-is? <> (quote zcite)))) (b (buffer-new)) (clip-zfd #f)) (buffer-set-body b zcite-clip) (buffer-pretend-autosaved b) (buffer-pretend-saved b) (set! clip-zfd (make-instance <zfield-data> #:zfd-tree zcite-clip)) (let* ((documentID (get-documentID)) (dd (get-<document-data> documentID)) (zfield (tree-search-upwards (cursor-tree) (quote (zcite)))) (zfieldID (zfield-zfieldID zfield)) (zfield-new-ID (generate-unique-zfieldID)) (zsubCite-t-ls (tm-search zfield is-zsubCite?)) (clip-zsubCite-t-ls (tm-search zcite-clip is-zsubCite?)) (zfd-key (string-append documentID zfieldID)) (zfd (hash-ref documentID+zfieldID-><zfield-data>-ht zfd-key)) (layout-prefix (or (zotero-style-citation-layout-prefix) "")) (layout-delimiter (or (zotero-style-citation-layout-delimiter) "")) (layout-suffix (or (zotero-style-citation-layout-suffix) "")) (suppress? (zfd-Code-code-properties-suppress-trailing-punctuation zfd)) (is-note? (zfield-IsNote? zfield)) (formattedCitation (zfd-Code-code-properties-formattedCitation zfd)) (formattedCitation (if (string-prefix? "{\\rtf " formattedCitation) (substring formattedCitation 6 (1- (string-length formattedCitation))))) (formattedCitation (if (string-prefix? layout-prefix formattedCitation) (substring formattedCitation (string-length layout-prefix) (string-length formattedCitation)) formattedCitation)) (formattedCitation (if (string-suffix? layout-suffix formattedCitation) (substring formattedCitation 0 (- (string-length formattedCitation) (string-length layout-suffix))) formattedCitation)) (formattedSubCite-ls (split-string-by-substr formattedCitation layout-delimiter)) (clip-formattedCitation (zfd-Code-code-properties-formattedCitation clip-zfd)) (clip-formattedCitation (if (string-prefix? "{\\rtf " clip-formattedCitation) (substring clip-formattedCitation 6 (1- (string-length clip-formattedCitation))))) (clip-formattedCitation (if (string-prefix? layout-prefix clip-formattedCitation) (substring clip-formattedCitation (string-length layout-prefix) (string-length clip-formattedCitation)) clip-formattedCitation)) (clip-formattedCitation (if (string-suffix? layout-suffix clip-formattedCitation) (substring clip-formattedCitation 0 (- (string-length clip-formattedCitation) (string-length layout-suffix))) clip-formattedCitation)) (clip-formattedSubCite-ls (split-string-by-substr clip-formattedCitation layout-delimiter)) (code-citationItems-ls (zfd-Code-code-citationItems-ls zfd)) (clip-code-citationItems-ls (zfd-Code-code-citationItems-ls clip-zfd)) (zcite-zsubCite->*-alist (map (lambda (a b c) (list a b c)) zsubCite-t-ls formattedSubCite-ls code-citationItems-ls)) (clip-zsubCite->*-alist (map (lambda (a b c) (list a b c)) clip-zsubCite-t-ls clip-formattedSubCite-ls clip-code-citationItems-ls)) (cp (cDr (cursor-path))) (before-cursor (list-filter zcite-zsubCite->*-alist (lambda (elt) (path-less? (tree->path (car elt)) cp)))) (after-cursor (list-filter zcite-zsubCite->*-alist (lambda (elt) (not (path-less? (tree->path (car elt)) cp))))) (zsubCite->*alist (append! before-cursor clip-zsubCite->*-alist after-cursor))) (unintern-ztHrefFromCiteToBib-for-cut documentID zfield) (set! (zfd-Code-code-citationID zfd) (tm-zotero-random-string)) (set! (zfd-Code-code-properties-formattedCitation zfd) (string-append "{\\rtf " (string-join (map cadr zsubCite->*alist) layout-delimiter) (if suppress? "" layout-suffix) "}")) (set! (zfield-Text-t zfield) (tm-zotero-UTF-8-str_text->texmacs (zfd-Code-code-properties-formattedCitation zfd) is-note? #f)) (set! (zfd-Code-code-citationItems-ls zfd) (map caddr zsubCite->*alist)) (set! (zfd-Code-code-properties-plainCitation zfd) (zfield-Text zfield)) (set! (zfield-Code-is-modified?-flag zfield) "false") (clear-tree-pointer clip-zfd) (buffer-pretend-autosaved b) (buffer-pretend-saved b) (buffer-close b))))))

  (define-option-require opt decl)
    <= (((and (in-tm-zotero-style?) (is-during-tm-zotero-clipboard-cut?))) (tm-define-overloaded (clipboard-copy which) (noop)))
    => (define-option-match opt decl) <= ((lambda (which) (and (in-tm-zotero-style?) (is-during-tm-zotero-clipboard-cut?))) (tm-define-overloaded (clipboard-copy which) (noop)))

  (define-option-require opt decl)
    <= (((and (in-tm-zotero-style?) (is-during-tm-zotero-clipboard-cut?))) (tm-define-overloaded (clipboard-cut which) (noop)))
    => (define-option-match opt decl) <= ((lambda (which) (and (in-tm-zotero-style?) (is-during-tm-zotero-clipboard-cut?))) (tm-define-overloaded (clipboard-cut which) (noop)))

  (define-option-require opt decl)
    <= (((and (in-tm-zotero-style?) (is-during-tm-zotero-clipboard-cut?))) (tm-define-overloaded (clipboard-paste which) (noop)))
    => (define-option-match opt decl) <= ((lambda (which) (and (in-tm-zotero-style?) (is-during-tm-zotero-clipboard-cut?))) (tm-define-overloaded (clipboard-paste which) (noop)))

  (define-option-require opt decl)
    <= (((and (in-tm-zotero-style?) (focus-is-zcite?))) (tm-define-overloaded (kbd-shift-space) (toggle-focus-zcite-suppress-trailing-punctuation)))
    => (define-option-match opt decl) <= ((lambda () (and (in-tm-zotero-style?) (focus-is-zcite?))) (tm-define-overloaded (kbd-shift-space) (toggle-focus-zcite-suppress-trailing-punctuation)))

  (define-option-require opt decl)
    <= (((and (focus-is-zcite?) (not (in-source?)))) (tm-define-overloaded (kbd-control-return) (tm-zotero-editCitation)))
    => (define-option-match opt decl) <= ((lambda () (and (focus-is-zcite?) (not (in-source?)))) (tm-define-overloaded (kbd-control-return) (tm-zotero-editCitation)))

  (define-option-require opt decl)
    <= (((and (focus-is-zcite?) (not (in-source?)))) (tm-define-overloaded (kbd-tab) (tm-zotero-affirmCitation)))
    => (define-option-match opt decl) <= ((lambda () (and (focus-is-zcite?) (not (in-source?)))) (tm-define-overloaded (kbd-tab) (tm-zotero-affirmCitation)))

  (define-option-require opt decl)
    <= (((and (focus-is-zbibliography?) (not (in-source?)))) (tm-define-overloaded (kbd-control-return) (tm-zotero-editBibliography)))
    => (define-option-match opt decl) <= ((lambda () (and (focus-is-zbibliography?) (not (in-source?)))) (tm-define-overloaded (kbd-control-return) (tm-zotero-editBibliography)))

  (define-option-require opt decl)
    <= (((and (focus-is-zbibliography?) (not (in-source?)))) (tm-define-overloaded (kbd-tab) (tm-zotero-editBibliography)))
    => (define-option-match opt decl) <= ((lambda () (and (focus-is-zbibliography?) (not (in-source?)))) (tm-define-overloaded (kbd-tab) (tm-zotero-editBibliography)))

  (define-option-require opt decl)
    <= (((and (or (focus-is-zfield?) (focus-is-ztHref?)) (or (in? l (list "zotero-pref-noteType0" "zotero-pref-noteType1" "zotero-pref-noteType2" "zt-not-inside-note" "zt-in-footnote" "zt-in-endnote" "zt-not-inside-zbibliography" "zt-option-this-zcite-in-text" "zt-extra-surround-before" "endnote-nr" "footnote-nr" "zt-endnote" "zt-footnote")) (and (or (== (get-env "zotero-pref-noteType0") "true") (and (or (== (get-env "zotero-pref-noteType1") "true") (== (get-env "zotero-pref-noteType2") "true")) (== (get-env "zt-option-this-zcite-in-text") "true"))) (in? l (list "footnote-sep" "page-fnote-barlen" "page-fnote-sep")))))) (tm-define-overloaded (parameter-show-in-menu? l) #f))
    => (define-option-match opt decl) <= ((lambda (l) (and (or (focus-is-zfield?) (focus-is-ztHref?)) (or (in? l (list "zotero-pref-noteType0" "zotero-pref-noteType1" "zotero-pref-noteType2" "zt-not-inside-note" "zt-in-footnote" "zt-in-endnote" "zt-not-inside-zbibliography" "zt-option-this-zcite-in-text" "zt-extra-surround-before" "endnote-nr" "footnote-nr" "zt-endnote" "zt-footnote")) (and (or (== (get-env "zotero-pref-noteType0") "true") (and (or (== (get-env "zotero-pref-noteType1") "true") (== (get-env "zotero-pref-noteType2") "true")) (== (get-env "zt-option-this-zcite-in-text") "true"))) (in? l (list "footnote-sep" "page-fnote-barlen" "page-fnote-sep")))))) (tm-define-overloaded (parameter-show-in-menu? l) #f))

  (define-option-require opt decl)
    <= (((and (focus-is-zbibliography?) (in? l (list "zt-option-zbib-font-size" "zbibColumns" "zbibPageBefore" "ztbibSubHeadingTextSize" "ztbibSubHeadingVspace*" "zt-link-BibToURL" "zt-render-bibItemRefsLists")))) (tm-define-overloaded (parameter-show-in-menu? l) #t))
    => (define-option-match opt decl) <= ((lambda (l) (and (focus-is-zbibliography?) (in? l (list "zt-option-zbib-font-size" "zbibColumns" "zbibPageBefore" "ztbibSubHeadingTextSize" "ztbibSubHeadingVspace*" "zt-link-BibToURL" "zt-render-bibItemRefsLists")))) (tm-define-overloaded (parameter-show-in-menu? l) #t))

  (define-option-require opt decl)
    <= (((and (focus-is-zbibliography?) (== var "zbibColumns"))) (tm-define-overloaded (parameter-choice-list var) (list "1" "2")))
    => (define-option-match opt decl) <= ((lambda (var) (and (focus-is-zbibliography?) (== var "zbibColumns"))) (tm-define-overloaded (parameter-choice-list var) (list "1" "2")))

  (define-option-require opt decl)
    <= (((and (focus-is-zbibliography?) (== var "zbibPageBefore"))) (tm-define-overloaded (parameter-choice-list var) (list "0" "1" "2")))
    => (define-option-match opt decl) <= ((lambda (var) (and (focus-is-zbibliography?) (== var "zbibPageBefore"))) (tm-define-overloaded (parameter-choice-list var) (list "0" "1" "2")))

  (define-option-require opt decl)
    <= (((focus-is-zfield?)) (tm-define-overloaded (focus-tag-name l) (case l (("zt-option-zbib-font-size") "Bibliography font size") (("zbibColumns") "Number of columns") (("zbibPageBefore") "Page break or double page before?") (("ztbibSubHeadingVspace*") "Vspace before ztbibSubHeading") (("zt-link-BibToURL") "Link bibitem to URL?") (("zt-link-FromCiteToBib") "Link from citation to bib item?") (("zt-render-bibItemRefsLists") "Render bib item refs lists?") (else (former l)))))
    => (define-option-match opt decl) <= ((lambda (l) (focus-is-zfield?)) (tm-define-overloaded (focus-tag-name l) (case l (("zt-option-zbib-font-size") "Bibliography font size") (("zbibColumns") "Number of columns") (("zbibPageBefore") "Page break or double page before?") (("ztbibSubHeadingVspace*") "Vspace before ztbibSubHeading") (("zt-link-BibToURL") "Link bibitem to URL?") (("zt-link-FromCiteToBib") "Link from citation to bib item?") (("zt-render-bibItemRefsLists") "Render bib item refs lists?") (else (former l)))))

  (define-option-require opt decl)
    <= (((and (focus-is-zcite?) (!= (get-env "zotero-pref-noteType0") "true") (or (== (get-env "zotero-pref-noteType1") "true") (== (get-env "zotero-pref-noteType2") "true")) (!= (get-env "zt-in-footnote") "true") (!= (get-env "zt-in-endnote") "true"))) (tm-define-overloaded (customizable-parameters t) (list (list "zt-option-this-zcite-in-text" "Force in-text?"))))
    => (define-option-match opt decl) <= ((lambda (t) (and (focus-is-zcite?) (!= (get-env "zotero-pref-noteType0") "true") (or (== (get-env "zotero-pref-noteType1") "true") (== (get-env "zotero-pref-noteType2") "true")) (!= (get-env "zt-in-footnote") "true") (!= (get-env "zt-in-endnote") "true"))) (tm-define-overloaded (customizable-parameters t) (list (list "zt-option-this-zcite-in-text" "Force in-text?"))))

  (define-option-require opt decl)
    <= (((and (focus-is-zcite?) (== var "zt-option-this-zcite-in-text"))) (tm-define-overloaded (parameter-choice-list var) (list "true" "false")))
    => (define-option-match opt decl) <= ((lambda (var) (and (focus-is-zcite?) (== var "zt-option-this-zcite-in-text"))) (tm-define-overloaded (parameter-choice-list var) (list "true" "false")))

  (define-option-require opt decl)
    <= (((focus-is-zcite?)) (tm-define-overloaded (hidden-child? t i) #f))
    => (define-option-match opt decl) <= ((lambda (t i) (focus-is-zcite?)) (tm-define-overloaded (hidden-child? t i) #f))

  ((define-property* which)  opt decl)
    <= ((#:secure)  () (tm-define-overloaded (tm-zotero-ext:create-unique-id) (create-unique-id)))
    => ((quote tm-zotero-ext:create-unique-id) #:secure (list))
 => cons <> cur-props
    => cur-props => (((quote tm-zotero-ext:create-unique-id) #:secure (list)))

(property-set! var prop what conds*)
  <= (tm-zotero-ext:create-unique-id #:secure () ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  () (tm-define-overloaded (tm-zotero-ext:ensure-zfield-interned! zfieldID-t) (%tm-zotero-ext:ensure-zfield-interned! zfieldID-t) ""))
    => ((quote tm-zotero-ext:ensure-zfield-interned!) #:secure (list))
 => cons <> cur-props
    => cur-props => (((quote tm-zotero-ext:ensure-zfield-interned!) #:secure (list)))

(property-set! var prop what conds*)
  <= (tm-zotero-ext:ensure-zfield-interned! #:secure () ())

  (define-option-require opt decl)
    <= (((tree? zfieldID-t)) (tm-define-overloaded (%tm-zotero-ext:ensure-zfield-interned! zfieldID-t) (let* ((documentID (get-documentID)) (zfieldID (tree->stree zfieldID-t)) (zfd-key (string-append documentID zfieldID)) (zfield (tree-search-upwards zfieldID-t zfield-tags)) (zfd (and zfield (make-instance <zfield-data> #:zfd-tree zfield)))) (when zfd (hash-set! documentID+zfieldID-><zfield-data>-ht zfd-key zfd) (document-merge!-<zfield-data> documentID zfd) (when (and zfield (is-zbibliography? zfield)) (document-merge!-zbibliography-zfd documentID zfd))) "")))
    => (define-option-match opt decl) <= ((lambda (zfieldID-t) (tree? zfieldID-t)) (tm-define-overloaded (%tm-zotero-ext:ensure-zfield-interned! zfieldID-t) (let* ((documentID (get-documentID)) (zfieldID (tree->stree zfieldID-t)) (zfd-key (string-append documentID zfieldID)) (zfield (tree-search-upwards zfieldID-t zfield-tags)) (zfd (and zfield (make-instance <zfield-data> #:zfd-tree zfield)))) (when zfd (hash-set! documentID+zfieldID-><zfield-data>-ht zfd-key zfd) (document-merge!-<zfield-data> documentID zfd) (when (and zfield (is-zbibliography? zfield)) (document-merge!-zbibliography-zfd documentID zfd))) "")))

  (define-option-require opt decl)
    <= (((and (tree? zfieldID-t) (zfield-is-document-new-zfield? (get-documentID) (tree->stree zfieldID-t)))) (tm-define-overloaded (%tm-zotero-ext:ensure-zfield-interned! zfieldID-t) ""))
    => (define-option-match opt decl) <= ((lambda (zfieldID-t) (and (tree? zfieldID-t) (zfield-is-document-new-zfield? (get-documentID) (tree->stree zfieldID-t)))) (tm-define-overloaded (%tm-zotero-ext:ensure-zfield-interned! zfieldID-t) ""))

  (define-option-require opt decl)
    <= (((and (tree? zfieldID-t) (inside-inactive? zfieldID-t))) (tm-define-overloaded (%tm-zotero-ext:ensure-zfield-interned! zfieldID-t) ""))
    => (define-option-match opt decl) <= ((lambda (zfieldID-t) (and (tree? zfieldID-t) (inside-inactive? zfieldID-t))) (tm-define-overloaded (%tm-zotero-ext:ensure-zfield-interned! zfieldID-t) ""))

  (define-option-require opt decl)
    <= (((and (tree? zfieldID-t) (not (inside-shown-part? zfieldID-t)))) (tm-define-overloaded (%tm-zotero-ext:ensure-zfield-interned! zfieldID-t) ""))
    => (define-option-match opt decl) <= ((lambda (zfieldID-t) (and (tree? zfieldID-t) (not (inside-shown-part? zfieldID-t)))) (tm-define-overloaded (%tm-zotero-ext:ensure-zfield-interned! zfieldID-t) ""))

  (define-option-require opt decl)
    <= (((and (tree? zfieldID-t) (hash-ref documentID+zfieldID-><zfield-data>-ht (string-append (get-documentID) (tree->stree zfieldID-t)) #f))) (tm-define-overloaded (%tm-zotero-ext:ensure-zfield-interned! zfieldID-t) ""))
    => (define-option-match opt decl) <= ((lambda (zfieldID-t) (and (tree? zfieldID-t) (hash-ref documentID+zfieldID-><zfield-data>-ht (string-append (get-documentID) (tree->stree zfieldID-t)) #f))) (tm-define-overloaded (%tm-zotero-ext:ensure-zfield-interned! zfieldID-t) ""))

  (define-option-require opt decl)
    <= (((is-during-tm-zotero-clipboard-cut?)) (tm-define-overloaded (%tm-zotero-ext:ensure-zfield-interned! zfieldID-t) ""))
    => (define-option-match opt decl) <= ((lambda (zfieldID-t) (is-during-tm-zotero-clipboard-cut?)) (tm-define-overloaded (%tm-zotero-ext:ensure-zfield-interned! zfieldID-t) ""))

  ((define-property* which)  opt decl)
    <= ((#:secure)  () (tm-define-overloaded (tm-zotero-ext:ensure-ztHrefFromCiteToBib-interned! zfieldID-t hashLabel-t) (%tm-zotero-ext:ensure-ztHrefFromCiteToBib-interned! zfieldID-t hashLabel-t) ""))
    => ((quote tm-zotero-ext:ensure-ztHrefFromCiteToBib-interned!) #:secure (list))
 => cons <> cur-props
    => cur-props => (((quote tm-zotero-ext:ensure-ztHrefFromCiteToBib-interned!) #:secure (list)))

(property-set! var prop what conds*)
  <= (tm-zotero-ext:ensure-ztHrefFromCiteToBib-interned! #:secure () ())

  (define-option-require opt decl)
    <= (((and (tree? zfieldID-t) (tree? hashLabel-t))) (tm-define-overloaded (%tm-zotero-ext:ensure-ztHrefFromCiteToBib-interned! zfieldID-t hashLabel-t) (let* ((documentID (get-documentID)) (zfieldID (tree->stree zfieldID-t)) (sysID (string-tail (tree->stree hashLabel-t) ztbibItemRef-hashlabel-string-prefix-length)) (ztHref* (tree-up hashLabel-t)) (ref-label (ztHrefFromCiteToBib-reflabel zfieldID sysID)) (zhd-key (string-append documentID "#" ref-label)) (zhd-ls-key (string-append documentID ztbibItemRef-hashlabel-string-prefix sysID)) (zhd (make-instance <ztHrefFromCiteToBib-data> #:the-zfieldID-of zfieldID #:the-sysID-of sysID #:zhd-tree ztHref*))) (hash-set! documentID+zfieldID+sysID-><ztHrefFromCiteToBib-data>-ht zhd-key zhd) (hash-set! documentID+zfieldID+sysID-><ztHrefFromCiteToBib-data>-ht zhd-ls-key (merge! (list zhd) (hash-ref documentID+zfieldID+sysID-><ztHrefFromCiteToBib-data>-ht zhd-ls-key (quote ())) <*-data>-less?))) ""))
    => (define-option-match opt decl) <= ((lambda (zfieldID-t hashLabel-t) (and (tree? zfieldID-t) (tree? hashLabel-t))) (tm-define-overloaded (%tm-zotero-ext:ensure-ztHrefFromCiteToBib-interned! zfieldID-t hashLabel-t) (let* ((documentID (get-documentID)) (zfieldID (tree->stree zfieldID-t)) (sysID (string-tail (tree->stree hashLabel-t) ztbibItemRef-hashlabel-string-prefix-length)) (ztHref* (tree-up hashLabel-t)) (ref-label (ztHrefFromCiteToBib-reflabel zfieldID sysID)) (zhd-key (string-append documentID "#" ref-label)) (zhd-ls-key (string-append documentID ztbibItemRef-hashlabel-string-prefix sysID)) (zhd (make-instance <ztHrefFromCiteToBib-data> #:the-zfieldID-of zfieldID #:the-sysID-of sysID #:zhd-tree ztHref*))) (hash-set! documentID+zfieldID+sysID-><ztHrefFromCiteToBib-data>-ht zhd-key zhd) (hash-set! documentID+zfieldID+sysID-><ztHrefFromCiteToBib-data>-ht zhd-ls-key (merge! (list zhd) (hash-ref documentID+zfieldID+sysID-><ztHrefFromCiteToBib-data>-ht zhd-ls-key (quote ())) <*-data>-less?))) ""))

  (define-option-require opt decl)
    <= (((inside-inactive? zfieldID-t)) (tm-define-overloaded (%tm-zotero-ext:ensure-ztHrefFromCiteToBib-interned! zfieldID-t hashLabel-t) ""))
    => (define-option-match opt decl) <= ((lambda (zfieldID-t hashLabel-t) (inside-inactive? zfieldID-t)) (tm-define-overloaded (%tm-zotero-ext:ensure-ztHrefFromCiteToBib-interned! zfieldID-t hashLabel-t) ""))

  (define-option-require opt decl)
    <= (((not (inside-shown-part? zfieldID-t))) (tm-define-overloaded (%tm-zotero-ext:ensure-ztHrefFromCiteToBib-interned! zfieldID-t hashLabel-t) ""))
    => (define-option-match opt decl) <= ((lambda (zfieldID-t hashLabel-t) (not (inside-shown-part? zfieldID-t))) (tm-define-overloaded (%tm-zotero-ext:ensure-ztHrefFromCiteToBib-interned! zfieldID-t hashLabel-t) ""))

  (define-option-require opt decl)
    <= (((and (tree? zfieldID-t) (hash-ref documentID+zfieldID+sysID-><ztHrefFromCiteToBib-data>-ht (string-append (get-documentID) "#" (ztHrefFromCiteToBib-reflabel (tree->stree zfieldID-t) (string-tail (tree->stree hashLabel-t) ztbibItemRef-hashlabel-string-prefix-length))) #f))) (tm-define-overloaded (%tm-zotero-ext:ensure-ztHrefFromCiteToBib-interned! zfieldID-t hashLabel-t) ""))
    => (define-option-match opt decl) <= ((lambda (zfieldID-t hashLabel-t) (and (tree? zfieldID-t) (hash-ref documentID+zfieldID+sysID-><ztHrefFromCiteToBib-data>-ht (string-append (get-documentID) "#" (ztHrefFromCiteToBib-reflabel (tree->stree zfieldID-t) (string-tail (tree->stree hashLabel-t) ztbibItemRef-hashlabel-string-prefix-length))) #f))) (tm-define-overloaded (%tm-zotero-ext:ensure-ztHrefFromCiteToBib-interned! zfieldID-t hashLabel-t) ""))

  (define-option-require opt decl)
    <= (((is-during-tm-zotero-clipboard-cut?)) (tm-define-overloaded (%tm-zotero-ext:ensure-ztHrefFromCiteToBib-interned! zfieldID-t hashLabel-t) ""))
    => (define-option-match opt decl) <= ((lambda (zfieldID-t hashLabel-t) (is-during-tm-zotero-clipboard-cut?)) (tm-define-overloaded (%tm-zotero-ext:ensure-ztHrefFromCiteToBib-interned! zfieldID-t hashLabel-t) ""))

  ((define-property* which)  opt decl)
    <= ((#:secure)  () (tm-define-overloaded (tm-zotero-ext:get-ztbibItemRefsList sysID-t left-t right-t) (let* ((documentID (get-documentID)) (sysID (tree->stree sysID-t)) (zhd-ls-key (string-append documentID ztbibItemRef-hashlabel-string-prefix sysID)) (zhd-ls (hash-ref documentID+zfieldID+sysID-><ztHrefFromCiteToBib-data>-ht zhd-ls-key (quote ()))) (ref-labels-ls (map the-ref-label-of zhd-ls))) (if (null? ref-labels-ls) "" (quasiquote (concat (unquote (tree->stree left-t)) (zt-ref-sep (unquote-splicing ref-labels-ls)) (unquote (tree->stree right-t))))))))
    => ((quote tm-zotero-ext:get-ztbibItemRefsList) #:secure (list))
 => cons <> cur-props
    => cur-props => (((quote tm-zotero-ext:get-ztbibItemRefsList) #:secure (list)))

(property-set! var prop what conds*)
  <= (tm-zotero-ext:get-ztbibItemRefsList #:secure () ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  () (tm-define-overloaded (tm-zotero-ext:document-has-zbibliography? t) (let* ((documentID (get-documentID)) (dd (get-<document-data> documentID)) (zbibliography-zfd-ls (document-zbibliography-zfd-ls dd))) (if (and (pair? zbibliography-zfd-ls) (nnull? zbibliography-zfd-ls)) "true" "false"))))
    => ((quote tm-zotero-ext:document-has-zbibliography?) #:secure (list))
 => cons <> cur-props
    => cur-props => (((quote tm-zotero-ext:document-has-zbibliography?) #:secure (list)))

(property-set! var prop what conds*)
  <= (tm-zotero-ext:document-has-zbibliography? #:secure () ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  () (tm-define-overloaded (tm-zotero-ext:inside-footnote? zfieldID-t) (if (inside-footnote? zfieldID-t) "true" "false")))
    => ((quote tm-zotero-ext:inside-footnote?) #:secure (list))
 => cons <> cur-props
    => cur-props => (((quote tm-zotero-ext:inside-footnote?) #:secure (list)))

(property-set! var prop what conds*)
  <= (tm-zotero-ext:inside-footnote? #:secure () ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  () (tm-define-overloaded (tm-zotero-ext:inside-endnote? zfieldID-t) (if (inside-endnote? zfieldID-t) "true" "false")))
    => ((quote tm-zotero-ext:inside-endnote?) #:secure (list))
 => cons <> cur-props
    => cur-props => (((quote tm-zotero-ext:inside-endnote?) #:secure (list)))

(property-set! var prop what conds*)
  <= (tm-zotero-ext:inside-endnote? #:secure () ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  () (tm-define-overloaded (tm-zotero-ext:inside-note? zfieldID-t) (if (inside-note? zfieldID-t) "true" "false")))
    => ((quote tm-zotero-ext:inside-note?) #:secure (list))
 => cons <> cur-props
    => cur-props => (((quote tm-zotero-ext:inside-note?) #:secure (list)))

(property-set! var prop what conds*)
  <= (tm-zotero-ext:inside-note? #:secure () ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  () (tm-define-overloaded (tm-zotero-ext:inside-zcite? t) (if (inside-zcite? t) "true" "false")))
    => ((quote tm-zotero-ext:inside-zcite?) #:secure (list))
 => cons <> cur-props
    => cur-props => (((quote tm-zotero-ext:inside-zcite?) #:secure (list)))

(property-set! var prop what conds*)
  <= (tm-zotero-ext:inside-zcite? #:secure () ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  () (tm-define-overloaded (tm-zotero-ext:inside-zbibliography? t) (if (inside-zbibliography? t) "true" "false")))
    => ((quote tm-zotero-ext:inside-zbibliography?) #:secure (list))
 => cons <> cur-props
    => cur-props => (((quote tm-zotero-ext:inside-zbibliography?) #:secure (list)))

(property-set! var prop what conds*)
  <= (tm-zotero-ext:inside-zbibliography? #:secure () ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  () (tm-define-overloaded (tm-zotero-ext:not-inside-zbibliography? t) (if (inside-zbibliography? t) "false" "true")))
    => ((quote tm-zotero-ext:not-inside-zbibliography?) #:secure (list))
 => cons <> cur-props
    => cur-props => (((quote tm-zotero-ext:not-inside-zbibliography?) #:secure (list)))

(property-set! var prop what conds*)
  <= (tm-zotero-ext:not-inside-zbibliography? #:secure () ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  () (tm-define-overloaded (tm-zotero-ext:inside-zfield? t) (if (inside-zfield? t) "true" "false")))
    => ((quote tm-zotero-ext:inside-zfield?) #:secure (list))
 => cons <> cur-props
    => cur-props => (((quote tm-zotero-ext:inside-zfield?) #:secure (list)))

(property-set! var prop what conds*)
  <= (tm-zotero-ext:inside-zfield? #:secure () ())

  ((define-property* which)  opt decl)
    <= ((#:secure)  () (tm-define-overloaded (tm-zotero-ext:inside-inactive? t) (if (inside-inactive? t) "true" "false")))
    => ((quote tm-zotero-ext:inside-inactive?) #:secure (list))
 => cons <> cur-props
    => cur-props => (((quote tm-zotero-ext:inside-inactive?) #:secure (list)))

(property-set! var prop what conds*)
  <= (tm-zotero-ext:inside-inactive? #:secure () ())

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("indent current line of a mathemagix program") (tm-define-overloaded (mmx-indent) (and-with doc (program-tree) (with i (compute-indentation (program-row-number)) (program-set-indent i) (program-go-to (program-row-number) i)))))
   => ((quote mmx-indent) #:synopsis (quote ("indent current line of a mathemagix program")))
 => cons <> cur-props
   => cur-props => (((quote mmx-indent) #:synopsis (quote ("indent current line of a mathemagix program"))))

(property-set! var prop what conds*)
  <= (mmx-indent #:synopsis ("indent current line of a mathemagix program") ())

  (define-option-require opt decl)
    <= (((and (in-prog-caas?) (not (inside? (quote session))))) (tm-define-overloaded (kbd-variant t forward?) (mmx-indent)))
    => (define-option-match opt decl) <= ((lambda (t forward?) (and (in-prog-caas?) (not (inside? (quote session))))) (tm-define-overloaded (kbd-variant t forward?) (mmx-indent)))

  (define-option-mode opt decl)
    <= ((in-prog-caas?) (tm-define-overloaded (insert-return) (insert-raw-return) (mmx-indent)))
    (ctx-add-condition! 0 (car opt)) => cur-conds => (in-prog-caas?)

  (define-option-require opt decl)
    <= (((coq-command-context? t)) (tm-define-overloaded (kbd-enter t shift?) (with cmd (quasiquote (coq-command (unquote (create-unique-id)) "dark grey" "")) (if shift? (with-innermost doc (quote document) (with i (+ (tree-down-index doc) 1) (tree-insert! doc i (list cmd)) (tree-go-to doc i 2 0))) (begin (if (tree-is? t #:up (quote concat)) (set! t (tree-up t)) (tree-set! t (quasiquote (concat (unquote t))))) (with i (+ (tree-down-index t) 1) (tree-insert! t i (list cmd)) (tree-go-to t i 2 0)))))))
    => (define-option-match opt decl) <= ((lambda (t shift?) (coq-command-context? t)) (tm-define-overloaded (kbd-enter t shift?) (with cmd (quasiquote (coq-command (unquote (create-unique-id)) "dark grey" "")) (if shift? (with-innermost doc (quote document) (with i (+ (tree-down-index doc) 1) (tree-insert! doc i (list cmd)) (tree-go-to doc i 2 0))) (begin (if (tree-is? t #:up (quote concat)) (set! t (tree-up t)) (tree-set! t (quasiquote (concat (unquote t))))) (with i (+ (tree-down-index t) 1) (tree-insert! t i (list cmd)) (tree-go-to t i 2 0)))))))

  (define-option-require opt decl)
    <= (((and (tree-is-buffer? t) (in-coq-style?))) (tm-define-overloaded (kbd-control-enter t shift?) (coq-check)))
    => (define-option-match opt decl) <= ((lambda (t shift?) (and (tree-is-buffer? t) (in-coq-style?))) (tm-define-overloaded (kbd-control-enter t shift?) (coq-check)))

  (define-option-require opt decl)
    <= (((and (in-prog-mathemagix?) (not (inside? (quote session))))) (tm-define-overloaded (kbd-variant t forward?) (mmx-indent)))
    => (define-option-match opt decl) <= ((lambda (t forward?) (and (in-prog-mathemagix?) (not (inside? (quote session))))) (tm-define-overloaded (kbd-variant t forward?) (mmx-indent)))

  (define-option-mode opt decl)
    <= ((in-prog-mathemagix?) (tm-define-overloaded (insert-return) (insert-raw-return) (mmx-indent)))
    (ctx-add-condition! 0 (car opt)) => cur-conds => (in-prog-mathemagix?)

  (define-option-require opt decl)
    <= (((and (in-prog-mmi?) (not (inside? (quote session))))) (tm-define-overloaded (kbd-variant t forward?) (mmx-indent)))
    => (define-option-match opt decl) <= ((lambda (t forward?) (and (in-prog-mmi?) (not (inside? (quote session))))) (tm-define-overloaded (kbd-variant t forward?) (mmx-indent)))

  (define-option-mode opt decl)
    <= ((in-prog-mmi?) (tm-define-overloaded (insert-return) (insert-raw-return) (mmx-indent)))
    (ctx-add-condition! 0 (car opt)) => cur-conds => (in-prog-mmi?)

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("indent current line of a r program") (tm-define-overloaded (r-indent) (and-with doc (program-tree) (with i (compute-indentation (program-row-number)) (program-set-indent i) (program-go-to (program-row-number) i)))))
   => ((quote r-indent) #:synopsis (quote ("indent current line of a r program")))
 => cons <> cur-props
   => cur-props => (((quote r-indent) #:synopsis (quote ("indent current line of a r program"))))

(property-set! var prop what conds*)
  <= (r-indent #:synopsis ("indent current line of a r program") ())

  (define-option-require opt decl)
    <= (((and (in-prog-r?) (not (inside? (quote session))))) (tm-define-overloaded (kbd-variant t forward?) (r-indent)))
    => (define-option-match opt decl) <= ((lambda (t forward?) (and (in-prog-r?) (not (inside? (quote session))))) (tm-define-overloaded (kbd-variant t forward?) (r-indent)))

  (define-option-mode opt decl)
    <= ((in-prog-r?) (tm-define-overloaded (insert-return) (insert-raw-return) (r-indent)))
    (ctx-add-condition! 0 (car opt)) => cur-conds => (in-prog-r?)

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-property-overloaded (search-start forward?)))
    => ((quote search-start) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote search-start) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (search-start #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-property-overloaded (spell-start)))
    => ((quote spell-start) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote spell-start) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (spell-start #:interactive (#t) ())

  ((define-property* which)  opt decl)
    <= ((#:check-mark)  ("v" save-aux-enabled?) (tm-define-overloaded (toggle-save-aux) (let ((new (if (== (get-env "save-aux") "true") "false" "true"))) (init-env "save-aux" new))))
    => ((quote toggle-save-aux) #:check-mark (list "v" save-aux-enabled?))
 => cons <> cur-props
    => cur-props => (((quote toggle-save-aux) #:check-mark (list "v" save-aux-enabled?)))

  ((define-property which)  opt decl)
    <= ((#:synopsis)  ("Toggle whether we save auxiliary data.") (tm-define-overloaded (toggle-save-aux) (let ((new (if (== (get-env "save-aux") "true") "false" "true"))) (init-env "save-aux" new))))
   => ((quote toggle-save-aux) #:synopsis (quote ("Toggle whether we save auxiliary data.")))
 => cons <> cur-props
   => cur-props => (((quote toggle-save-aux) #:synopsis (quote ("Toggle whether we save auxiliary data."))) ((quote toggle-save-aux) #:check-mark (list "v" save-aux-enabled?)))

(property-set! var prop what conds*)
  <= (toggle-save-aux #:synopsis ("Toggle whether we save auxiliary data.") ())

(property-set! var prop what conds*)
  <= (toggle-save-aux #:check-mark ("v" #<procedure save-aux-enabled? ()>) ())

  ((define-property* which)  opt decl)
    <= ((#:interactive)  (#t) (tm-define-overloaded (open-preferences) (top-window preferences-widget "User preferences")))
    => ((quote open-preferences) #:interactive (list #t))
 => cons <> cur-props
    => cur-props => (((quote open-preferences) #:interactive (list #t)))

(property-set! var prop what conds*)
  <= (open-preferences #:interactive (#t) ())

  (define-option-require opt decl)
    <= (((in? l (quote (math equation equation* eqnarray eqnarray*)))) (tm-define-overloaded (standard-options l) (list #:recurse "number-long-article" "math-check")))
    => (define-option-match opt decl) <= ((lambda (l) (in? l (quote (math equation equation* eqnarray eqnarray*)))) (tm-define-overloaded (standard-options l) (list #:recurse "number-long-article" "math-check")))

  (define-option-require opt decl)
    <= (((== l (quote math-colored))) (tm-define-overloaded (standard-options l) (list "math-ss")))
    => (define-option-match opt decl) <= ((lambda (l) (== l (quote math-colored))) (tm-define-overloaded (standard-options l) (list "math-ss")))

  (define-option-require opt decl)
    <= (((== l (quote math))) (tm-define-overloaded (focus-tag-name l) "Inline formula"))
    => (define-option-match opt decl) <= ((lambda (l) (== l (quote math))) (tm-define-overloaded (focus-tag-name l) "Inline formula"))

  (define-option-require opt decl)
    <= (((in? l (quote (equation equation*)))) (tm-define-overloaded (focus-tag-name l) "Displayed formula"))
    => (define-option-match opt decl) <= ((lambda (l) (in? l (quote (equation equation*)))) (tm-define-overloaded (focus-tag-name l) "Displayed formula"))

  (define-option-require opt decl)
    <= (((in? l (quote (eqnarray eqnarray*)))) (tm-define-overloaded (focus-tag-name l) "Equations"))
    => (define-option-match opt decl) <= ((lambda (l) (in? l (quote (eqnarray eqnarray*)))) (tm-define-overloaded (focus-tag-name l) "Equations"))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (math equation equation*)))) (tm-define-overloaded (focus-variants-of t) (quote (formula equation))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (math equation equation*)))) (tm-define-overloaded (focus-variants-of t) (quote (formula equation))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (eqnarray eqnarray*)))) (tm-define-overloaded (focus-variants-of t) (quote (eqnarray*))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (eqnarray eqnarray*)))) (tm-define-overloaded (focus-variants-of t) (quote (eqnarray*))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (math equation equation*)))) (tm-define-overloaded (focus-variant-menu t) (menu-dynamic ("Inline formula" (variant-formula t)) ("Displayed formula" (variant-equation t)))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (math equation equation*)))) (tm-define-overloaded (focus-variant-menu t) (menu-dynamic ("Inline formula" (variant-formula t)) ("Displayed formula" (variant-equation t)))))

  (define-option-require opt decl)
    <= (((script-context? t)) (tm-define-overloaded (focus-can-insert-remove? t) #t))
    => (define-option-match opt decl) <= ((lambda (t) (script-context? t)) (tm-define-overloaded (focus-can-insert-remove? t) #t))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (lsub lsup)))) (tm-define-overloaded (focus-variants-of t) (quote (lsub lsup))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (lsub lsup)))) (tm-define-overloaded (focus-variants-of t) (quote (lsub lsup))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (rsub rsup)))) (tm-define-overloaded (focus-variants-of t) (quote (rsub rsup))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (rsub rsup)))) (tm-define-overloaded (focus-variants-of t) (quote (rsub rsup))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (lsub lsup)))) (tm-define-overloaded (focus-variant-menu t) (menu-dynamic (when (script-only-script? t) ("Left subscript" (variant-set (focus-tree) (quote lsub))) ("Left superscript" (variant-set (focus-tree) (quote lsup)))))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (lsub lsup)))) (tm-define-overloaded (focus-variant-menu t) (menu-dynamic (when (script-only-script? t) ("Left subscript" (variant-set (focus-tree) (quote lsub))) ("Left superscript" (variant-set (focus-tree) (quote lsup)))))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (rsub rsup)))) (tm-define-overloaded (focus-variant-menu t) (menu-dynamic (when (script-only-script? t) ("Subscript" (variant-set (focus-tree) (quote rsub))) ("Superscript" (variant-set (focus-tree) (quote rsup)))))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (rsub rsup)))) (tm-define-overloaded (focus-variant-menu t) (menu-dynamic (when (script-only-script? t) ("Subscript" (variant-set (focus-tree) (quote rsub))) ("Superscript" (variant-set (focus-tree) (quote rsup)))))))

  (define-option-require opt decl)
    <= (((script-context? t)) (tm-define-overloaded (focus-insert-menu t) (menu-dynamic (assuming (tree-in? t (quote (lsub rsub))) (when (script-only-script? t) ("Insert superscript" (structured-insert-up)))) (assuming (tree-in? t (quote (lsup rsup))) (when (script-only-script? t) ("Insert subscript" (structured-insert-down)))))))
    => (define-option-match opt decl) <= ((lambda (t) (script-context? t)) (tm-define-overloaded (focus-insert-menu t) (menu-dynamic (assuming (tree-in? t (quote (lsub rsub))) (when (script-only-script? t) ("Insert superscript" (structured-insert-up)))) (assuming (tree-in? t (quote (lsup rsup))) (when (script-only-script? t) ("Insert subscript" (structured-insert-down)))))))

  (define-option-require opt decl)
    <= (((script-context? t)) (tm-define-overloaded (focus-insert-icons t) (menu-dynamic (assuming (tree-in? t (quote (lsub rsub))) (when (script-only-script? t) ((balloon (icon "tm_insert_up.xpm") "Insert superscript") (structured-insert-up)))) (assuming (tree-in? t (quote (lsup rsup))) (when (script-only-script? t) ((balloon (icon "tm_insert_down.xpm") "Insert subscript") (structured-insert-down)))))))
    => (define-option-match opt decl) <= ((lambda (t) (script-context? t)) (tm-define-overloaded (focus-insert-icons t) (menu-dynamic (assuming (tree-in? t (quote (lsub rsub))) (when (script-only-script? t) ((balloon (icon "tm_insert_up.xpm") "Insert superscript") (structured-insert-up)))) (assuming (tree-in? t (quote (lsup rsup))) (when (script-only-script? t) ((balloon (icon "tm_insert_down.xpm") "Insert subscript") (structured-insert-down)))))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote sqrt))) (tm-define-overloaded (focus-can-insert-remove? t) #f))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote sqrt))) (tm-define-overloaded (focus-can-insert-remove? t) #f))

  (define-option-require opt decl)
    <= (((tree-is? t (quote sqrt))) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic ((check "Multiple root" "v" (== (tree-arity (focus-tree)) 2)) (sqrt-toggle (focus-tree))))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote sqrt))) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic ((check "Multiple root" "v" (== (tree-arity (focus-tree)) 2)) (sqrt-toggle (focus-tree))))))

  (define-option-require opt decl)
    <= (((tree-is? t (quote sqrt))) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic ((check (balloon (icon "tm_root_index.xpm") "Multiple root") "v" (== (tree-arity (focus-tree)) 2)) (sqrt-toggle (focus-tree))))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-is? t (quote sqrt))) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic ((check (balloon (icon "tm_root_index.xpm") "Multiple root") "v" (== (tree-arity (focus-tree)) 2)) (sqrt-toggle (focus-tree))))))

  (define-option-require opt decl)
    <= (((in? l (quote (wide wide*)))) (tm-define-overloaded (focus-tag-name l) "Wide"))
    => (define-option-match opt decl) <= ((lambda (l) (in? l (quote (wide wide*)))) (tm-define-overloaded (focus-tag-name l) "Wide"))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (wide wide*)))) (tm-define-overloaded (focus-variants-of t) (quote (wide))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (wide wide*)))) (tm-define-overloaded (focus-variants-of t) (quote (wide))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (wide wide*)))) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic ((check "Accent below" "v" (alternate-second? (focus-tree))) (alternate-toggle (focus-tree))))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (wide wide*)))) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic ((check "Accent below" "v" (alternate-second? (focus-tree))) (alternate-toggle (focus-tree))))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (wide wide*)))) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic ((check (balloon (icon "tm_wide_under.xpm") "Accent below") "v" (alternate-second? (focus-tree))) (alternate-toggle (focus-tree))))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (wide wide*)))) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic ((check (balloon (icon "tm_wide_under.xpm") "Accent below") "v" (alternate-second? (focus-tree))) (alternate-toggle (focus-tree))))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (around around*)))) (tm-define-overloaded (focus-has-preferences? t) #t))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (around around*)))) (tm-define-overloaded (focus-has-preferences? t) #t))

  (define-option-require opt decl)
    <= (((in? l (quote (around around*)))) (tm-define-overloaded (standard-options l) (list "math-brackets")))
    => (define-option-match opt decl) <= ((lambda (l) (in? l (quote (around around*)))) (tm-define-overloaded (standard-options l) (list "math-brackets")))

  (define-option-require opt decl)
    <= (((in? l (quote (around around*)))) (tm-define-overloaded (focus-tag-name l) "Around"))
    => (define-option-match opt decl) <= ((lambda (l) (in? l (quote (around around*)))) (tm-define-overloaded (focus-tag-name l) "Around"))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (around around*)))) (tm-define-overloaded (focus-variants-of t) (quote (around))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (around around*)))) (tm-define-overloaded (focus-variants-of t) (quote (around))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (around around*)))) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic ((check "Large brackets" "v" (alternate-second? (focus-tree))) (alternate-toggle (focus-tree))))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (around around*)))) (tm-define-overloaded (focus-toggle-menu t) (menu-dynamic ((check "Large brackets" "v" (alternate-second? (focus-tree))) (alternate-toggle (focus-tree))))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (left mid right around around*)))) (tm-define-overloaded (focus-extra-menu t) (menu-dynamic --- ("Increase size" (geometry-up)) ("Decrease size" (geometry-down)) ("Default size" (geometry-reset)))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (left mid right around around*)))) (tm-define-overloaded (focus-extra-menu t) (menu-dynamic --- ("Increase size" (geometry-up)) ("Decrease size" (geometry-down)) ("Default size" (geometry-reset)))))

  (define-option-require opt decl)
    <= (((tree-in? t (quote (around around*)))) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic ((check (balloon (icon "tm_large_around.xpm") "Large brackets") "v" (alternate-second? (focus-tree))) (alternate-toggle (focus-tree))))))
    => (define-option-match opt decl) <= ((lambda (t) (tree-in? t (quote (around around*)))) (tm-define-overloaded (focus-toggle-icons t) (menu-dynamic ((check (balloon (icon "tm_large_around.xpm") "Large brackets") "v" (alternate-second? (focus-tree))) (alternate-toggle (focus-tree))))))

  (define-option-mode opt decl)
    <= ((in-tm-zotero-style?) (tm-define-overloaded (texmacs-extra-menu) (menu-dynamic (link tm-zotero-menu))))
    (ctx-add-condition! 0 (car opt)) => cur-conds => (in-tm-zotero-style?)

(property var prop)
  <= (init-default #:check-mark) => ("*" #<procedure test-default? vals>)

(property var prop)
  <= (init-default #:interactive) => #f

(property var prop)
  <= (init-default #:balloon) => #f

(property var prop)
  <= (init-default #:synopsis) => #f

(property var prop)
  <= (init-env #:check-mark) => ("*" #<procedure test-init? (var val)>)

(property var prop)
  <= (init-env #:interactive) => #f

(property var prop)
  <= (init-env #:balloon) => #f

(property var prop)
  <= (init-env #:synopsis) => #f

(property var prop)
  <= (init-env #:check-mark) => ("*" #<procedure test-init? (var val)>)

(property var prop)
  <= (init-env #:interactive) => #f

(property var prop)
  <= (init-env #:balloon) => #f

(property var prop)
  <= (init-env #:synopsis) => #f

(property var prop)
  <= (init-env #:check-mark) => ("*" #<procedure test-init? (var val)>)

(property var prop)
  <= (init-env #:interactive) => #f

(property var prop)
  <= (init-env #:balloon) => #f

(property var prop)
  <= (init-env #:synopsis) => #f

(property var prop)
  <= (init-env #:check-mark) => ("*" #<procedure test-init? (var val)>)

(property var prop)
  <= (init-env #:interactive) => #f

(property var prop)
  <= (init-env #:balloon) => #f

(property var prop)
  <= (init-env #:synopsis) => #f

(property var prop)
  <= (init-env #:check-mark) => ("*" #<procedure test-init? (var val)>)

(property var prop)
  <= (init-env #:interactive) => #f

(property var prop)
  <= (init-env #:balloon) => #f

(property var prop)
  <= (init-env #:synopsis) => #f

(property var prop)
  <= (init-env #:check-mark) => ("*" #<procedure test-init? (var val)>)

(property var prop)
  <= (init-env #:interactive) => #f

(property var prop)
  <= (init-env #:balloon) => #f

(property var prop)
  <= (init-env #:synopsis) => #f

(property var prop)
  <= (init-interactive-env #:check-mark) => #f

(property var prop)
  <= (init-interactive-env #:interactive) => (#t)

(property var prop)
  <= (init-interactive-env #:balloon) => #f

(property var prop)
  <= (init-interactive-env #:synopsis) => #f

(property var prop)
  <= (make-locus #:check-mark) => #f

(property var prop)
  <= (make-locus #:interactive) => #f

(property var prop)
  <= (make-locus #:balloon) => #f

(property var prop)
  <= (make-locus #:synopsis) => #f

(property var prop)
  <= (link-set-locus #:check-mark) => ("auto" #<procedure link-on-locus? (nr)>)

(property var prop)
  <= (link-set-locus #:interactive) => #f

(property var prop)
  <= (link-set-locus #:balloon) => #f

(property var prop)
  <= (link-set-locus #:synopsis) => ("Set locus number @nr of a link.")

(property var prop)
  <= (noop #:check-mark) => #f

(property var prop)
  <= (noop #:interactive) => #f

(property var prop)
  <= (noop #:balloon) => #f

(property var prop)
  <= (noop #:synopsis) => #f

(property var prop)
  <= (make-doc-data #:check-mark) => #f

(property var prop)
  <= (make-doc-data #:interactive) => #f

(property var prop)
  <= (make-doc-data #:balloon) => #f

(property var prop)
  <= (make-doc-data #:synopsis) => #f

(property var prop)
  <= (focus-help #:check-mark) => #f

(property var prop)
  <= (focus-help #:interactive) => #f

(property var prop)
  <= (focus-help #:balloon) => #f

(property var prop)
  <= (focus-help #:synopsis) => #f

(property var prop)
  <= (init-default #:check-mark) => ("*" #<procedure test-default? vals>)

(property var prop)
  <= (init-default #:interactive) => #f

(property var prop)
  <= (init-default #:balloon) => #f

(property var prop)
  <= (init-default #:synopsis) => #f

(property var prop)
  <= (init-env #:check-mark) => ("*" #<procedure test-init? (var val)>)

(property var prop)
  <= (init-env #:interactive) => #f

(property var prop)
  <= (init-env #:balloon) => #f

(property var prop)
  <= (init-env #:synopsis) => #f

(property var prop)
  <= (init-env #:check-mark) => ("*" #<procedure test-init? (var val)>)

(property var prop)
  <= (init-env #:interactive) => #f

(property var prop)
  <= (init-env #:balloon) => #f

(property var prop)
  <= (init-env #:synopsis) => #f

(property var prop)
  <= (init-env #:check-mark) => ("*" #<procedure test-init? (var val)>)

(property var prop)
  <= (init-env #:interactive) => #f

(property var prop)
  <= (init-env #:balloon) => #f

(property var prop)
  <= (init-env #:synopsis) => #f

(property var prop)
  <= (init-env #:check-mark) => ("*" #<procedure test-init? (var val)>)

(property var prop)
  <= (init-env #:interactive) => #f

(property var prop)
  <= (init-env #:balloon) => #f

(property var prop)
  <= (init-env #:synopsis) => #f

(property var prop)
  <= (init-env #:check-mark) => ("*" #<procedure test-init? (var val)>)

(property var prop)
  <= (init-env #:interactive) => #f

(property var prop)
  <= (init-env #:balloon) => #f

(property var prop)
  <= (init-env #:synopsis) => #f

(property var prop)
  <= (init-env #:check-mark) => ("*" #<procedure test-init? (var val)>)

(property var prop)
  <= (init-env #:interactive) => #f

(property var prop)
  <= (init-env #:balloon) => #f

(property var prop)
  <= (init-env #:synopsis) => #f

(property var prop)
  <= (init-interactive-env #:check-mark) => #f

(property var prop)
  <= (init-interactive-env #:interactive) => (#t)

(property var prop)
  <= (init-interactive-env #:balloon) => #f

(property var prop)
  <= (init-interactive-env #:synopsis) => #f

(property var prop)
  <= (init-page-rendering #:check-mark) => ("*" #<procedure test-page-rendering? (s)>)

(property var prop)
  <= (init-page-rendering #:interactive) => #f

(property var prop)
  <= (init-page-rendering #:balloon) => #f

(property var prop)
  <= (init-page-rendering #:synopsis) => #f

(property var prop)
  <= (init-page-rendering #:check-mark) => ("*" #<procedure test-page-rendering? (s)>)

(property var prop)
  <= (init-page-rendering #:interactive) => #f

(property var prop)
  <= (init-page-rendering #:balloon) => #f

(property var prop)
  <= (init-page-rendering #:synopsis) => #f

(property var prop)
  <= (init-page-rendering #:check-mark) => ("*" #<procedure test-page-rendering? (s)>)

(property var prop)
  <= (init-page-rendering #:interactive) => #f

(property var prop)
  <= (init-page-rendering #:balloon) => #f

(property var prop)
  <= (init-page-rendering #:synopsis) => #f

(property var prop)
  <= (init-page-rendering #:check-mark) => ("*" #<procedure test-page-rendering? (s)>)

(property var prop)
  <= (init-page-rendering #:interactive) => #f

(property var prop)
  <= (init-page-rendering #:balloon) => #f

(property var prop)
  <= (init-page-rendering #:synopsis) => #f

(property var prop)
  <= (init-page-rendering #:check-mark) => ("*" #<procedure test-page-rendering? (s)>)

(property var prop)
  <= (init-page-rendering #:interactive) => #f

(property var prop)
  <= (init-page-rendering #:balloon) => #f

(property var prop)
  <= (init-page-rendering #:synopsis) => #f

(property var prop)
  <= (init-page-rendering #:check-mark) => ("*" #<procedure test-page-rendering? (s)>)

(property var prop)
  <= (init-page-rendering #:interactive) => #f

(property var prop)
  <= (init-page-rendering #:balloon) => #f

(property var prop)
  <= (init-page-rendering #:synopsis) => #f

(property var prop)
  <= (init-page-orientation #:check-mark) => ("*" #<procedure test-page-orientation? (s)>)

(property var prop)
  <= (init-page-orientation #:interactive) => #f

(property var prop)
  <= (init-page-orientation #:balloon) => #f

(property var prop)
  <= (init-page-orientation #:synopsis) => #f

(property var prop)
  <= (init-page-orientation #:check-mark) => ("*" #<procedure test-page-orientation? (s)>)

(property var prop)
  <= (init-page-orientation #:interactive) => #f

(property var prop)
  <= (init-page-orientation #:balloon) => #f

(property var prop)
  <= (init-page-orientation #:synopsis) => #f

(property var prop)
  <= (init-env #:check-mark) => ("*" #<procedure test-init? (var val)>)

(property var prop)
  <= (init-env #:interactive) => #f

(property var prop)
  <= (init-env #:balloon) => #f

(property var prop)
  <= (init-env #:synopsis) => #f

(property var prop)
  <= (init-env #:check-mark) => ("*" #<procedure test-init? (var val)>)

(property var prop)
  <= (init-env #:interactive) => #f

(property var prop)
  <= (init-env #:balloon) => #f

(property var prop)
  <= (init-env #:synopsis) => #f

(property var prop)
  <= (set-default-document-language #:check-mark) => ("*" #<procedure test-default-document-language? ()>)

(property var prop)
  <= (set-default-document-language #:interactive) => #f

(property var prop)
  <= (set-default-document-language #:balloon) => #f

(property var prop)
  <= (set-default-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (init-default-font #:check-mark) => ("*" #<procedure test-default-font? ()>)

(property var prop)
  <= (init-default-font #:interactive) => #f

(property var prop)
  <= (init-default-font #:balloon) => #f

(property var prop)
  <= (init-default-font #:synopsis) => #f

(property var prop)
  <= (init-font #:check-mark) => ("*" #<procedure test-init-font? (val math-val)>)

(property var prop)
  <= (init-font #:interactive) => #f

(property var prop)
  <= (init-font #:balloon) => #f

(property var prop)
  <= (init-font #:synopsis) => #f

(property var prop)
  <= (init-font #:check-mark) => ("*" #<procedure test-init-font? (val math-val)>)

(property var prop)
  <= (init-font #:interactive) => #f

(property var prop)
  <= (init-font #:balloon) => #f

(property var prop)
  <= (init-font #:synopsis) => #f

(property var prop)
  <= (init-font #:check-mark) => ("*" #<procedure test-init-font? (val math-val)>)

(property var prop)
  <= (init-font #:interactive) => #f

(property var prop)
  <= (init-font #:balloon) => #f

(property var prop)
  <= (init-font #:synopsis) => #f

(property var prop)
  <= (init-font #:check-mark) => ("*" #<procedure test-init-font? (val math-val)>)

(property var prop)
  <= (init-font #:interactive) => #f

(property var prop)
  <= (init-font #:balloon) => #f

(property var prop)
  <= (init-font #:synopsis) => #f

(property var prop)
  <= (init-font #:check-mark) => ("*" #<procedure test-init-font? (val math-val)>)

(property var prop)
  <= (init-font #:interactive) => #f

(property var prop)
  <= (init-font #:balloon) => #f

(property var prop)
  <= (init-font #:synopsis) => #f

(property var prop)
  <= (init-font #:check-mark) => ("*" #<procedure test-init-font? (val math-val)>)

(property var prop)
  <= (init-font #:interactive) => #f

(property var prop)
  <= (init-font #:balloon) => #f

(property var prop)
  <= (init-font #:synopsis) => #f

(property var prop)
  <= (init-font #:check-mark) => ("*" #<procedure test-init-font? (val math-val)>)

(property var prop)
  <= (init-font #:interactive) => #f

(property var prop)
  <= (init-font #:balloon) => #f

(property var prop)
  <= (init-font #:synopsis) => #f

(property var prop)
  <= (init-font #:check-mark) => ("*" #<procedure test-init-font? (val math-val)>)

(property var prop)
  <= (init-font #:interactive) => #f

(property var prop)
  <= (init-font #:balloon) => #f

(property var prop)
  <= (init-font #:synopsis) => #f

(property var prop)
  <= (init-env #:check-mark) => ("*" #<procedure test-init? (var val)>)

(property var prop)
  <= (init-env #:interactive) => #f

(property var prop)
  <= (init-env #:balloon) => #f

(property var prop)
  <= (init-env #:synopsis) => #f

(property var prop)
  <= (open-document-font-selector #:check-mark) => #f

(property var prop)
  <= (open-document-font-selector #:interactive) => (#t)

(property var prop)
  <= (open-document-font-selector #:balloon) => #f

(property var prop)
  <= (open-document-font-selector #:synopsis) => #f

(property var prop)
  <= (init-default-font #:check-mark) => ("*" #<procedure test-default-font? ()>)

(property var prop)
  <= (init-default-font #:interactive) => #f

(property var prop)
  <= (init-default-font #:balloon) => #f

(property var prop)
  <= (init-default-font #:synopsis) => #f

(property var prop)
  <= (init-font #:check-mark) => ("*" #<procedure test-init-font? (val math-val)>)

(property var prop)
  <= (init-font #:interactive) => #f

(property var prop)
  <= (init-font #:balloon) => #f

(property var prop)
  <= (init-font #:synopsis) => #f

(property var prop)
  <= (init-font #:check-mark) => ("*" #<procedure test-init-font? (val math-val)>)

(property var prop)
  <= (init-font #:interactive) => #f

(property var prop)
  <= (init-font #:balloon) => #f

(property var prop)
  <= (init-font #:synopsis) => #f

(property var prop)
  <= (init-font #:check-mark) => ("*" #<procedure test-init-font? (val math-val)>)

(property var prop)
  <= (init-font #:interactive) => #f

(property var prop)
  <= (init-font #:balloon) => #f

(property var prop)
  <= (init-font #:synopsis) => #f

(property var prop)
  <= (init-font #:check-mark) => ("*" #<procedure test-init-font? (val math-val)>)

(property var prop)
  <= (init-font #:interactive) => #f

(property var prop)
  <= (init-font #:balloon) => #f

(property var prop)
  <= (init-font #:synopsis) => #f

(property var prop)
  <= (init-font #:check-mark) => ("*" #<procedure test-init-font? (val math-val)>)

(property var prop)
  <= (init-font #:interactive) => #f

(property var prop)
  <= (init-font #:balloon) => #f

(property var prop)
  <= (init-font #:synopsis) => #f

(property var prop)
  <= (init-font #:check-mark) => ("*" #<procedure test-init-font? (val math-val)>)

(property var prop)
  <= (init-font #:interactive) => #f

(property var prop)
  <= (init-font #:balloon) => #f

(property var prop)
  <= (init-font #:synopsis) => #f

(property var prop)
  <= (init-font #:check-mark) => ("*" #<procedure test-init-font? (val math-val)>)

(property var prop)
  <= (init-font #:interactive) => #f

(property var prop)
  <= (init-font #:balloon) => #f

(property var prop)
  <= (init-font #:synopsis) => #f

(property var prop)
  <= (init-font #:check-mark) => ("*" #<procedure test-init-font? (val math-val)>)

(property var prop)
  <= (init-font #:interactive) => #f

(property var prop)
  <= (init-font #:balloon) => #f

(property var prop)
  <= (init-font #:synopsis) => #f

(property var prop)
  <= (init-env #:check-mark) => ("*" #<procedure test-init? (var val)>)

(property var prop)
  <= (init-env #:interactive) => #f

(property var prop)
  <= (init-env #:balloon) => #f

(property var prop)
  <= (init-env #:synopsis) => #f

(property var prop)
  <= (open-document-font-selector #:check-mark) => #f

(property var prop)
  <= (open-document-font-selector #:interactive) => (#t)

(property var prop)
  <= (open-document-font-selector #:balloon) => #f

(property var prop)
  <= (open-document-font-selector #:synopsis) => #f

(property var prop)
  <= (set-default-document-language #:check-mark) => ("*" #<procedure test-default-document-language? ()>)

(property var prop)
  <= (set-default-document-language #:interactive) => #f

(property var prop)
  <= (set-default-document-language #:balloon) => #f

(property var prop)
  <= (set-default-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (set-document-language #:interactive) => #f

(property var prop)
  <= (set-document-language #:balloon) => #f

(property var prop)
  <= (set-document-language #:synopsis) => #f

(property var prop)
  <= (init-env #:check-mark) => ("*" #<procedure test-init? (var val)>)

(property var prop)
  <= (init-env #:interactive) => #f

(property var prop)
  <= (init-env #:balloon) => #f

(property var prop)
  <= (init-env #:synopsis) => #f

(property var prop)
  <= (init-env #:check-mark) => ("*" #<procedure test-init? (var val)>)

(property var prop)
  <= (init-env #:interactive) => #f

(property var prop)
  <= (init-env #:balloon) => #f

(property var prop)
  <= (init-env #:synopsis) => #f

(property var prop)
  <= (init-page-orientation #:check-mark) => ("*" #<procedure test-page-orientation? (s)>)

(property var prop)
  <= (init-page-orientation #:interactive) => #f

(property var prop)
  <= (init-page-orientation #:balloon) => #f

(property var prop)
  <= (init-page-orientation #:synopsis) => #f

(property var prop)
  <= (init-page-orientation #:check-mark) => ("*" #<procedure test-page-orientation? (s)>)

(property var prop)
  <= (init-page-orientation #:interactive) => #f

(property var prop)
  <= (init-page-orientation #:balloon) => #f

(property var prop)
  <= (init-page-orientation #:synopsis) => #f

(property var prop)
  <= (init-page-rendering #:check-mark) => ("*" #<procedure test-page-rendering? (s)>)

(property var prop)
  <= (init-page-rendering #:interactive) => #f

(property var prop)
  <= (init-page-rendering #:balloon) => #f

(property var prop)
  <= (init-page-rendering #:synopsis) => #f

(property var prop)
  <= (init-page-rendering #:check-mark) => ("*" #<procedure test-page-rendering? (s)>)

(property var prop)
  <= (init-page-rendering #:interactive) => #f

(property var prop)
  <= (init-page-rendering #:balloon) => #f

(property var prop)
  <= (init-page-rendering #:synopsis) => #f

(property var prop)
  <= (init-page-rendering #:check-mark) => ("*" #<procedure test-page-rendering? (s)>)

(property var prop)
  <= (init-page-rendering #:interactive) => #f

(property var prop)
  <= (init-page-rendering #:balloon) => #f

(property var prop)
  <= (init-page-rendering #:synopsis) => #f

(property var prop)
  <= (init-page-rendering #:check-mark) => ("*" #<procedure test-page-rendering? (s)>)

(property var prop)
  <= (init-page-rendering #:interactive) => #f

(property var prop)
  <= (init-page-rendering #:balloon) => #f

(property var prop)
  <= (init-page-rendering #:synopsis) => #f

(property var prop)
  <= (init-page-rendering #:check-mark) => ("*" #<procedure test-page-rendering? (s)>)

(property var prop)
  <= (init-page-rendering #:interactive) => #f

(property var prop)
  <= (init-page-rendering #:balloon) => #f

(property var prop)
  <= (init-page-rendering #:synopsis) => #f

(property var prop)
  <= (init-page-rendering #:check-mark) => ("*" #<procedure test-page-rendering? (s)>)

(property var prop)
  <= (init-page-rendering #:interactive) => #f

(property var prop)
  <= (init-page-rendering #:balloon) => #f

(property var prop)
  <= (init-page-rendering #:synopsis) => #f

(property var prop)
  <= (init-default #:check-mark) => ("*" #<procedure test-default? vals>)

(property var prop)
  <= (init-default #:interactive) => #f

(property var prop)
  <= (init-default #:balloon) => #f

(property var prop)
  <= (init-default #:synopsis) => #f

(property var prop)
  <= (init-env #:check-mark) => ("*" #<procedure test-init? (var val)>)

(property var prop)
  <= (init-env #:interactive) => #f

(property var prop)
  <= (init-env #:balloon) => #f

(property var prop)
  <= (init-env #:synopsis) => #f

(property var prop)
  <= (init-env #:check-mark) => ("*" #<procedure test-init? (var val)>)

(property var prop)
  <= (init-env #:interactive) => #f

(property var prop)
  <= (init-env #:balloon) => #f

(property var prop)
  <= (init-env #:synopsis) => #f

(property var prop)
  <= (init-env #:check-mark) => ("*" #<procedure test-init? (var val)>)

(property var prop)
  <= (init-env #:interactive) => #f

(property var prop)
  <= (init-env #:balloon) => #f

(property var prop)
  <= (init-env #:synopsis) => #f

(property var prop)
  <= (init-env #:check-mark) => ("*" #<procedure test-init? (var val)>)

(property var prop)
  <= (init-env #:interactive) => #f

(property var prop)
  <= (init-env #:balloon) => #f

(property var prop)
  <= (init-env #:synopsis) => #f

(property var prop)
  <= (init-env #:check-mark) => ("*" #<procedure test-init? (var val)>)

(property var prop)
  <= (init-env #:interactive) => #f

(property var prop)
  <= (init-env #:balloon) => #f

(property var prop)
  <= (init-env #:synopsis) => #f

(property var prop)
  <= (init-env #:check-mark) => ("*" #<procedure test-init? (var val)>)

(property var prop)
  <= (init-env #:interactive) => #f

(property var prop)
  <= (init-env #:balloon) => #f

(property var prop)
  <= (init-env #:synopsis) => #f

(property var prop)
  <= (init-interactive-env #:check-mark) => #f

(property var prop)
  <= (init-interactive-env #:interactive) => (#t)

(property var prop)
  <= (init-interactive-env #:balloon) => #f

(property var prop)
  <= (init-interactive-env #:synopsis) => #f

(property var prop)
  <= (init-page-type #:check-mark) => ("*" #<procedure test-page-type? (s)>)

(property var prop)
  <= (init-page-type #:interactive) => #f

(property var prop)
  <= (init-page-type #:balloon) => #f

(property var prop)
  <= (init-page-type #:synopsis) => #f

(property var prop)
  <= (init-page-type #:check-mark) => ("*" #<procedure test-page-type? (s)>)

(property var prop)
  <= (init-page-type #:interactive) => #f

(property var prop)
  <= (init-page-type #:balloon) => #f

(property var prop)
  <= (init-page-type #:synopsis) => #f

(property var prop)
  <= (init-page-type #:check-mark) => ("*" #<procedure test-page-type? (s)>)

(property var prop)
  <= (init-page-type #:interactive) => #f

(property var prop)
  <= (init-page-type #:balloon) => #f

(property var prop)
  <= (init-page-type #:synopsis) => #f

(property var prop)
  <= (init-page-type #:check-mark) => ("*" #<procedure test-page-type? (s)>)

(property var prop)
  <= (init-page-type #:interactive) => #f

(property var prop)
  <= (init-page-type #:balloon) => #f

(property var prop)
  <= (init-page-type #:synopsis) => #f

(property var prop)
  <= (init-page-type #:check-mark) => ("*" #<procedure test-page-type? (s)>)

(property var prop)
  <= (init-page-type #:interactive) => #f

(property var prop)
  <= (init-page-type #:balloon) => #f

(property var prop)
  <= (init-page-type #:synopsis) => #f

(property var prop)
  <= (init-page-type #:check-mark) => ("*" #<procedure test-page-type? (s)>)

(property var prop)
  <= (init-page-type #:interactive) => #f

(property var prop)
  <= (init-page-type #:balloon) => #f

(property var prop)
  <= (init-page-type #:synopsis) => #f

(property var prop)
  <= (init-page-type #:check-mark) => ("*" #<procedure test-page-type? (s)>)

(property var prop)
  <= (init-page-type #:interactive) => #f

(property var prop)
  <= (init-page-type #:balloon) => #f

(property var prop)
  <= (init-page-type #:synopsis) => #f

(property var prop)
  <= (init-page-type #:check-mark) => ("*" #<procedure test-page-type? (s)>)

(property var prop)
  <= (init-page-type #:interactive) => #f

(property var prop)
  <= (init-page-type #:balloon) => #f

(property var prop)
  <= (init-page-type #:synopsis) => #f

(property var prop)
  <= (interactive #:check-mark) => #f

(property var prop)
  <= (interactive #:interactive) => (#t)

(property var prop)
  <= (interactive #:balloon) => #f

(property var prop)
  <= (interactive #:synopsis) => ("Call @fun with interactively specified arguments @args")

(property var prop)
  <= (add-style-package #:check-mark) => ("v" #<procedure has-style-package? (pack)>)

(property var prop)
  <= (add-style-package #:interactive) => #f

(property var prop)
  <= (add-style-package #:balloon) => (#<procedure style-get-documentation (style)>)

(property var prop)
  <= (add-style-package #:synopsis) => #f

(property var prop)
  <= (add-style-package #:check-mark) => ("v" #<procedure has-style-package? (pack)>)

(property var prop)
  <= (add-style-package #:interactive) => #f

(property var prop)
  <= (add-style-package #:balloon) => (#<procedure style-get-documentation (style)>)

(property var prop)
  <= (add-style-package #:synopsis) => #f

(property var prop)
  <= (add-style-package #:check-mark) => ("v" #<procedure has-style-package? (pack)>)

(property var prop)
  <= (add-style-package #:interactive) => #f

(property var prop)
  <= (add-style-package #:balloon) => (#<procedure style-get-documentation (style)>)

(property var prop)
  <= (interactive #:check-mark) => #f

(property var prop)
  <= (interactive #:interactive) => (#t)

(property var prop)
  <= (interactive #:balloon) => #f

(property var prop)
  <= (interactive #:synopsis) => ("Call @fun with interactively specified arguments @args")

(property var prop)
  <= (set-main-style #:check-mark) => ("v" #<procedure has-main-style? (style)>)

(property var prop)
  <= (set-main-style #:interactive) => #f

(property var prop)
  <= (set-main-style #:balloon) => (#<procedure style-get-documentation (style)>)

(property var prop)
  <= (set-main-style #:check-mark) => ("v" #<procedure has-main-style? (style)>)

(property var prop)
  <= (set-main-style #:interactive) => #f

(property var prop)
  <= (set-main-style #:balloon) => (#<procedure style-get-documentation (style)>)

(property var prop)
  <= (set-main-style #:check-mark) => ("v" #<procedure has-main-style? (style)>)

(property var prop)
  <= (set-main-style #:interactive) => #f

(property var prop)
  <= (set-main-style #:balloon) => (#<procedure style-get-documentation (style)>)

(property var prop)
  <= (set-main-style #:check-mark) => ("v" #<procedure has-main-style? (style)>)

(property var prop)
  <= (set-main-style #:interactive) => #f

(property var prop)
  <= (set-main-style #:balloon) => (#<procedure style-get-documentation (style)>)

(property var prop)
  <= (set-main-style #:check-mark) => ("v" #<procedure has-main-style? (style)>)

(property var prop)
  <= (set-main-style #:interactive) => #f

(property var prop)
  <= (set-main-style #:balloon) => (#<procedure style-get-documentation (style)>)

(property var prop)
  <= (set-main-style #:check-mark) => ("v" #<procedure has-main-style? (style)>)

(property var prop)
  <= (set-main-style #:interactive) => #f

(property var prop)
  <= (set-main-style #:balloon) => (#<procedure style-get-documentation (style)>)

(property var prop)
  <= (set-main-style #:synopsis) => #f

(property var prop)
  <= (set-main-style #:check-mark) => ("v" #<procedure has-main-style? (style)>)

(property var prop)
  <= (set-main-style #:interactive) => #f

(property var prop)
  <= (set-main-style #:balloon) => (#<procedure style-get-documentation (style)>)

(property var prop)
  <= (set-main-style #:check-mark) => ("v" #<procedure has-main-style? (style)>)

(property var prop)
  <= (set-main-style #:interactive) => #f

(property var prop)
  <= (set-main-style #:balloon) => (#<procedure style-get-documentation (style)>)

(property var prop)
  <= (set-main-style #:synopsis) => #f

(property var prop)
  <= (set-main-style #:check-mark) => ("v" #<procedure has-main-style? (style)>)

(property var prop)
  <= (set-main-style #:interactive) => #f

(property var prop)
  <= (set-main-style #:balloon) => (#<procedure style-get-documentation (style)>)

(property var prop)
  <= (set-main-style #:check-mark) => ("v" #<procedure has-main-style? (style)>)

(property var prop)
  <= (set-main-style #:interactive) => #f

(property var prop)
  <= (set-main-style #:balloon) => (#<procedure style-get-documentation (style)>)

(property var prop)
  <= (edit-style-source #:check-mark) => #f

(property var prop)
  <= (edit-style-source #:interactive) => #f

(property var prop)
  <= (edit-style-source #:balloon) => #f

(property var prop)
  <= (edit-style-source #:synopsis) => #f

(property var prop)
  <= (interactive #:check-mark) => #f

(property var prop)
  <= (interactive #:interactive) => (#t)

(property var prop)
  <= (interactive #:balloon) => #f

(property var prop)
  <= (interactive #:synopsis) => ("Call @fun with interactively specified arguments @args")

(property var prop)
  <= (interactive #:check-mark) => #f

(property var prop)
  <= (interactive #:interactive) => (#t)

(property var prop)
  <= (interactive #:balloon) => #f

(property var prop)
  <= (interactive #:synopsis) => ("Call @fun with interactively specified arguments @args")

(property var prop)
  <= (open-paragraph-format #:check-mark) => #f

(property var prop)
  <= (open-paragraph-format #:interactive) => (#t)

(property var prop)
  <= (open-paragraph-format #:balloon) => #f

(property var prop)
  <= (open-paragraph-format #:synopsis) => #f

(property var prop)
  <= (open-page-format #:check-mark) => #f

(property var prop)
  <= (open-page-format #:interactive) => (#t)

(property var prop)
  <= (open-page-format #:balloon) => #f

(property var prop)
  <= (open-page-format #:synopsis) => #f

(property var prop)
  <= (open-cell-properties #:check-mark) => #f

(property var prop)
  <= (open-cell-properties #:interactive) => (#t)

(property var prop)
  <= (open-cell-properties #:balloon) => #f

(property var prop)
  <= (open-cell-properties #:synopsis) => #f

(property var prop)
  <= (open-table-properties #:check-mark) => #f

(property var prop)
  <= (open-table-properties #:interactive) => (#t)

(property var prop)
  <= (open-table-properties #:balloon) => #f

(property var prop)
  <= (open-table-properties #:synopsis) => #f

(property var prop)
  <= (interactive #:check-mark) => #f

(property var prop)
  <= (interactive #:interactive) => (#t)

(property var prop)
  <= (interactive #:balloon) => #f

(property var prop)
  <= (interactive #:synopsis) => ("Call @fun with interactively specified arguments @args")

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (noop #:check-mark) => #f

(property var prop)
  <= (noop #:interactive) => #f

(property var prop)
  <= (noop #:balloon) => #f

(property var prop)
  <= (noop #:synopsis) => #f

(property var prop)
  <= (noop #:check-mark) => #f

(property var prop)
  <= (noop #:interactive) => #f

(property var prop)
  <= (noop #:balloon) => #f

(property var prop)
  <= (noop #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (cmd #:check-mark) => #f

(property var prop)
  <= (cmd #:interactive) => #f

(property var prop)
  <= (cmd #:balloon) => #f

(property var prop)
  <= (cmd #:synopsis) => #f

(property var prop)
  <= (interactive-color #:check-mark) => #f

(property var prop)
  <= (interactive-color #:interactive) => (#t)

(property var prop)
  <= (interactive-color #:balloon) => #f

(property var prop)
  <= (interactive-color #:synopsis) => #f

(property var prop)
  <= (make-interactive-with #:check-mark) => #f

(property var prop)
  <= (make-interactive-with #:interactive) => (#t)

(property var prop)
  <= (make-interactive-with #:balloon) => #f

(property var prop)
  <= (make-interactive-with #:synopsis) => #f

(property var prop)
  <= (make-move #:check-mark) => #f

(property var prop)
  <= (make-move #:interactive) => #f

(property var prop)
  <= (make-move #:balloon) => #f

(property var prop)
  <= (make-move #:synopsis) => #f

(property var prop)
  <= (make-shift #:check-mark) => #f

(property var prop)
  <= (make-shift #:interactive) => #f

(property var prop)
  <= (make-shift #:balloon) => #f

(property var prop)
  <= (make-shift #:synopsis) => #f

(property var prop)
  <= (make-resize #:check-mark) => #f

(property var prop)
  <= (make-resize #:interactive) => #f

(property var prop)
  <= (make-resize #:balloon) => #f

(property var prop)
  <= (make-resize #:synopsis) => #f

(property var prop)
  <= (make-extend #:check-mark) => #f

(property var prop)
  <= (make-extend #:interactive) => #f

(property var prop)
  <= (make-extend #:balloon) => #f

(property var prop)
  <= (make-extend #:synopsis) => #f

(property var prop)
  <= (make-clipped #:check-mark) => #f

(property var prop)
  <= (make-clipped #:interactive) => #f

(property var prop)
  <= (make-clipped #:balloon) => #f

(property var prop)
  <= (make-clipped #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make-reduce-by #:check-mark) => #f

(property var prop)
  <= (make-reduce-by #:interactive) => #f

(property var prop)
  <= (make-reduce-by #:balloon) => #f

(property var prop)
  <= (make-reduce-by #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make-with-like #:check-mark) => #f

(property var prop)
  <= (make-with-like #:interactive) => #f

(property var prop)
  <= (make-with-like #:balloon) => #f

(property var prop)
  <= (make-with-like #:synopsis) => #f

(property var prop)
  <= (make-with-like #:check-mark) => #f

(property var prop)
  <= (make-with-like #:interactive) => #f

(property var prop)
  <= (make-with-like #:balloon) => #f

(property var prop)
  <= (make-with-like #:synopsis) => #f

(property var prop)
  <= (make-with-like #:check-mark) => #f

(property var prop)
  <= (make-with-like #:interactive) => #f

(property var prop)
  <= (make-with-like #:balloon) => #f

(property var prop)
  <= (make-with-like #:synopsis) => #f

(property var prop)
  <= (make-with-like #:check-mark) => #f

(property var prop)
  <= (make-with-like #:interactive) => #f

(property var prop)
  <= (make-with-like #:balloon) => #f

(property var prop)
  <= (make-with-like #:synopsis) => #f

(property var prop)
  <= (make-specific #:check-mark) => #f

(property var prop)
  <= (make-specific #:interactive) => #f

(property var prop)
  <= (make-specific #:balloon) => #f

(property var prop)
  <= (make-specific #:synopsis) => #f

(property var prop)
  <= (make-specific #:check-mark) => #f

(property var prop)
  <= (make-specific #:interactive) => #f

(property var prop)
  <= (make-specific #:balloon) => #f

(property var prop)
  <= (make-specific #:synopsis) => #f

(property var prop)
  <= (make-specific #:check-mark) => #f

(property var prop)
  <= (make-specific #:interactive) => #f

(property var prop)
  <= (make-specific #:balloon) => #f

(property var prop)
  <= (make-specific #:synopsis) => #f

(property var prop)
  <= (make-specific #:check-mark) => #f

(property var prop)
  <= (make-specific #:interactive) => #f

(property var prop)
  <= (make-specific #:balloon) => #f

(property var prop)
  <= (make-specific #:synopsis) => #f

(property var prop)
  <= (make-specific #:check-mark) => #f

(property var prop)
  <= (make-specific #:interactive) => #f

(property var prop)
  <= (make-specific #:balloon) => #f

(property var prop)
  <= (make-specific #:synopsis) => #f

(property var prop)
  <= (make-specific #:check-mark) => #f

(property var prop)
  <= (make-specific #:interactive) => #f

(property var prop)
  <= (make-specific #:balloon) => #f

(property var prop)
  <= (make-specific #:synopsis) => #f

(property var prop)
  <= (make-specific #:check-mark) => #f

(property var prop)
  <= (make-specific #:interactive) => #f

(property var prop)
  <= (make-specific #:balloon) => #f

(property var prop)
  <= (make-specific #:synopsis) => #f

(property var prop)
  <= (make-specific #:check-mark) => #f

(property var prop)
  <= (make-specific #:interactive) => #f

(property var prop)
  <= (make-specific #:balloon) => #f

(property var prop)
  <= (make-specific #:synopsis) => #f

(property var prop)
  <= (make-rigid #:check-mark) => #f

(property var prop)
  <= (make-rigid #:interactive) => #f

(property var prop)
  <= (make-rigid #:balloon) => #f

(property var prop)
  <= (make-rigid #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (make #:check-mark) => #f

(property var prop)
  <= (make #:interactive) => #f

(property var prop)
  <= (make #:balloon) => #f

(property var prop)
  <= (make #:synopsis) => #f

(property var prop)
  <= (add-style-package #:check-mark) => ("v" #<procedure has-style-package? (pack)>)

(property var prop)
  <= (add-style-package #:interactive) => #f

(property var prop)
  <= (add-style-package #:balloon) => (#<procedure style-get-documentation (style)>)

(property var prop)
  <= (add-style-package #:synopsis) => #f

(property var prop)
  <= (add-style-package #:check-mark) => ("v" #<procedure has-style-package? (pack)>)

(property var prop)
  <= (add-style-package #:interactive) => #f

(property var prop)
  <= (add-style-package #:balloon) => (#<procedure style-get-documentation (style)>)

(property var prop)
  <= (add-style-package #:synopsis) => #f

(property var prop)
  <= (add-style-package #:check-mark) => ("v" #<procedure has-style-package? (pack)>)

(property var prop)
  <= (add-style-package #:interactive) => #f

(property var prop)
  <= (add-style-package #:balloon) => (#<procedure style-get-documentation (style)>)

(property var prop)
  <= (interactive #:check-mark) => #f

(property var prop)
  <= (interactive #:interactive) => (#t)

(property var prop)
  <= (interactive #:balloon) => #f

(property var prop)
  <= (interactive #:synopsis) => ("Call @fun with interactively specified arguments @args")

(property var prop)
  <= (focus-help #:check-mark) => #f

(property var prop)
  <= (focus-help #:interactive) => #f

(property var prop)
  <= (make-doc-data #:check-mark) => #f

(property var prop)
  <= (make-doc-data #:interactive) => #f

(property var prop)
  <= (tm-zotero-addCitation #:check-mark) => #f

(property var prop)
  <= (tm-zotero-addCitation #:interactive) => #f

(property var prop)
  <= (tm-zotero-addCitation #:balloon) => #f

(property var prop)
  <= (tm-zotero-addCitation #:synopsis) => #f

(property var prop)
  <= (tm-zotero-editCitation #:check-mark) => #f

(property var prop)
  <= (tm-zotero-editCitation #:interactive) => #f

(property var prop)
  <= (tm-zotero-editCitation #:balloon) => #f

(property var prop)
  <= (tm-zotero-editCitation #:synopsis) => #f

(property var prop)
  <= (tm-zotero-affirmCitation #:check-mark) => #f

(property var prop)
  <= (tm-zotero-affirmCitation #:interactive) => #f

(property var prop)
  <= (tm-zotero-affirmCitation #:balloon) => #f

(property var prop)
  <= (tm-zotero-affirmCitation #:synopsis) => #f

(property var prop)
  <= (tm-zotero-addBibliography #:check-mark) => #f

(property var prop)
  <= (tm-zotero-addBibliography #:interactive) => #f

(property var prop)
  <= (tm-zotero-addBibliography #:balloon) => #f

(property var prop)
  <= (tm-zotero-addBibliography #:synopsis) => #f

(property var prop)
  <= (tm-zotero-editBibliography #:check-mark) => #f

(property var prop)
  <= (tm-zotero-editBibliography #:interactive) => #f

(property var prop)
  <= (tm-zotero-editBibliography #:balloon) => #f

(property var prop)
  <= (tm-zotero-editBibliography #:synopsis) => #f

(property var prop)
  <= (tm-zotero-refresh #:check-mark) => #f

(property var prop)
  <= (tm-zotero-refresh #:interactive) => #f

(property var prop)
  <= (tm-zotero-refresh #:balloon) => #f

(property var prop)
  <= (tm-zotero-refresh #:synopsis) => #f

(property var prop)
  <= (tm-zotero-setDocPrefs #:check-mark) => #f

(property var prop)
  <= (tm-zotero-setDocPrefs #:interactive) => #f

(property var prop)
  <= (tm-zotero-setDocPrefs #:balloon) => #f

(property var prop)
  <= (tm-zotero-setDocPrefs #:synopsis) => #f

(property var prop)
  <= (toggle-preference #:check-mark) => ("v" #<procedure preference-on? (which)>)

(property var prop)
  <= (toggle-preference #:interactive) => #f

(property var prop)
  <= (toggle-preference #:balloon) => #f

(property var prop)
  <= (toggle-preference #:synopsis) => ("Toggle the preference @which")

(property var prop)
  <= (new-buffer #:check-mark) => #f

(property var prop)
  <= (new-buffer #:interactive) => #f

(property var prop)
  <= (new-buffer #:balloon) => #f

(property var prop)
  <= (new-buffer #:synopsis) => #f

(property var prop)
  <= (open-buffer #:check-mark) => #f

(property var prop)
  <= (open-buffer #:interactive) => #f

(property var prop)
  <= (open-buffer #:balloon) => #f

(property var prop)
  <= (open-buffer #:synopsis) => ("Open a new file")

(property var prop)
  <= (revert-buffer #:check-mark) => #f

(property var prop)
  <= (revert-buffer #:interactive) => #f

(property var prop)
  <= (revert-buffer #:balloon) => #f

(property var prop)
  <= (revert-buffer #:synopsis) => #f

(property var prop)
  <= (save-buffer #:check-mark) => #f

(property var prop)
  <= (save-buffer #:interactive) => #f

(property var prop)
  <= (save-buffer #:balloon) => #f

(property var prop)
  <= (save-buffer #:synopsis) => #f

(property var prop)
  <= (choose-file #:check-mark) => #f

(property var prop)
  <= (choose-file #:interactive) => (#t)

(property var prop)
  <= (choose-file #:balloon) => #f

(property var prop)
  <= (choose-file #:synopsis) => #f

(property var prop)
  <= (preview-buffer #:check-mark) => #f

(property var prop)
  <= (preview-buffer #:interactive) => #f

(property var prop)
  <= (preview-buffer #:balloon) => #f

(property var prop)
  <= (preview-buffer #:synopsis) => #f

(property var prop)
  <= (interactive-print-buffer #:check-mark) => #f

(property var prop)
  <= (interactive-print-buffer #:interactive) => (#t)

(property var prop)
  <= (interactive-print-buffer #:balloon) => #f

(property var prop)
  <= (interactive-print-buffer #:synopsis) => ("Print the current buffer")

(property var prop)
  <= (safely-kill-buffer #:check-mark) => #f

(property var prop)
  <= (safely-kill-buffer #:interactive) => #f

(property var prop)
  <= (safely-kill-buffer #:balloon) => #f

(property var prop)
  <= (safely-kill-buffer #:synopsis) => #f

(property var prop)
  <= (safely-quit-TeXmacs #:check-mark) => #f

(property var prop)
  <= (safely-quit-TeXmacs #:interactive) => #f

(property var prop)
  <= (safely-quit-TeXmacs #:balloon) => #f

(property var prop)
  <= (safely-quit-TeXmacs #:synopsis) => #f

